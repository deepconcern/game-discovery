{"version":3,"sources":["webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/tslib/tslib.es6.js","webpack:///../src/invariant.ts","webpack:///../src/context/ApolloContext.ts","webpack:///../src/parser/parser.ts","webpack:///../src/context/ApolloProvider.tsx","webpack:///../src/storeUtils.ts","webpack:///../src/directives.ts","webpack:///../src/fragments.ts","webpack:///../src/util/assign.ts","webpack:///../src/getFromAST.ts","webpack:///../src/util/filterInPlace.ts","webpack:///../src/transform.ts","webpack:///../src/util/canUse.ts","webpack:///../src/util/cloneDeep.ts","webpack:///../src/util/environment.ts","webpack:///../src/util/errorHandling.ts","webpack:///../src/util/maybeDeepFreeze.ts","webpack:///../src/util/mergeDeep.ts","webpack:///../src/util/warnOnce.ts","webpack:///../src/equality.ts","webpack:///../src/zenObservable.ts","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/visitor.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/jsutils/inspect.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/jsutils/devAssert.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/jsutils/defineToJSON.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/error/syntaxError.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/location.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/blockString.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/tokenKind.js","webpack:///../src/data/OperationData.ts","webpack:///../src/data/QueryData.ts","webpack:///../src/data/MutationData.ts","webpack:///../src/data/SubscriptionData.ts","webpack:///../src/useApolloClient.ts","webpack:///../src/ssr/RenderPromises.ts","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/process/browser.js","webpack:///../src/core/networkStatus.ts","webpack:///../src/util/Observable.ts","webpack:///../src/util/arrays.ts","webpack:///../src/errors/ApolloError.ts","webpack:///../src/core/types.ts","webpack:///../src/core/ObservableQuery.ts","webpack:///../src/data/mutations.ts","webpack:///../src/data/queries.ts","webpack:///../src/core/LocalState.ts","webpack:///../src/util/capitalizeFirstLetter.ts","webpack:///../src/util/observables.ts","webpack:///../src/core/QueryManager.ts","webpack:///../src/data/store.ts","webpack:///../src/ApolloClient.ts","webpack:///../src/version.ts","webpack:///../src/linkUtils.ts","webpack:///../src/link.ts","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql-tag/src/index.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/parser.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/error/GraphQLError.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/jsutils/isObjectLike.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/printLocation.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/kinds.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/source.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/jsutils/defineToStringTag.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/lexer.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/directiveLocation.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/symbol-observable/es/index.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/symbol-observable/es/ponyfill.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/zen-observable/index.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/zen-observable/lib/Observable.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/fast-json-stable-stringify/index.js","webpack:////Users/wyattbarnes/workspace/game-discovery/node_modules/graphql/language/printer.js","webpack:///../src/utils.ts","webpack:///../src/types/Cache.ts","webpack:///../src/cache.ts","webpack:///../src/slot.ts","webpack:///../src/context.ts","webpack:///../src/entry.ts","webpack:///../src/key-trie.ts","webpack:///../src/index.ts","webpack:///../src/fragmentMatcher.ts","webpack:///../src/depTrackingCache.ts","webpack:///../src/readFromStore.ts","webpack:///../src/objectCache.ts","webpack:///../src/writeToStore.ts","webpack:///../src/inMemoryCache.ts","webpack:///../src/httpLink.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","Symbol","iterator","v","op","TypeError","pop","push","__spreadArrays","il","r","k","a","j","jl","message","genericMessage","framesToPop","name","InvariantError","Error","invariant","condition","wrapConsoleMethod","method","console","warn","error","processStub","env","process","Function","atLeastWeTried","apolloContext","getApolloContext","createContext","DocumentType","ApolloProvider","client","children","ApolloContext","context","Provider","cache","Map","operationName","type","Query","Mutation","Subscription","parser","document","variables","cached","get","fragments","definitions","filter","x","kind","queries","operation","mutations","subscriptions","valueToObjectRepresentation","argObj","isIntValue","isFloatValue","Number","isBooleanValue","isStringValue","isObjectValue","fields","map","obj","isVariable","variableValue","isListValue","values","listValue","nestedArgArrayObj","isEnumValue","isNullValue","storeKeyNameFromField","field","directivesObj","directives","forEach","directive","getStoreKeyName","KNOWN_DIRECTIVES","fieldName","args","filterKeys","sort","key","JSON","stringify","completeFieldName","stringifiedArgs","keys","argumentsObjectFromField","resultKeyNameFromField","alias","isField","selection","isInlineFragment","isIdValue","idObject","generated","toIdValue","idConfig","id","typename","undefined","isJsonValue","jsonObject","getDirectiveInfoFromField","shouldInclude","isInclusionDirective","directiveArguments","ifArgument","ifValue","every","evaledValue","hasDirectives","names","doc","Directive","node","getDirectiveNames","some","hasClientExports","getFragmentQueryDocument","fragmentName","actualFragmentName","definition","selectionSet","selections","target","sources","source","checkDocument","operations","getOperationDefinition","getOperationName","getFragmentDefinitions","getQueryDefinition","queryDef","getMainDefinition","queryDoc","fragmentDefinition","createFragmentMap","symTable","fragment","getDefaultValues","variableDefinitions","defaultValues","defaultValue","variable","defaultValueObj","filterInPlace","array","test","elem","TYPENAME_FIELD","nullIfDocIsEmpty","isEmpty","fragmentDef","getFragmentDefinition","getDirectiveMatcher","dir","removeDirectivesFromDocument","variablesInUse","variablesToRemove","fragmentSpreadsInUse","fragmentSpreadsToRemove","modifiedDoc","Variable","enter","_key","parent","Field","remove","arg","getAllFragmentSpreadsFromSelectionSet","allFragments","frag","FragmentSpread","config","argMatcher","argument","aConfig","getArgumentMatcher","OperationDefinition","varDef","argConfig","Argument","removeArgumentsFromDocument","fs","def","FragmentDefinition","removeFragmentSpreadFromDocument","addTypenameToDocument","SelectionSet","lastIndexOf","connectionRemoveConfig","willRemove","removeConnectionDirectiveFromDocument","buildQueryFromSelectionSet","removeClientSetsFromDocument","canUseWeakMap","WeakMap","navigator","product","toString","cloneDeep","cloneDeepHelper","val","seen","has","slice","set","child","getPrototypeOf","isEnv","isProduction","isTest","tryFunctionOrLogError","graphQLResultHasError","errors","maybeDeepFreeze","deepFreeze","o","freeze","getOwnPropertyNames","prop","isFrozen","mergeDeep","mergeDeepArray","count","pastCopies","shallowCopyForMerge","mergeHelper","isObject","isExtensible","sourceKey","sourceValue","targetValue","isArray","previousComparisons","equal","check","aTag","bTag","previouslyCompared","aKeys","bKeys","keyCount","size","aIterator","entries","isMap","info","aKey","aValue","clear","bSet","Set","add","Observable","defineProperty","exports","visit","root","visitor","visitorKeys","QueryDocumentKeys","stack","inArray","index","edits","path","ancestors","newRoot","isLeaving","isEdited","clone","_i2","_Object$keys2","editOffset","ii","editKey","editValue","splice","prev","isNode","_inspect","default","visitFn","getVisitFn","BREAK","visitInParallel","visitors","skipping","fn","leave","visitWithTypeInfo","typeInfo","require","__esModule","Name","Document","VariableDefinition","InlineFragment","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","maybeNode","Boolean","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor","formatValue","_nodejsCustomInspectSymbol","_typeof","seenValues","concat","previouslySeenValues","customInspectFn","object","String","inspect","getCustomFn","customValue","len","Math","min","remaining","items","join","formatArray","tag","replace","getObjectTag","formatObject","formatObjectValue","_default","for","classObject","toJSON","syntaxError","position","description","_GraphQLError","GraphQLError","getLocation","match","lineRegexp","line","column","exec","getBlockStringIndentation","lines","commonIndent","indent","leadingWhitespace","str","isBlank","dedentBlockStringValue","rawString","split","shift","printBlockString","indentation","preferMultipleLines","isSingleLine","hasLeadingSpace","hasTrailingQuote","printAsMultipleLines","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","NAME","INT","FLOAT","STRING","BLOCK_STRING","COMMENT","options","isMounted","previousOptions","getOptions","setOptions","newOptions","storePrevious","isEqual","unmount","refreshClient","isNew","cleanup","verifyDocumentType","onNewData","previousData","currentObservable","runLazy","runLazyQuery","lazyOptions","getExecuteResult","getQueryResult","startQuerySubscription","obsRefetch","query","refetch","obsFetchMore","fetchMoreOptions","fetchMore","obsUpdateQuery","mapFn","updateQuery","obsStartPolling","pollInterval","startPolling","obsStopPolling","stopPolling","obsSubscribeToMore","subscribeToMore","execute","skip","removeQuerySubscription","updateObservableQuery","getExecuteSsrResult","executeLazy","loading","networkStatus","ready","called","data","fetchData","ssr","obs","getCurrentResult","afterExecute","lazy","handleErrorOrCompleted","bind","ssrInitiated","renderPromises","ssrDisabled","fetchDisabled","disableNetworkFetches","ssrLoading","stale","observableQueryFields","addQueryPromise","prepareObservableQueryOptions","displayName","fetchPolicy","metadata","reactComponent","initializeObservableQuery","getSSRObservable","observableQueryOptions","watchQuery","registerSSRObservable","newObservableQueryOptions","catch","subscription","obsQuery","subscribe","previousResult","resubscribeToQuery","lastError","getLastError","lastResult","getLastResult","resetLastResults","currentResult","partial","graphQLErrors","partialRefetch","resetQueryStoreErrors","onCompleted","onError","unsubscribe","OperationData","setResult","runMutation","mutationFunctionOptions","onMutationStart","mutationId","generateNewMutationId","mutate","response","onMutationCompleted","onMutationError","mutation","mostRecentMutationId","optimisticResponse","update","awaitRefetchQueries","mutateOptions","mutateVariables","refetchQueries","mutationContext","ignoreResults","updateResult","isMostRecentMutation","initialize","getLoadingResult","shouldResubscribe","startSubscription","endSubscription","updateCurrentData","updateError","complete","completeSubscription","onSubscriptionData","subscriptionData","onSubscriptionComplete","useApolloClient","queryPromises","queryInfoTrie","observable","props","lookupQueryInfo","queryInstance","finish","hasPromises","consumeAndAwaitPromises","promises","promise","all","varMap","variablesString","cachedSetTimeout","cachedClearTimeout","module","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","noop","nextTick","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","NetworkStatus","isNetworkRequestInFlight","LinkObservable","isNonEmptyArray","FetchType","err","networkError","errorMessage","extraInfo","graphQLError","ApolloError","queryManager","shouldSubscribe","observer","onSubscribe","observers","isTornDown","queryId","generateQueryId","opDef","queryName","delete","removeQuery","storeValue","policy","queryStoreValue","queryStore","isNetworkFetchPolicy","errorPolicy","updateLastResult","isDifferentFromLastResult","newResult","lastResultSnapshot","snapshot","fetchQuery","combinedOptions","qid","normal","fetchMoreResult","stopQuery","startGraphQLSubscription","previous","opts","setVariables","oldFetchPolicy","fetchResults","tryFetch","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","assertNotCacheFirstOrOnly","startPollingQuery","assumeImmutableResults","subObserver","_subscription","_observer","defaultSubscriptionObserverErrorCallback","first","setUpQuery","tearDownQuery","addObservableQuery","iterateObserversSafely","observeQuery","transform","getLocalState","addExportedVariables","previousVariables","serverQuery","sub","removeObservableQuery","observersWithMethod","store","getStore","initMutation","markMutationError","markMutationResult","reset","initQuery","previousQuery","resolvers","fragmentMatcher","addResolvers","setFragmentMatcher","resolverGroup","setResolvers","getResolvers","runResolvers","remoteResult","onlyRunForcedResolvers","resolveDocument","localResult","getFragmentMatcher","clientQuery","prepareContext","getCacheKey","dataIdFromObject","buildRootValueFromCache","exportedVariables","shouldForceResolvers","forceResolvers","diff","returnPartialData","optimistic","rootValue","mainDefinition","fragmentMap","definitionOperation","defaultOperationType","charAt","toUpperCase","execContext","resolveSelectionSet","resultsToMerge","resolveField","fieldResult","typeCondition","fragmentResult","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolverType","__typename","resolverMap","resolveSubSelectedArray","item","multiplex","inner","link","queryDeduplication","onBroadcast","ssrMode","clientAwareness","localState","mutationStore","MutationStore","QueryStore","idCounter","fetchQueryRejectFns","transformCache","inFlightLinkObservables","pollingInfoByQueryId","LocalState","getCache","stop","_info","stopQueryNoBroadcast","updateQueries","setQuery","getVariables","generateUpdateQueriesInfo","ret","updateQueriesByName","observableQuery","updater","markMutationInit","updateWithProxyFn","self","storeResult","getObservableFromLink","markMutationComplete","refetchQueryPromises","refetchQuery","queryOptions","fetchType","fetchMoreForQueryId","needToFetch","isNetworkOnly","shouldFetch","requestId","cancel","updateQueryWatch","lastRequestId","invalidated","invalidate","storePreviousVariables","isPoll","poll","isRefetch","networkResult","fetchRequest","getQuery","markQueryError","markQueryResultClient","hasForcedResolvers","markQueryResult","newData","queryListenerForObserver","invoke","networkStatusChanged","shouldNotifyIfLoading","notifyOnNetworkStatusChange","hasGraphQLErrors","isMissing","errorStatusChanged","diffResult","resultFromStore","transformed","transformDocument","forLink","transformForLink","defaultVars","transformedOptions","ObservableQuery","watchedQuery","stopQueryInStore","stopQueryInStoreNoBroadcast","addQueryListener","listener","watch","callback","clearStore","resetIds","resetStore","reFetchObservableQueries","includeStandby","observableQueryPromises","startQuery","makeObservable","markSubscriptionResult","getCurrentQueryResult","getQueryWithPreviousResult","queryIdOrObservable","foundObserveableQuery","deduplication","forceFetch","of","activeNextCount","completed","handler","asyncMap","errorsFromStore","fqrfId","newInfo","newContext","checkInFlight","interval","initialCache","ignoreErrors","writeWithErrors","write","dataId","recordOptimisticTransaction","c","orig","nextQueryResult","currentQueryResult","mutationResult","queryVariables","performTransaction","removeOptimistic","defaultOptions","resetStoreCallbacks","clearStoreCallbacks","ssrForceFetchDelay","connectToDevTools","typeDefs","empty","DataStore","window","__APOLLO_CLIENT__","QueryManager","clientAwarenessName","clientAwarenessVersion","devToolsHookCb","action","state","dataWithOptimisticResults","extract","readQuery","readFragment","writeQuery","writeFragment","writeData","__actionHookForDevTools","cb","__requestRaw","payload","initQueryManager","onResetStore","onClearStore","restore","serializedState","setLocalStateFragmentMatcher","isTerminating","request","fromError","errorValue","createOperation","starting","enumerable","getKey","passthrough","forward","toLink","ApolloLink","from","links","reduce","left","right","leftLink","rightLink","second","firstLink","nextLink","transformedOperation","extensions","transformOperation","OPERATION_FIELDS","validateOperation","parse","normalize","string","trim","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","parseDocument","cacheKey","parsed","stripLoc","removeLocAtThisLevel","docType","loc","startToken","endToken","valueType","ast","astFragmentMap","substring","start","end","processFragments","gql","literals","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","Parser","parseValue","expectToken","_tokenKind","parseValueLiteral","parseType","parseTypeReference","_interopRequireDefault","_devAssert","_defineToJSON","_syntaxError","_kinds","_source","_lexer","_directiveLocation","sourceObj","Source","createLexer","_options","_proto","parseName","token","Kind","DOCUMENT","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","OPERATION_DEFINITION","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","VARIABLE_DEFINITION","parseVariable","expectOptionalToken","VARIABLE","SELECTION_SET","parseSelection","parseFragment","parseField","nameOrAlias","FIELD","parseArguments","isConst","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","parseNamedType","expectKeyword","FRAGMENT_DEFINITION","parseList","parseObject","advance","parseStringLiteral","BOOLEAN","NULL","ENUM","block","_this","LIST","any","_this2","OBJECT","parseObjectField","OBJECT_FIELD","parseDirective","DIRECTIVE","LIST_TYPE","NON_NULL_TYPE","NAMED_TYPE","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","types","allowLegacySDLImplementsInterfaces","allowLegacySDLEmptyFields","parseFieldDefinition","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMemberTypes","UNION_TYPE_DEFINITION","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","DirectiveLocation","noLocation","Loc","lastToken","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","printError","_isObjectLike","_location","_printLocation","positions","originalError","_nodes","_locations","_positions","list","pos","_extensions","originalExtensions","defineProperties","writable","configurable","captureStackTrace","output","_error$nodes2","printLocation","_i4","_error$locations2","location","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","locationLine","sublineIndex","floor","sublineColumnNum","sublines","printPrefixedLines","subline","existingLines","_ref","padLen","max","_ref2","_ref3","prefix","_defineToStringTag","toStringTag","startOfFileToken","Tok","lineStart","advanceLexer","isPunctuatorToken","_blockString","readToken","printCharCode","code","isNaN","fromCharCode","lexer","bodyLength","startPosition","charCodeAt","positionAfterWhitespace","col","readComment","readName","firstCode","isFloat","readDigits","readNumber","chunkStart","rawValue","readBlockString","charCode","char2hex","invalidSequence","readString","unexpectedCharacterMessage","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","global","ponyfill","originalModule","webpackPolyfill","l","symbolObservablePonyfill","_classCallCheck","instance","Constructor","_defineProperties","descriptor","_createClass","protoProps","staticProps","hasSymbols","hasSymbol","getSymbol","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","getSpecies","ctor","isObservable","hostReportError","log","enqueue","cleanupSubscription","_cleanup","closeSubscription","_queue","_state","notifySubscription","m","onNotify","flushSubscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscriber","_this3","_this4","C","hasSeed","hasValue","seed","acc","_this5","_len","startNext","_this6","outer","completeIfDone","closed","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_item","return","_len2","_key2","symbol","cmp","cycles","aobj","bobj","isFinite","out","seenIndex","print","_visitor","printDocASTReducer","varDefs","wrap","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","addDescription","_ref22","_ref23","_ref24","hasMultilineItems","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","maybeArray","separator","maybeString","isMultiline","queryFromPojo","selectionSetFromObj","Cache","justTypenameQuery","currentContext","MISSING_VALUE","host","Slot","Date","now","random","slots","getValue","withValue","saved","noContext","defaultDispose","dispose","newest","oldest","entry","getEntry","older","newer","clean","parentEntrySlot","reusableEmptyArray","emptySetPool","assert","optionalMessage","valueGet","parents","childValues","dirtyChildren","dirty","recomputing","Entry","recompute","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","recomputeNewValue","maybeUnsubscribe","setDirty","maybeSubscribe","reportClean","setClean","reallyRecompute","reportDirty","forgetChild","childValue","removeDirtyChild","dc","reportOrphan","_value","weakness","lookup","lookupArray","getChildTrie","isObjRef","weak","strong","KeyTrie","haveWarned","shouldWarn","answer","ensureReady","canBypassInit","idValue","isRootQuery","hasOwn","introspectionQueryResultData","possibleTypesMap","parseIntrospectionResult","isReady","implementingTypes","introspectionResultData","typeMap","__schema","possibleTypes","implementingType","depend","disposable","makeCacheKey","toObject","defaultNormalizedCacheFactory","cacheKeyRoot","freezeResults","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","contextValue","variableValues","readQueryFromStore","diffQueryAgainstStore","rootId","fragmentMatcherFunction","queryDefinition","cacheRedirects","execResult","hasMissingFields","missing","tolerable","finalResult","objectsToMerge","handleMissing","executeField","fragmentExecResult","readStoreResult","resultKey","storeKeyName","fieldValue","resolver","storeObj","json","readStoreResolver","combineExecResults","assertSelectionSetForIdValue","execResults","childResult","defaultFragmentMatcher","writeQueryToStore","writeResultToStore","operationDefinition","writeSelectionSetToStore","processedData","enhancedError","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","isDefered","isClient","matches","fakeContext","ObjectCache","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","generatedKey","realKey","real","madeChanges","realValue","newRealValue","itemDataId","defaultConfig","HeuristicFragmentMatcher","_id","addTypename","resultCaching","optimisticId","transaction","watches","typenameDocumentCache","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","read","broadcastWatches","evict","idToRemove","toReapply","removedCount","layer","fallbackHttpConfig","http","includeQuery","includeExtensions","headers","accept","throwServerError","statusCode","status","serializeFetchParameter","serialized","parseError","createHttpLink","linkOptions","uri","fetch","useGETForQueries","fetcher","checkFetcher","linkConfig","requestOptions","fetchOptions","credentials","chosenURI","fallbackURI","contextURI","getContext","selectURI","clientAwarenessHeaders","controller","contextHeaders","contextConfig","fallbackConfig","configs","signal","AbortController","_controller","queryParams","addQueryParam","encodeURIComponent","serializedVariables","serializedExtensions","preFragment","fragmentStart","substr","queryParamsPrefix","newURI","setContext","text","bodyText","abort"],"mappings":"8FAAA;;;;;;;;;;;;;;;AAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GAG5E,IAAIK,EAAW,WAQlB,OAPAA,EAAWZ,OAAOa,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAIZ,KADTW,EAAIG,UAAUF,GACOhB,OAAOU,UAAUL,eAAee,KAAKL,EAAGX,KAAIU,EAAEV,GAAKW,EAAEX,IAE9E,OAAOU,IAEKO,MAAMb,KAAMU,YAGzB,SAASI,EAAOP,EAAGQ,GACtB,IAAIT,EAAI,GACR,IAAK,IAAIV,KAAKW,EAAOf,OAAOU,UAAUL,eAAee,KAAKL,EAAGX,IAAMmB,EAAEC,QAAQpB,GAAK,IAC9EU,EAAEV,GAAKW,EAAEX,IACb,GAAS,MAALW,GAAqD,mBAAjCf,OAAOyB,sBACtB,KAAIT,EAAI,EAAb,IAAgBZ,EAAIJ,OAAOyB,sBAAsBV,GAAIC,EAAIZ,EAAEe,OAAQH,IAC3DO,EAAEC,QAAQpB,EAAEY,IAAM,GAAKhB,OAAOU,UAAUgB,qBAAqBN,KAAKL,EAAGX,EAAEY,MACvEF,EAAEV,EAAEY,IAAMD,EAAEX,EAAEY,KAE1B,OAAOF,EAkBJ,SAASa,EAAUC,EAASC,EAAYC,EAAGC,GAE9C,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOb,GAAKW,EAAOX,IACpF,SAASgB,EAASH,GAAS,IAAMC,EAAKN,EAAS,MAAUK,IAAW,MAAOb,GAAKW,EAAOX,IACvF,SAASc,EAAKG,GAJlB,IAAeJ,EAIaI,EAAOC,KAAOR,EAAQO,EAAOJ,QAJ1CA,EAIyDI,EAAOJ,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,OAITM,KAAKP,EAAWI,GAClGF,GAAMN,EAAYA,EAAUV,MAAMO,EAASC,GAAc,KAAKS,WAI/D,SAASK,EAAYf,EAASgB,GACjC,IAAsGC,EAAGC,EAAGhC,EAAGiC,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPpC,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOqC,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAET,KAAMe,EAAK,GAAI,MAASA,EAAK,GAAI,OAAUA,EAAK,IAAwB,mBAAXC,SAA0BP,EAAEO,OAAOC,UAAY,WAAa,OAAO/C,OAAUuC,EACvJ,SAASM,EAAKpC,GAAK,OAAO,SAAUuC,GAAK,OACzC,SAAcC,GACV,GAAIZ,EAAG,MAAM,IAAIa,UAAU,mCAC3B,KAAOV,GAAG,IACN,GAAIH,EAAI,EAAGC,IAAMhC,EAAY,EAAR2C,EAAG,GAASX,EAAC,OAAaW,EAAG,GAAKX,EAAC,SAAehC,EAAIgC,EAAC,SAAehC,EAAEM,KAAK0B,GAAI,GAAKA,EAAER,SAAWxB,EAAIA,EAAEM,KAAK0B,EAAGW,EAAG,KAAKhB,KAAM,OAAO3B,EAE3J,OADIgC,EAAI,EAAGhC,IAAG2C,EAAK,CAAS,EAARA,EAAG,GAAQ3C,EAAEsB,QACzBqB,EAAG,IACP,KAAK,EAAG,KAAK,EAAG3C,EAAI2C,EAAI,MACxB,KAAK,EAAc,OAAXT,EAAEC,QAAgB,CAAEb,MAAOqB,EAAG,GAAIhB,MAAM,GAChD,KAAK,EAAGO,EAAEC,QAASH,EAAIW,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKT,EAAEI,IAAIO,MAAOX,EAAEG,KAAKQ,MAAO,SACxC,QACI,KAAM7C,EAAIkC,EAAEG,MAAMrC,EAAIA,EAAEK,OAAS,GAAKL,EAAEA,EAAEK,OAAS,KAAkB,IAAVsC,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAET,EAAI,EAAG,SACjG,GAAc,IAAVS,EAAG,MAAc3C,GAAM2C,EAAG,GAAK3C,EAAE,IAAM2C,EAAG,GAAK3C,EAAE,IAAM,CAAEkC,EAAEC,MAAQQ,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYT,EAAEC,MAAQnC,EAAE,GAAI,CAAEkC,EAAEC,MAAQnC,EAAE,GAAIA,EAAI2C,EAAI,MAC7D,GAAI3C,GAAKkC,EAAEC,MAAQnC,EAAE,GAAI,CAAEkC,EAAEC,MAAQnC,EAAE,GAAIkC,EAAEI,IAAIQ,KAAKH,GAAK,MACvD3C,EAAE,IAAIkC,EAAEI,IAAIO,MAChBX,EAAEG,KAAKQ,MAAO,SAEtBF,EAAKb,EAAKxB,KAAKQ,EAASoB,GAC1B,MAAOzB,GAAKkC,EAAK,CAAC,EAAGlC,GAAIuB,EAAI,EAjBrB,QAiBoCD,EAAI/B,EAAI,EACtD,GAAY,EAAR2C,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAErB,MAAOqB,EAAG,GAAKA,EAAG,QAAK,EAAQhB,MAAM,GArB9BJ,CAAK,CAACpB,EAAGuC,MAgEtD,SAASK,IACZ,IAAK,IAAI9C,EAAI,EAAGC,EAAI,EAAG8C,EAAK5C,UAAUC,OAAQH,EAAI8C,EAAI9C,IAAKD,GAAKG,UAAUF,GAAGG,OACxE,IAAI4C,EAAI5D,MAAMY,GAAIiD,EAAI,EAA3B,IAA8BhD,EAAI,EAAGA,EAAI8C,EAAI9C,IACzC,IAAK,IAAIiD,EAAI/C,UAAUF,GAAIkD,EAAI,EAAGC,EAAKF,EAAE9C,OAAQ+C,EAAIC,EAAID,IAAKF,IAC1DD,EAAEC,GAAKC,EAAEC,GACjB,OAAOH,I,yHCnJT,SAAA9D,sBAAA,oB,wBAGC,EAGH,cAGE,WAAYmE,QAAA,IAAAA,MAXS,uBAWrB,MACE,YACqB,iBAAZA,EACAC,wBAAmBD,EAAO,6DAC7BA,IACL,K,OAPH,EAAAE,YAAc,EACd,EAAAC,KAVqB,sBAiBnBtE,EAAe,EAAMuE,EAAe9D,W,EAExC,OAXoC,iBAWpC,EAXA,CAAoC+D,O,SAapBC,EAAUC,EAAgBP,GACxC,IAAKO,EACH,MAAM,IAAIH,EAAeJ,GAI7B,SAASQ,EAAkBC,GACzB,OAAO,WACL,OAAOC,QAAQD,GAAQxD,MAAMyD,QAAS5D,aAI1C,SAAiBwD,GACF,EAAAK,KAAOH,EAAkB,QACzB,EAAAI,MAAQJ,EAAkB,SAFzC,CAAiBF,MAAS,KAU1B,IAAIO,EAA8B,CAAEC,IAAK,IAEzC,GAAuB,iBAAZC,EACTF,EAAcE,OACT,IAILC,SAAS,OAAQ,iBAAjBA,CAAmCH,GACnC,MAAOI,O,6NC5CLC,E,uBAEJ,SAAgBC,IAId,OAHKD,IACHA,EAAgB,IAAME,cAAkC,KAEnDF,E,ICNGG,ECGCC,EAAqD,SAAC,G,IACjEC,EAAA,EAAAA,OACAC,EAAA,EAAAA,SAEMC,EAAgBN,IACtB,OAAO,oBACS,2BAYV,YAXA,IAAAO,MAAA,IACIH,GAAUG,EAAQH,SAAWA,IAC/BG,EAAU9F,OAAOa,OAAO,GAAIiF,EAAS,CAAEH,OAAM,KAG/C,wBAOE,kBAACE,EAAcE,SAAQ,CAAC3D,MAAO0D,GAC5BF,QDvBb,SAAYH,GACV,qBACA,2BACA,mCAHF,CAAYA,MAAY,KAYxB,IAAMO,EAAQ,IAAIC,IAElB,SAAgBC,EAAcC,GAC5B,IAAI5B,EACJ,OAAQ4B,GACN,KAAKV,EAAaW,MAChB7B,EAAO,QACP,MACF,KAAKkB,EAAaY,SAChB9B,EAAO,WACP,MACF,KAAKkB,EAAaa,aAChB/B,EAAO,eAGX,OAAOA,EAIT,SAAgBgC,EAAOC,GACrB,IAGIC,EAAWN,EAHTO,EAASV,EAAMW,IAAIH,GACzB,GAAIE,EAAQ,OAAOA,EAKF,mBACQ,UAKzB,IAAME,EAAYJ,EAASK,YAAYC,QACrC,SAACC,GAAsB,MAAW,uBAAXA,EAAEC,QAGrBC,EAAUT,EAASK,YAAYC,QACnC,SAACC,GACC,MAAW,wBAAXA,EAAEC,MAAkD,UAAhBD,EAAEG,aAGpCC,EAAYX,EAASK,YAAYC,QACrC,SAACC,GACC,MAAW,wBAAXA,EAAEC,MAAkD,aAAhBD,EAAEG,aAGpCE,EAAgBZ,EAASK,YAAYC,QACzC,SAACC,GACC,MAAW,wBAAXA,EAAEC,MAAkD,iBAAhBD,EAAEG,aAI9B,uBACPD,EAAQ9F,QAAUgG,EAAUhG,QAAUiG,EAAcjG,OACvD,GAOmC,cAAa,gBAAAiG,EAAcjG,QAAd,KAMlD,EAAI,SAAoB,mBAAkB,UAAoB,WAExD,kB,IACJ,WACE,E,SAEA,EAGF,E,4BAOF,WAEA,IAAuB,wBAOvB,YANE,EAAAoD,MAA6B,SAA7B,EAA6B,U,oBAMH,oB,OAC5B,W,uwCElBF,SAAgB8C,EACdC,EACA/C,EACAnC,EACAqE,GAEA,GAlCF,SAAoBrE,GAClB,MAAsB,aAAfA,EAAM4E,KAiCTO,CAAWnF,IA9BjB,SAAsBA,GACpB,MAAsB,eAAfA,EAAM4E,KA6BYQ,CAAapF,GACpCkF,EAAO/C,EAAKnC,OAASqF,OAAOrF,EAAMA,YAC7B,GAxCT,SAAwBA,GACtB,MAAsB,iBAAfA,EAAM4E,KAuCFU,CAAetF,IA5C5B,SAAuBA,GACrB,MAAsB,gBAAfA,EAAM4E,KA2CuBW,CAAcvF,GAChDkF,EAAO/C,EAAKnC,OAASA,EAAMA,WACtB,GA1BT,SAAuBA,GACrB,MAAsB,gBAAfA,EAAM4E,KAyBFY,CAAcxF,GAAQ,CAC/B,IAAM,EAAe,GACrBA,EAAMyF,OAAOC,KAAI,SAAAC,GACf,OAAAV,EAA4B,EAAcU,EAAIxD,KAAMwD,EAAI3F,MAAOqE,MAEjEa,EAAO/C,EAAKnC,OAAS,OAChB,GApCT,SAAoBA,GAClB,MAAsB,aAAfA,EAAM4E,KAmCFgB,CAAW5F,GAAQ,CAC5B,IAAM6F,GAAiBxB,GAAc,IAAYrE,EAAMmC,KAAKnC,OAC5DkF,EAAO/C,EAAKnC,OAAS6F,OAChB,GA/BT,SAAqB7F,GACnB,MAAsB,cAAfA,EAAM4E,KA8BFkB,CAAY9F,GACrBkF,EAAO/C,EAAKnC,OAASA,EAAM+F,OAAOL,KAAI,SAAAM,GACpC,IAAMC,EAAoB,GAO1B,OANAhB,EACEgB,EACA9D,EACA6D,EACA3B,GAEM4B,EAA0B9D,EAAKnC,eAEpC,GAtCT,SAAqBA,GACnB,MAAsB,cAAfA,EAAM4E,KAqCFsB,CAAYlG,GACrBkF,EAAO/C,EAAKnC,OAAUA,EAAwBA,UACzC,KApCT,SAAqBA,GACnB,MAAsB,cAAfA,EAAM4E,KAmCFuB,CAAYnG,GAGrB,MAAM,YAFNkF,EAAO/C,EAAKnC,OAAS,MAUzB,SAAgBoG,EACdC,EACAhC,GAEA,IAAIiC,EAAqB,KACrBD,EAAME,aACRD,EAAgB,GAChBD,EAAME,WAAWC,SAAQ,SAAAC,GACvBH,EAAcG,EAAUtE,KAAKnC,OAAS,GAElCyG,EAAU3H,WACZ2H,EAAU3H,UAAU0H,SAAQ,SAAC,G,IAAErE,EAAA,EAAAA,KAAMnC,EAAA,EAAAA,MACnC,OAAAiF,EACEqB,EAAcG,EAAUtE,KAAKnC,OAC7BmC,EACAnC,EACAqE,UAOV,IAAIa,EAAc,KAQlB,OAPImB,EAAMvH,WAAauH,EAAMvH,UAAUC,SACrCmG,EAAS,GACTmB,EAAMvH,UAAU0H,SAAQ,SAAC,G,IAAErE,EAAA,EAAAA,KAAMnC,EAAA,EAAAA,MAC/B,OAAAiF,EAA4BC,EAAQ/C,EAAMnC,EAAOqE,OAI9CqC,EAAgBL,EAAMlE,KAAKnC,MAAOkF,EAAQoB,GASnD,IAAMK,EAA6B,CACjC,aACA,UACA,OACA,SACA,OACA,UAGF,SAAgBD,EACdE,EACAC,EACAN,GAEA,GACEA,GACAA,EAAU,YACVA,EAAU,WAAV,IACA,CACA,GACEA,EAAU,WAAV,QACCA,EAAU,WAAV,OAAgDxH,OAAS,EAC1D,CACA,IAAM+H,EAAaP,EAAU,WAAV,OACdA,EAAU,WAAV,OACD,GACJO,EAAWC,OAEX,IAAM,EAAYF,EACZ,EAAe,GAKrB,OAJAC,EAAWN,SAAQ,SAAAQ,GACjB,EAAaA,GAAO,EAAUA,MAGtBT,EAAU,WAAV,IAA+B,IAAIU,KAAKC,UAChD,GACD,IAED,OAAOX,EAAU,WAAV,IAIX,IAAIY,EAA4BP,EAEhC,GAAIC,EAAM,CAIR,IAAMO,EAA0B,IAAUP,GAC1CM,GAAqB,IAAIC,EAAe,IAc1C,OAXIb,GACF3I,OAAOyJ,KAAKd,GAAYC,SAAQ,SAAAQ,IACS,IAAnCL,EAAiBvH,QAAQ4H,KACzBT,EAAWS,IAAQpJ,OAAOyJ,KAAKd,EAAWS,IAAMjI,OAClDoI,GAAqB,IAAIH,EAAG,IAAIC,KAAKC,UAAUX,EAAWS,IAAK,IAE/DG,GAAqB,IAAIH,MAKxBG,EAGT,SAAgBG,EACdjB,EACAhC,GAEA,GAAIgC,EAAMvH,WAAauH,EAAMvH,UAAUC,OAAQ,CAC7C,IAAM,EAAiB,GAIvB,OAHAsH,EAAMvH,UAAU0H,SAAQ,SAAC,G,IAAErE,EAAA,EAAAA,KAAMnC,EAAA,EAAAA,MAC/B,OAAAiF,EAA4B,EAAQ9C,EAAMnC,EAAOqE,MAE5C,EAGT,OAAO,KAGT,SAAgBkD,EAAuBlB,GACrC,OAAOA,EAAMmB,MAAQnB,EAAMmB,MAAMxH,MAAQqG,EAAMlE,KAAKnC,MAGtD,SAAgByH,EAAQC,GACtB,MAA0B,UAAnBA,EAAU9C,KAGnB,SAAgB+C,EACdD,GAEA,MAA0B,mBAAnBA,EAAU9C,KAGnB,SAAgBgD,EAAUC,GACxB,OAAOA,GACsC,OAA1CA,EAAiC9D,MACS,kBAAnC8D,EAAqBC,UAQjC,SAAgBC,EACdC,EACAF,GAEA,YAFA,IAAAA,OAAA,GAEA,aACE/D,KAAM,KACN+D,UAAS,GACe,iBAAbE,EACP,CAAEC,GAAID,EAAUE,cAAUC,GAC1BH,GAIR,SAAgBI,EAAYC,GAC1B,OACgB,MAAdA,GACsB,iBAAfA,GACsC,SAA5CA,EAAmCtE,K,SCtRxBuE,EACdjC,EACAhC,GAEA,GAAIgC,EAAME,YAAcF,EAAME,WAAWxH,OAAQ,CAC/C,IAAM,EAA8B,GAOpC,OANAsH,EAAME,WAAWC,SAAQ,SAACC,GACxB,EAAaA,EAAUtE,KAAKnC,OAASsH,EACnCb,EACApC,MAGG,EAET,OAAO,KAGT,SAAgBkE,EACdb,EACArD,GAEA,YAFA,IAAAA,MAAA,KAuDAkC,EApDEmB,EAAUnB,WAsDLA,EAAaA,EAAW7B,OAAO8D,GAAsB9C,KAAI,SAAAe,GAC9D,IAAMgC,EAAqBhC,EAAU3H,UACf2H,EAAUtE,KAAKnC,MAErC,YAC0C,mBAI1C,IAAM0I,EAAaD,EAAmB,GAEN,YAAU,EACxC,6BAGF,IAAME,EAAqBD,EAAW1I,MAUpC,OAPF,gBAEsB,aAAjB2I,EAAQ/D,MAAwC,iBAAjB+D,EAAQ/D,MAC1C,GAIA,8B,IA9EFgE,OAAM,SAAC,G,IAAEnC,EAAA,EAAAA,UAAWiC,EAAA,EAAAA,WAChBG,GAAuB,EAU3B,MAT8B,aAA1BH,EAAW1I,MAAM4E,MACnBiE,EAAcxE,EAAWqE,EAAW1I,MAAuBmC,KAAKnC,OAChE,uBAEqC,IAGrC6I,EAAeH,EAAW1I,MAA2BA,MAEvB,SAAzByG,EAAUtE,KAAKnC,OAAoB6I,EAAcA,KAuC5D,IACEtC,EAxBF,SAAgBuC,EAAcC,EAAiBC,GAC7C,OAbF,SAAkCA,GAChC,IAAMD,EAAkB,GAQxB,OANA,gBAAMC,EAAK,CACTC,UAAS,SAACC,GACRH,EAAMvH,KAAK0H,EAAK/G,KAAKnC,UAIlB+I,EAIAI,CAAkBH,GAAKI,MAC5B,SAACjH,GAAiB,OAAA4G,EAAM3J,QAAQ+C,IAAS,KAI7C,SAAgBkH,EAAiBjF,GAC/B,OACEA,GACA0E,EAAc,CAAC,UAAW1E,IAC1B0E,EAAc,CAAC,UAAW1E,GAS9B,SAASoE,EAAqB,G,IAAUxI,EAAA,OAAAA,MACtC,MAAiB,SAAVA,GAA8B,YAAVA,E,SCpEbsJ,EACdlF,EACAmF,GAEA,IAAIC,EAAqBD,EAKnB/E,EAA2C,GAwDjD,OAvDAJ,EAASK,YAAY+B,SAAQ,SAAAiD,GAG3B,GAAwB,wBAApBA,EAAW7E,KACb,MAAM,WASgB,uBAApB6E,EAAW7E,MACbJ,EAAUhD,KAAKiI,WAMe,IAAvBD,IAEG,kBAAAzK,OAAA,GAKZyK,EAAqBhF,EAAU,GAAGrC,KAAKnC,OAK9B,2BACNoE,GAAQ,CACXK,YAAa,OAAF,IAAE,CAAF,CACT,CACEG,KAAM,sBACNE,UAAW,QACX4E,aAAc,CACZ9E,KAAM,eACN+E,WAAY,CACV,CACE/E,KAAM,iBACNzC,KAAM,CACJyC,KAAM,OACN5E,MAAOwJ,QAMdpF,EAASK,e,SCrEFhG,EACdmL,G,IACA,wDAUA,OARAC,EAAQrD,SAAQ,SAAAsD,GACV,MAAOA,GAGXlM,OAAOyJ,KAAKyC,GAAQtD,SAAQ,SAAAQ,GAC1B4C,EAAO5C,GAAO8C,EAAO9C,SAGlB4C,ECCT,SAAgBG,EAAcf,GAEI,sCAKhC,IAAMgB,EAAahB,EAAIvE,YACpBC,QAAO,SAAAhH,GAAK,MAAW,uBAAXA,EAAEkH,QACdc,KAAI,SAAA+D,GACH,GAAwB,wBAApBA,EAAW7E,KACb,MAAM,WAMR,OAAO6E,KAQX,OAJY,4BAILT,EAGT,SAAgBiB,EACdjB,GAGA,OADAe,EAAcf,GACPA,EAAIvE,YAAYC,QACrB,SAAA+E,GAAc,MAAoB,wBAApBA,EAAW7E,QACzB,GAWJ,SAAgBsF,EAAiBlB,GAC/B,OACEA,EAAIvE,YACDC,QACC,SAAA+E,GACE,MAAoB,wBAApBA,EAAW7E,MAAkC6E,EAAWtH,QAE3DuD,KAAI,SAACf,GAA+B,OAAAA,EAAExC,KAAKnC,SAAO,IAAM,KAK/D,SAAgBmK,EACdnB,GAEA,OAAOA,EAAIvE,YAAYC,QACrB,SAAA+E,GAAc,MAAoB,uBAApBA,EAAW7E,QAI7B,SAAgBwF,EAAmBpB,GACjC,IAAMqB,EAAWJ,EAAuBjB,GAOxC,OAJgC,yCAIzBqB,EAgCT,SAAgBC,EACdC,GAIA,IAAIC,EAFJT,EAAcQ,GAId,IAAuB,UAAAA,EAAS9F,YAAT,eAAsB,CAAxC,IAAIgF,EAAU,KACjB,GAAwB,wBAApBA,EAAW7E,KAAgC,CAC7C,IAAME,EAAa2E,EAAuC3E,UAC1D,GACgB,UAAdA,GACc,aAAdA,GACc,iBAAdA,EAEA,OAAO2E,EAGa,uBAApBA,EAAW7E,MAAkC4F,IAG/CA,EAAqBf,GAIzB,GAAIe,EACF,OAAOA,EAGT,MAAM,YAcR,SAAgBC,EACdjG,QAAA,IAAAA,MAAA,IAEA,IAAMkG,EAAwB,GAK9B,OAJAlG,EAAUgC,SAAQ,SAAAmE,GAChBD,EAASC,EAASxI,KAAKnC,OAAS2K,KAG3BD,EAGT,SAAgBE,EACdnB,GAEA,GACEA,GACAA,EAAWoB,qBACXpB,EAAWoB,oBAAoB9L,OAC/B,CACA,IAAM+L,EAAgBrB,EAAWoB,oBAC9BnG,QAAO,SAAC,GAAqB,OAAnB,EAAAqG,gBACVrF,KACC,SAAC,G,IAAEsF,EAAA,EAAAA,SAAUD,EAAA,EAAAA,aACLE,EAAgD,GAOtD,OANAhG,EACEgG,EACAD,EAAS7I,KACT4I,GAGKE,KAIb,OAAOxM,EAAM,0BAAC,IAAOqM,IAGvB,MAAO,G,SCvNOI,EACdC,EACAC,EACA1H,GAEA,IAAIkG,EAAS,EAOb,OANAuB,EAAM3E,SAAQ,SAAU6E,EAAMzM,GACxBwM,EAAKpM,KAAKZ,KAAMiN,EAAMzM,EAAGuM,KAC3BA,EAAMvB,KAAYyB,KAEnB3H,GACHyH,EAAMpM,OAAS6K,EACRuB,ECuCT,IAAMG,EAA4B,CAChC1G,KAAM,QACNzC,KAAM,CACJyC,KAAM,OACN5E,MAAO,eAeX,SAASuL,EAAiBvC,GACxB,OAZF,SAASwC,EACPnK,EACAmD,GAEA,OAAOnD,EAAGqI,aAAaC,WAAWf,OAChC,SAAAlB,GACE,MAAmB,mBAAnBA,EAAU9C,MACV4G,EAAQhH,EAAUkD,EAAUvF,KAAKnC,OAAQwE,MAKtCgH,CACLvB,EAAuBjB,IFkC3B,SACEA,GAEA,oCAO6B,wCAI7B,IAAMyC,EAAczC,EAAIvE,YAAY,GAOpC,OALA,8CAKOgH,EEvD0BC,CAAsB1C,GACrDyB,EAAkBN,EAAuBnB,KAEvC,KACAA,EAGN,SAAS2C,EACPpF,GAEA,OAAO,SAA0BE,GAC/B,OAAOF,EAAW6C,MAChB,SAAAwC,GACE,OAACA,EAAIzJ,MAAQyJ,EAAIzJ,OAASsE,EAAUtE,KAAKnC,OACxC4L,EAAIR,MAAQQ,EAAIR,KAAK3E,OAK9B,SAAgBoF,EACdtF,EACAyC,GAEA,IAAM8C,EAA0ClO,OAAOW,OAAO,MAC1DwN,EAA6C,GAE3CC,EAAgDpO,OAAOW,OAAO,MAChE0N,EAAwD,GAExDC,EAAcX,EAChB,gBAAMvC,EAAK,CACTmD,SAAU,CACRC,MAAA,SAAMlD,EAAMmD,EAAMC,GAO8B,uBAA3CA,EAAkC1H,OAEnCkH,EAAe5C,EAAK/G,KAAKnC,QAAS,KAKxCuM,MAAO,CACLH,MAAA,SAAMlD,GACJ,GAAI3C,GAAc2C,EAAK3C,aAGKA,EAAW6C,MACnC,SAAA3C,GAAa,OAAAA,EAAU+F,WAKvBtD,EAAK3C,YACL2C,EAAK3C,WAAW6C,KAAKuC,EAAoBpF,KA2BzC,OAzBI2C,EAAKpK,WAGPoK,EAAKpK,UAAU0H,SAAQ,SAAAiG,GACE,aAAnBA,EAAIzM,MAAM4E,MACZmH,EAAkBvK,KAAK,CACrBW,KAAOsK,EAAIzM,MAAuBmC,KAAKnC,WAM3CkJ,EAAKQ,cAqTvB,SAASgD,EACPhD,GAEA,IAAMiD,EAAqC,GAe3C,OAbAjD,EAAaC,WAAWnD,SAAQ,SAAAkB,IAE3BD,EAAQC,IAAcC,EAAiBD,KACxCA,EAAUgC,aAEVgD,EAAsChF,EAAUgC,cAAclD,SAC5D,SAAAoG,GAAQ,OAAAD,EAAanL,KAAKoL,MAEA,mBAAnBlF,EAAU9C,MACnB+H,EAAanL,KAAKkG,MAIfiF,EApUOD,CAAsCxD,EAAKQ,cAAclD,SACvD,SAAAoG,GACEX,EAAwBzK,KAAK,CAC3BW,KAAMyK,EAAKzK,KAAKnC,WAOjB,OAMf6M,eAAgB,CACdT,MAAK,SAAClD,GAGJ8C,EAAqB9C,EAAK/G,KAAKnC,QAAS,IAI5CiJ,UAAW,CACTmD,MAAK,SAAClD,GAEJ,GAAIyC,EAAoBpF,EAApBoF,CAAgCzC,GAClC,OAAO,UA+BjB,OApBEgD,GACAhB,EAAca,GAAmB,SAAA3K,GAAK,OAAC0K,EAAe1K,EAAEe,SAAOpD,SAE/DmN,EA+LJ,SACEY,EACA9D,GAEA,IAAM+D,EAjBR,SAA4BD,GAC1B,OAAO,SAAyBE,GAC9B,OAAOF,EAAO1D,MACZ,SAAC6D,GACC,OAAAD,EAAShN,OACe,aAAxBgN,EAAShN,MAAM4E,MACfoI,EAAShN,MAAMmC,OACd8K,EAAQ9K,OAAS6K,EAAShN,MAAMmC,KAAKnC,OACnCiN,EAAQ7B,MAAQ6B,EAAQ7B,KAAK4B,QASnBE,CAAmBJ,GAEtC,OAAOvB,EACL,gBAAMvC,EAAK,CACTmE,oBAAqB,CACnBf,MAAK,SAAClD,GACJ,kCACKA,GAAI,CAEP2B,oBAAqB3B,EAAK2B,oBAAoBnG,QAC5C,SAAA0I,GACE,OAACN,EAAO1D,MAAK,SAAAqD,GAAO,OAAAA,EAAItK,OAASiL,EAAOpC,SAAS7I,KAAKnC,gBAMhEuM,MAAO,CACLH,MAAK,SAAClD,GAKJ,GAF0B4D,EAAO1D,MAAK,SAAAiE,GAAa,OAAAA,EAAUb,UAEtC,CACrB,IAAI,EAAgB,EAMpB,GALAtD,EAAKpK,UAAU0H,SAAQ,SAAAiG,GACjBM,EAAWN,KACb,GAAiB,MAGC,IAAlB,EACF,OAAO,QAMfa,SAAU,CACRlB,MAAK,SAAClD,GAEJ,GAAI6D,EAAW7D,GACb,OAAO,UA5ODqE,CAA4BxB,EAAmBG,IAO7DA,GACAhB,EAAce,GAAyB,SAAAuB,GAAM,OAACxB,EAAqBwB,EAAGrL,SACnEpD,SAEHmN,EAyOJ,SACEY,EACA9D,GAEA,SAASoD,EACPlD,GAEA,GAAI4D,EAAO1D,MAAK,SAAAqE,GAAO,OAAAA,EAAItL,OAAS+G,EAAK/G,KAAKnC,SAC5C,OAAO,KAIX,OAAOuL,EACL,gBAAMvC,EAAK,CACT6D,eAAgB,CAAET,MAAK,GACvBsB,mBAAoB,CAAEtB,MAAK,MAxPfuB,CACZ1B,EACAC,IAIGA,EAGT,SAAgB0B,EAAsB5E,GACpC,OAAO,gBAAMe,EAAcf,GAAM,CAC/B6E,aAAc,CACZzB,MAAA,SAAMlD,EAAMmD,EAAMC,GAEhB,IACEA,GAC6C,wBAA5CA,EAAmC1H,KAFtC,CAQQ,IAAA+E,EAAA,EAAAA,WACR,GAAKA,EAaL,IAPaA,EAAWP,MAAK,SAAA1B,GAC3B,OACED,EAAQC,KACkB,eAAzBA,EAAUvF,KAAKnC,OACgC,IAA9C0H,EAAUvF,KAAKnC,MAAM8N,YAAY,KAAM,OAG7C,CAMA,IAAMzH,EAAQiG,EACd,KACE7E,EAAQpB,IACRA,EAAME,YACNF,EAAME,WAAW6C,MAAK,SAAA1L,GAAK,MAAiB,WAAjBA,EAAEyE,KAAKnC,UAMpC,kCACKkJ,GAAI,CACPS,WAAY,OAAF,IAAE,CAAIA,EAAU,CAAE2B,YAOtC,IAAMyC,EAAyB,CAC7B3C,KAAM,SAAC3E,GACL,IAAMuH,EAAsC,eAAzBvH,EAAUtE,KAAKnC,MAalC,OAZIgO,KAECvH,EAAU3H,WACV2H,EAAU3H,UAAUsK,MAAK,SAAAqD,GAAO,MAAmB,QAAnBA,EAAItK,KAAKnC,UASvCgO,IAIX,SAAgBC,EAAsCjF,GACpD,OAAO6C,EACL,CAACkC,GACDhE,EAAcf,IAkMlB,SAAgBkF,EACd9J,GAKA,MAA4B,UAHTkG,EAAkBlG,GAC6BU,UAIzDV,EAIW,gBAAMA,EAAU,CAClC+I,oBAAqB,CACnBf,MAAK,SAAClD,GACJ,kCACKA,GAAI,CACPpE,UAAW,cASrB,SAAgBqJ,EACd/J,GAEA2F,EAAc3F,GAEd,IAAI8H,EAAcL,EAChB,CACE,CACET,KAAM,SAAC3E,GAA6B,MAAyB,WAAzBA,EAAUtE,KAAKnC,OACnDwM,QAAQ,IAGZpI,GAyBF,OAlBI8H,IACFA,EAAc,gBAAMA,EAAa,CAC/BwB,mBAAoB,CAClBtB,MAAK,SAAClD,GACJ,GAAIA,EAAKQ,cACgBR,EAAKQ,aAAaC,WAAWf,OAClD,SAAAlB,GACE,OAAAD,EAAQC,IAAuC,eAAzBA,EAAUvF,KAAKnC,SAGvC,OAAO,UAQZkM,E,IC5hBIkC,EAAmC,mBAAZC,WACb,iBAAdC,WACe,gBAAtBA,UAAUC,SCFJC,EAAA,iBAAAA,SAKR,SAAgBC,EAAazO,GAC3B,OAGF,SAAS0O,EAAmBC,EAAQC,GAClC,OAAQJ,EAASxP,KAAK2P,IACtB,IAAK,iBACH,GAAIC,EAAKC,IAAIF,GAAM,OAAOC,EAAKrK,IAAIoK,GACnC,IAAM,EAAmBA,EAAYG,MAAM,GAK3C,OAJAF,EAAKG,IAAIJ,EAAK,GACd,EAAKnI,SAAQ,SAAUwI,EAAOpQ,GAC5B,EAAKA,GAAK8P,EAAgBM,EAAOJ,MAE5B,EAGT,IAAK,kBACH,GAAIA,EAAKC,IAAIF,GAAM,OAAOC,EAAKrK,IAAIoK,GAGnC,IAAM,EAAO/Q,OAAOW,OAAOX,OAAOqR,eAAeN,IAKjD,OAJAC,EAAKG,IAAIJ,EAAK,GACd/Q,OAAOyJ,KAAKsH,GAAKnI,SAAQ,SAAAQ,GACvB,EAAKA,GAAO0H,EAAiBC,EAAY3H,GAAM4H,MAE1C,EAGT,QACE,OAAOD,GA5BFD,CAAgB1O,EAAO,IAAI6D,KCGpC,SAAgBqL,EAAMpM,GACpB,YATuB,IAAZC,EACF,aAIF,iBAIaD,EAGtB,SAAgBqM,IACd,OAA+B,IAAxBD,EAAM,cAOf,SAAgBE,IACd,OAAyB,IAAlBF,EAAM,Q,SCpBCG,EAAsB5O,GACpC,IACE,OAAOA,IACP,MAAOtB,GACHuD,QAAQE,OACVF,QAAQE,MAAMzD,IAKpB,SAAgBmQ,EAAsBlP,GACpC,OAAOA,EAAOmP,QAAUnP,EAAOmP,OAAOxQ,OCOxC,SAAgByQ,EAAgB7J,GAC9B,KFHgC,IAAzBuJ,EAAM,gBEGUE,QAID,mBAAXlO,QAA+C,iBAAfA,OAAO,KAG9C,OAxBN,SAASuO,EAAWC,GAalB,OAZA9R,OAAO+R,OAAOD,GAEd9R,OAAOgS,oBAAoBF,GAAGlJ,SAAQ,SAASqJ,GAE/B,OAAZH,EAAEG,IACkB,iBAAZH,EAAEG,IAAyC,mBAAZH,EAAEG,IACxCjS,OAAOkS,SAASJ,EAAEG,KAEnBJ,EAAWC,EAAEG,OAIVH,EAWID,CAAW9J,GAGtB,OAAOA,EC/BD,IAAA1H,EAAA,iBAAAA,eAwBR,SAAgB8R,K,IACd,sDAEA,OAAOC,GAAenG,GASxB,SAAgBmG,GAAkBnG,GAChC,IAAID,EAASC,EAAQ,IAAM,GACrBoG,EAAQpG,EAAQ9K,OACtB,GAAIkR,EAAQ,EAAG,CACb,IAAMC,EAAoB,GAC1BtG,EAASuG,GAAoBvG,EAAQsG,GACrC,IAAK,IAAItR,EAAI,EAAGA,EAAIqR,IAASrR,EAC3BgL,EAASwG,GAAYxG,EAAQC,EAAQjL,GAAIsR,GAG7C,OAAOtG,EAGT,SAASyG,GAAS1K,GAChB,OAAe,OAARA,GAA+B,iBAARA,EAGhC,SAASyK,GACPxG,EACAE,EACAoG,GAEA,OAAIG,GAASvG,IAAWuG,GAASzG,IAG3BhM,OAAO0S,eAAiB1S,OAAO0S,aAAa1G,KAC9CA,EAASuG,GAAoBvG,EAAQsG,IAGvCtS,OAAOyJ,KAAKyC,GAAQtD,SAAQ,SAAA+J,GAC1B,IAAMC,EAAc1G,EAAOyG,GAC3B,GAAItS,EAAee,KAAK4K,EAAQ2G,GAAY,CAC1C,IAAME,EAAc7G,EAAO2G,GACvBC,IAAgBC,IAQlB7G,EAAO2G,GAAaH,GAClBD,GAAoBM,EAAaP,GACjCM,EACAN,SAMJtG,EAAO2G,GAAaC,KAIjB5G,GAIFE,EAGT,SAASqG,GAAuBnQ,EAAUkQ,GAgBxC,OAdY,OAAVlQ,GACiB,iBAAVA,GACPkQ,EAAW9Q,QAAQY,GAAS,IAG1BA,EADEjC,MAAM2S,QAAQ1Q,GACPA,EAAc8O,MAAM,GAErB,OAAH,IAAG,CAAH,CACHhR,UAAWF,OAAOqR,eAAejP,IAC9BA,GAGPkQ,EAAW1O,KAAKxB,IAEXA,EC/GUpC,OAAOW,OAAO,M,+CCF3B,yDAAEiQ,EAAA,EAAAA,SAAUvQ,EAAA,EAAAA,eACZ0S,EAAsB,IAAI9M,I,SAKhB+M,EAAM/O,EAAQlE,GAC5B,IACE,OASJ,SAASkT,EAAMhP,EAAQlE,GAErB,GAAIkE,IAAMlE,EACR,OAAO,EAKT,IAAMmT,EAAOtC,EAASxP,KAAK6C,GACrBkP,EAAOvC,EAASxP,KAAKrB,GAK3B,GAAImT,IAASC,EACX,OAAO,EAGT,OAAQD,GACN,IAAK,iBAGH,GAAIjP,EAAE9C,SAAWpB,EAAEoB,OAAQ,OAAO,EAEpC,IAAK,kBACH,GAAIiS,EAAmBnP,EAAGlE,GAAI,OAAO,EAErC,IAAMsT,EAAQrT,OAAOyJ,KAAKxF,GACpBqP,EAAQtT,OAAOyJ,KAAK1J,GAIpBwT,EAAWF,EAAMlS,OACvB,GAAIoS,IAAaD,EAAMnS,OAAQ,OAAO,EAGtC,IAAK,IAAI6C,EAAI,EAAGA,EAAIuP,IAAYvP,EAC9B,IAAK3D,EAAee,KAAKrB,EAAGsT,EAAMrP,IAChC,OAAO,EAKX,IAASA,EAAI,EAAGA,EAAIuP,IAAYvP,EAAG,CACjC,IAAMoF,EAAMiK,EAAMrP,GAClB,IAAKiP,EAAMhP,EAAEmF,GAAMrJ,EAAEqJ,IACnB,OAAO,EAIX,OAAO,EAGT,IAAK,iBACH,OAAOnF,EAAEM,OAASxE,EAAEwE,MAAQN,EAAEG,UAAYrE,EAAEqE,QAE9C,IAAK,kBAEH,GAAIH,GAAMA,EAAG,OAAOlE,GAAMA,EAE5B,IAAK,mBACL,IAAK,gBACH,OAAQkE,IAAOlE,EAEjB,IAAK,kBACL,IAAK,kBACH,OAAOkE,GAAK,GAAGlE,EAEjB,IAAK,eACL,IAAK,eACH,GAAIkE,EAAEuP,OAASzT,EAAEyT,KAAM,OAAO,EAC9B,GAAIJ,EAAmBnP,EAAGlE,GAAI,OAAO,EAKrC,IAHA,IAAM0T,EAAYxP,EAAEyP,UACdC,EAAiB,iBAATT,IAED,CACX,IAAMU,EAAOH,EAAUnR,OACvB,GAAIsR,EAAKnR,KAAM,MAGT,cAACoR,EAAA,KAAMC,EAAA,KAGb,IAAK/T,EAAEkR,IAAI4C,GACT,OAAO,EAKT,GAAIF,IAAUV,EAAMa,EAAQ/T,EAAE4G,IAAIkN,IAChC,OAAO,EAIX,OAAO,EAKX,OAAO,EA7GEZ,CAAMhP,EAAGlE,GADlB,QAGEgT,EAAoBgB,SA8GxB,SAASX,EAAmBnP,EAAWlE,GASrC,IAAIiU,EAAOjB,EAAoBpM,IAAI1C,GACnC,GAAI+P,GAGF,GAAIA,EAAK/C,IAAIlR,GAAI,OAAO,OAExBgT,EAAoB5B,IAAIlN,EAAG+P,EAAO,IAAIC,KAGxC,OADAD,EAAKE,IAAInU,IACF,I,yCC1HIoU,E,OAMJ,E,oCCpBTnU,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQC,MAoJR,SAAeC,EAAMC,GACnB,IAAIC,EAAcvT,UAAUC,OAAS,QAAsBoJ,IAAjBrJ,UAAU,GAAmBA,UAAU,GAAKwT,EAGlFC,OAAQpK,EACRqK,EAAUzU,MAAM2S,QAAQyB,GACxB9K,EAAO,CAAC8K,GACRM,GAAS,EACTC,EAAQ,GACRxJ,OAAOf,EACPnB,OAAMmB,EACNmE,OAASnE,EACTwK,EAAO,GACPC,EAAY,GACZC,EAAUV,EAGd,EAAG,CAED,IAAIW,IADJL,IAC0BpL,EAAKtI,OAC3BgU,EAAWD,GAA8B,IAAjBJ,EAAM3T,OAElC,GAAI+T,EAAW,CAKb,GAJA9L,EAA2B,IAArB4L,EAAU7T,YAAeoJ,EAAYwK,EAAKA,EAAK5T,OAAS,GAC9DmK,EAAOoD,EACPA,EAASsG,EAAUrR,MAEfwR,EAAU,CACZ,GAAIP,EACFtJ,EAAOA,EAAK4F,YACP,CAGL,IAFA,IAAIkE,EAAQ,GAEHC,EAAM,EAAGC,EAAgBtV,OAAOyJ,KAAK6B,GAAO+J,EAAMC,EAAcnU,OAAQkU,IAAO,CACtF,IAAIrR,EAAIsR,EAAcD,GACtBD,EAAMpR,GAAKsH,EAAKtH,GAGlBsH,EAAO8J,EAKT,IAFA,IAAIG,EAAa,EAERC,EAAK,EAAGA,EAAKV,EAAM3T,OAAQqU,IAAM,CACxC,IAAIC,EAAUX,EAAMU,GAAI,GACpBE,EAAYZ,EAAMU,GAAI,GAEtBZ,IACFa,GAAWF,GAGTX,GAAyB,OAAdc,GACbpK,EAAKqK,OAAOF,EAAS,GACrBF,KAEAjK,EAAKmK,GAAWC,GAKtBb,EAAQF,EAAME,MACdpL,EAAOkL,EAAMlL,KACbqL,EAAQH,EAAMG,MACdF,EAAUD,EAAMC,QAChBD,EAAQA,EAAMiB,SACT,CAIL,GAHAxM,EAAMsF,EAASkG,EAAUC,EAAQpL,EAAKoL,QAAStK,EAG3Ce,OAFJA,EAAOoD,EAASA,EAAOtF,GAAO6L,GAG5B,SAGEvG,GACFqG,EAAKnR,KAAKwF,GAId,IAAI5G,OAAS,EAEb,IAAKrC,MAAM2S,QAAQxH,GAAO,CACxB,IAAKuK,EAAOvK,GACV,MAAM,IAAI7G,MAAM,sBAAuB,EAAIqR,EAASC,SAASzK,IAG/D,IAAI0K,EAAUC,EAAWzB,EAASlJ,EAAKtE,KAAMkO,GAE7C,GAAIc,EAAS,CAGX,IAFAxT,EAASwT,EAAQ5U,KAAKoT,EAASlJ,EAAMlC,EAAKsF,EAAQqG,EAAMC,MAEzCkB,EACb,MAGF,IAAe,IAAX1T,GACF,IAAK0S,EAAW,CACdH,EAAKpR,MACL,eAEG,QAAe4G,IAAX/H,IACTsS,EAAMlR,KAAK,CAACwF,EAAK5G,KAEZ0S,GAAW,CACd,IAAIW,EAAOrT,GAEJ,CACLuS,EAAKpR,MACL,SAHA2H,EAAO9I,SAUF+H,IAAX/H,GAAwB2S,GAC1BL,EAAMlR,KAAK,CAACwF,EAAKkC,IAGf4J,EACFH,EAAKpR,OAELgR,EAAQ,CACNC,QAASA,EACTC,MAAOA,EACPpL,KAAMA,EACNqL,MAAOA,EACPc,KAAMjB,GAERC,EAAUzU,MAAM2S,QAAQxH,GACxB7B,EAAOmL,EAAUtJ,EAAOmJ,EAAYnJ,EAAKtE,OAAS,GAClD6N,GAAS,EACTC,EAAQ,GAEJpG,GACFsG,EAAUpR,KAAK8K,GAGjBA,EAASpD,cAEMf,IAAVoK,GAEY,IAAjBG,EAAM3T,SACR8T,EAAUH,EAAMA,EAAM3T,OAAS,GAAG,IAGpC,OAAO8T,GApSTZ,EAAQ8B,gBAkTR,SAAyBC,GACvB,IAAIC,EAAW,IAAIlW,MAAMiW,EAASjV,QAClC,MAAO,CACLqN,MAAO,SAAelD,GACpB,IAAK,IAAItK,EAAI,EAAGA,EAAIoV,EAASjV,OAAQH,IACnC,IAAKqV,EAASrV,GAAI,CAChB,IAAIsV,EAAKL,EAAWG,EAASpV,GAAIsK,EAAKtE,MAEtC,GAEA,GAAIsP,EAAI,CACN,IAAI9T,EAAS8T,EAAGjV,MAAM+U,EAASpV,GAAIE,WAEnC,IAAe,IAAXsB,EACF6T,EAASrV,GAAKsK,OACT,GAAI9I,IAAW0T,EACpBG,EAASrV,GAAKkV,OACT,QAAe3L,IAAX/H,EACT,OAAOA,KAMjB+T,MAAO,SAAejL,GACpB,IAAK,IAAItK,EAAI,EAAGA,EAAIoV,EAASjV,OAAQH,IACnC,GAAKqV,EAASrV,GAcHqV,EAASrV,KAAOsK,IACzB+K,EAASrV,GAAK,UAfE,CAChB,IAAIsV,EAAKL,EAAWG,EAASpV,GAAIsK,EAAKtE,MAEtC,GAEA,GAAIsP,EAAI,CACN,IAAI9T,EAAS8T,EAAGjV,MAAM+U,EAASpV,GAAIE,WAEnC,GAAIsB,IAAW0T,EACbG,EAASrV,GAAKkV,OACT,QAAe3L,IAAX/H,IAAmC,IAAXA,EACjC,OAAOA,OAtVrB6R,EAAQmC,kBAsWR,SAA2BC,EAAUjC,GACnC,MAAO,CACLhG,MAAO,SAAelD,GACpBmL,EAASjI,MAAMlD,GACf,IAAIgL,EAAKL,EAAWzB,EAASlJ,EAAKtE,MAElC,GAEA,GAAIsP,EAAI,CACN,IAAI9T,EAAS8T,EAAGjV,MAAMmT,EAAStT,WAU/B,YAReqJ,IAAX/H,IACFiU,EAASF,MAAMjL,GAEXuK,EAAOrT,IACTiU,EAASjI,MAAMhM,IAIZA,IAGX+T,MAAO,SAAejL,GACpB,IAGI9I,EAHA8T,EAAKL,EAAWzB,EAASlJ,EAAKtE,MAElC,GAQA,OALIsP,IACF9T,EAAS8T,EAAGjV,MAAMmT,EAAStT,YAG7BuV,EAASF,MAAMjL,GACR9I,KAtYb6R,EAAQ4B,WAAaA,EACrB5B,EAAQ6B,MAAQ7B,EAAQK,uBAAoB,EAE5C,IAEgC3M,EAF5B+N,GAE4B/N,EAFM2O,EAAQ,MAEO3O,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,GAEvF,IAAI2M,EAAoB,CACtBkC,KAAM,GACNC,SAAU,CAAC,eACXtH,oBAAqB,CAAC,OAAQ,sBAAuB,aAAc,gBACnEuH,mBAAoB,CAAC,WAAY,OAAQ,eAAgB,cACzDvI,SAAU,CAAC,QACX0B,aAAc,CAAC,cACftB,MAAO,CAAC,QAAS,OAAQ,YAAa,aAAc,gBACpDe,SAAU,CAAC,OAAQ,SACnBT,eAAgB,CAAC,OAAQ,cACzB8H,eAAgB,CAAC,gBAAiB,aAAc,gBAChDjH,mBAAoB,CAAC,OAErB,sBAAuB,gBAAiB,aAAc,gBACtDkH,SAAU,GACVC,WAAY,GACZC,YAAa,GACbC,aAAc,GACdC,UAAW,GACXC,UAAW,GACXC,UAAW,CAAC,UACZC,YAAa,CAAC,UACdC,YAAa,CAAC,OAAQ,SACtBnM,UAAW,CAAC,OAAQ,aACpBoM,UAAW,CAAC,QACZC,SAAU,CAAC,QACXC,YAAa,CAAC,QACdC,iBAAkB,CAAC,aAAc,kBACjCC,wBAAyB,CAAC,QAC1BC,qBAAsB,CAAC,cAAe,OAAQ,cAC9CC,qBAAsB,CAAC,cAAe,OAAQ,aAAc,aAAc,UAC1EC,gBAAiB,CAAC,cAAe,OAAQ,YAAa,OAAQ,cAC9DC,qBAAsB,CAAC,cAAe,OAAQ,OAAQ,eAAgB,cACtEC,wBAAyB,CAAC,cAAe,OAAQ,aAAc,UAC/DC,oBAAqB,CAAC,cAAe,OAAQ,aAAc,SAC3DC,mBAAoB,CAAC,cAAe,OAAQ,aAAc,UAC1DC,oBAAqB,CAAC,cAAe,OAAQ,cAC7CC,0BAA2B,CAAC,cAAe,OAAQ,aAAc,UACjEC,oBAAqB,CAAC,cAAe,OAAQ,YAAa,aAC1DC,gBAAiB,CAAC,aAAc,kBAChCC,oBAAqB,CAAC,OAAQ,cAC9BC,oBAAqB,CAAC,OAAQ,aAAc,aAAc,UAC1DC,uBAAwB,CAAC,OAAQ,aAAc,UAC/CC,mBAAoB,CAAC,OAAQ,aAAc,SAC3CC,kBAAmB,CAAC,OAAQ,aAAc,UAC1CC,yBAA0B,CAAC,OAAQ,aAAc,WAEnDzE,EAAQK,kBAAoBA,EAC5B,IAAIwB,EAAQlW,OAAO+R,OAAO,IA8O1B,SAAS8D,EAAOkD,GACd,OAAOC,QAAQD,GAAuC,iBAAnBA,EAAU/R,MA0G/C,SAASiP,EAAWzB,EAASxN,EAAMkO,GACjC,IAAI+D,EAAczE,EAAQxN,GAE1B,GAAIiS,EAAa,CACf,IAAK/D,GAAoC,mBAAhB+D,EAEvB,OAAOA,EAGT,IAAIC,EAAsBhE,EAAY+D,EAAY1C,MAAQ0C,EAAYzK,MAEtE,GAAmC,mBAAxB0K,EAET,OAAOA,MAEJ,CACL,IAAIC,EAAkBjE,EAAYV,EAAQ+B,MAAQ/B,EAAQhG,MAE1D,GAAI2K,EAAiB,CACnB,GAA+B,mBAApBA,EAET,OAAOA,EAGT,IAAIC,EAAsBD,EAAgBnS,GAE1C,GAAmC,mBAAxBoS,EAET,OAAOA,IA7Rf/E,EAAQ6B,MAAQA,G,6BCrJhBlW,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0B,QAcR,SAAiB3T,GACf,OAAOiX,EAAYjX,EAAO,KAb5B,IAEgC2F,EAF5BuR,GAE4BvR,EAFwB2O,EAAQ,MAEX3O,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,GAEvF,SAASwR,EAAQxR,GAAwT,OAAtOwR,EAArD,mBAAXjW,QAAoD,iBAApBA,OAAOC,SAAmC,SAAiBwE,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,mBAAXzE,QAAyByE,EAAItH,cAAgB6C,QAAUyE,IAAQzE,OAAO5C,UAAY,gBAAkBqH,IAAyBA,GAYxV,SAASsR,EAAYjX,EAAOoX,GAC1B,OAAQD,EAAQnX,IACd,IAAK,SACH,OAAOiH,KAAKC,UAAUlH,GAExB,IAAK,WACH,OAAOA,EAAMmC,KAAO,aAAakV,OAAOrX,EAAMmC,KAAM,KAAO,aAE7D,IAAK,SACH,OAAc,OAAVnC,EACK,OAUf,SAA2BA,EAAOsX,GAChC,IAA6C,IAAzCA,EAAqBlY,QAAQY,GAC/B,MAAO,aAGT,IAAIoX,EAAa,GAAGC,OAAOC,EAAsB,CAACtX,IAC9CuX,EA4DN,SAAqBC,GACnB,IAAID,EAAkBC,EAAOC,OAAOP,EAA2BvD,UAE/D,GAA+B,mBAApB4D,EACT,OAAOA,EAGT,GAA8B,mBAAnBC,EAAOE,QAChB,OAAOF,EAAOE,QApEMC,CAAY3X,GAElC,QAAwBmI,IAApBoP,EAA+B,CAEjC,IAAIK,EAAcL,EAAgBvY,KAAKgB,GAEvC,GAAI4X,IAAgB5X,EAClB,MAA8B,iBAAhB4X,EAA2BA,EAAcX,EAAYW,EAAaR,QAE7E,GAAIrZ,MAAM2S,QAAQ1Q,GACvB,OAwBJ,SAAqBmL,EAAOiM,GAC1B,GAAqB,IAAjBjM,EAAMpM,OACR,MAAO,KAGT,GAAIqY,EAAWrY,OA1ES,EA2EtB,MAAO,UAOT,IAJA,IAAI8Y,EAAMC,KAAKC,IA/EM,GA+EgB5M,EAAMpM,QACvCiZ,EAAY7M,EAAMpM,OAAS8Y,EAC3BI,EAAQ,GAEHrZ,EAAI,EAAGA,EAAIiZ,IAAOjZ,EACzBqZ,EAAMzW,KAAKyV,EAAY9L,EAAMvM,GAAIwY,IAGjB,IAAdY,EACFC,EAAMzW,KAAK,mBACFwW,EAAY,GACrBC,EAAMzW,KAAK,OAAO6V,OAAOW,EAAW,gBAGtC,MAAO,IAAMC,EAAMC,KAAK,MAAQ,IA/CvBC,CAAYnY,EAAOoX,GAG5B,OAGF,SAAsBI,EAAQJ,GAC5B,IAAI/P,EAAOzJ,OAAOyJ,KAAKmQ,GAEvB,GAAoB,IAAhBnQ,EAAKtI,OACP,MAAO,KAGT,GAAIqY,EAAWrY,OA1DS,EA2DtB,MAAO,IAgDX,SAAsByY,GACpB,IAAIY,EAAMxa,OAAOU,UAAUkQ,SAASxP,KAAKwY,GAAQa,QAAQ,aAAc,IAAIA,QAAQ,KAAM,IAEzF,GAAY,WAARD,GAAkD,mBAAvBZ,EAAOnZ,YAA4B,CAChE,IAAI8D,EAAOqV,EAAOnZ,YAAY8D,KAE9B,GAAoB,iBAATA,GAA8B,KAATA,EAC9B,OAAOA,EAIX,OAAOiW,EA3DQE,CAAad,GAAU,IAOtC,MAAO,KAJUnQ,EAAK3B,KAAI,SAAUsB,GAElC,OAAOA,EAAM,KADDiQ,EAAYO,EAAOxQ,GAAMoQ,MAGdc,KAAK,MAAQ,KAlB/BK,CAAavY,EAAOoX,GA1BhBoB,CAAkBxY,EAAOoX,GAElC,QACE,OAAOK,OAAOzX,M,6BCrCpBpC,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0B,aAAU,EAClB,IACI8E,EAD8C,mBAAXvX,QAA+C,mBAAfA,OAAOwX,IAAqBxX,OAAOwX,IAAI,mCAAgCvQ,EAE9I8J,EAAQ0B,QAAU8E,G,6BCNlB7a,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0B,QAER,SAAmBpR,EAAWP,GAG5B,IAFuB4U,QAAQrU,GAG7B,MAAM,IAAIF,MAAML,K,6BCTpBpE,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0B,QAUR,SAAsBgF,GACpB,IAAIzE,EAAKpV,UAAUC,OAAS,QAAsBoJ,IAAjBrJ,UAAU,GAAmBA,UAAU,GAAK6Z,EAAYra,UAAUkQ,SACnGmK,EAAYra,UAAUsa,OAAS1E,EAC/ByE,EAAYra,UAAUoZ,QAAUxD,EAE5BgD,EAA2BvD,UAC7BgF,EAAYra,UAAU4Y,EAA2BvD,SAAWO,IAdhE,IAEgCvO,EAF5BuR,GAE4BvR,EAFwB2O,EAAQ,MAEX3O,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,I,6BCPvF/H,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ4G,YAQR,SAAqB/O,EAAQgP,EAAUC,GACrC,OAAO,IAAIC,EAAcC,aAAa,iBAAiB5B,OAAO0B,QAAc5Q,EAAW2B,EAAQ,CAACgP,KAPlG,IAAIE,EAAgB1E,EAAQ,K,6BCL5B1W,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQiH,YAUR,SAAqBpP,EAAQgP,GAC3B,IAGIK,EAHAC,EAAa,eACbC,EAAO,EACPC,EAASR,EAAW,EAGxB,MAAQK,EAAQC,EAAWG,KAAKzP,EAAOtJ,QAAU2Y,EAAM1G,MAAQqG,GAC7DO,GAAQ,EACRC,EAASR,EAAW,GAAKK,EAAM1G,MAAQ0G,EAAM,GAAGpa,QAGlD,MAAO,CACLsa,KAAMA,EACNC,OAAQA,K,6BCaZ,SAASE,EAA0BC,GAGjC,IAFA,IAAIC,EAAe,KAEV9a,EAAI,EAAGA,EAAI6a,EAAM1a,OAAQH,IAAK,CACrC,IAAIya,EAAOI,EAAM7a,GACb+a,EAASC,EAAkBP,GAE/B,GAAIM,IAAWN,EAAKta,UAIC,OAAjB2a,GAAyBC,EAASD,IAGf,KAFrBA,EAAeC,IAGb,MAKN,OAAwB,OAAjBD,EAAwB,EAAIA,EAGrC,SAASE,EAAkBC,GAGzB,IAFA,IAAIjb,EAAI,EAEDA,EAAIib,EAAI9a,SAAsB,MAAX8a,EAAIjb,IAAyB,OAAXib,EAAIjb,KAC9CA,IAGF,OAAOA,EAGT,SAASkb,EAAQD,GACf,OAAOD,EAAkBC,KAASA,EAAI9a,OAzExCnB,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ8H,uBAUR,SAAgCC,GAE9B,IAAIP,EAAQO,EAAUC,MAAM,gBAExBP,EAAeF,EAA0BC,GAE7C,GAAqB,IAAjBC,EACF,IAAK,IAAI9a,EAAI,EAAGA,EAAI6a,EAAM1a,OAAQH,IAChC6a,EAAM7a,GAAK6a,EAAM7a,GAAGkQ,MAAM4K,GAK9B,KAAOD,EAAM1a,OAAS,GAAK+a,EAAQL,EAAM,KACvCA,EAAMS,QAGR,KAAOT,EAAM1a,OAAS,GAAK+a,EAAQL,EAAMA,EAAM1a,OAAS,KACtD0a,EAAMlY,MAIR,OAAOkY,EAAMvB,KAAK,OA/BpBjG,EAAQuH,0BAA4BA,EACpCvH,EAAQkI,iBA6ER,SAA0Bna,GACxB,IAAIoa,EAActb,UAAUC,OAAS,QAAsBoJ,IAAjBrJ,UAAU,GAAmBA,UAAU,GAAK,GAClFub,EAAsBvb,UAAUC,OAAS,QAAsBoJ,IAAjBrJ,UAAU,IAAmBA,UAAU,GACrFwb,GAAwC,IAAzBta,EAAMZ,QAAQ,MAC7Bmb,EAA+B,MAAbva,EAAM,IAA2B,OAAbA,EAAM,GAC5Cwa,EAA+C,MAA5Bxa,EAAMA,EAAMjB,OAAS,GACxC0b,GAAwBH,GAAgBE,GAAoBH,EAC5Dja,EAAS,IAETqa,GAA0BH,GAAgBC,IAC5Cna,GAAU,KAAOga,GAGnBha,GAAUga,EAAcpa,EAAMqY,QAAQ,MAAO,KAAO+B,GAAepa,EAE/Dya,IACFra,GAAU,MAGZ,MAAO,MAAQA,EAAOiY,QAAQ,OAAQ,SAAW,Q,6BCrGnDza,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQyI,eAAY,EAMpB,IAAIA,EAAY9c,OAAO+R,OAAO,CAC5BgL,IAAK,QACLC,IAAK,QACLC,KAAM,IACNC,OAAQ,IACRC,IAAK,IACLC,QAAS,IACTC,QAAS,IACTC,OAAQ,MACRC,MAAO,IACPC,OAAQ,IACRC,GAAI,IACJC,UAAW,IACXC,UAAW,IACXC,QAAS,IACTC,KAAM,IACNC,QAAS,IACTC,KAAM,OACNC,IAAK,MACLC,MAAO,QACPC,OAAQ,SACRC,aAAc,cACdC,QAAS,YAMX/J,EAAQyI,UAAYA,G,yHC1BpB,aAUE,WAAYuB,EAAmCvY,GATxC,KAAAwY,WAAqB,EACrB,KAAAC,gBAA2C,GAG3C,KAAAzY,QAA8B,GAG7B,KAAAuY,QAAmC,GAGzC7d,KAAK6d,QAAUA,GAAY,GAC3B7d,KAAKsF,QAAUA,GAAW,GA2D9B,OAxDS,YAAA0Y,WAAP,WACE,OAAOhe,KAAK6d,SAGP,YAAAI,WAAP,SACEC,EACAC,QAAA,IAAAA,OAAA,GAEIA,IAAkBC,YAAQpe,KAAK6d,QAASK,KAC1Cle,KAAK+d,gBAAkB/d,KAAK6d,SAE9B7d,KAAK6d,QAAUK,GAOP,YAAAG,QAAV,WACEre,KAAK8d,WAAY,GAGT,YAAAQ,cAAV,WACE,IAAMnZ,EACHnF,KAAK6d,SAAW7d,KAAK6d,QAAQ1Y,QAC7BnF,KAAKsF,SAAWtF,KAAKsF,QAAQH,OAI9B,mBAKF,IAAIoZ,GAAQ,EAMZ,OALIpZ,IAAWnF,KAAKmF,SAClBoZ,GAAQ,EACRve,KAAKmF,OAASA,EACdnF,KAAKwe,WAEA,CACLrZ,OAAQnF,KAAKmF,OACboZ,MAAK,IAIC,YAAAE,mBAAV,SAA6BzY,EAAwBL,GACnD,IAAMe,EAAY,YAAOV,GACK,YAAcL,GAClB,YAAce,EAAUf,MAEtC,YACG,eAInB,EAvEA,ICaA,YAQE,WAAY,G,IACVkY,EAAA,EAAAA,QACAvY,EAAA,EAAAA,QACAoZ,EAAA,EAAAA,UAHF,EASE,YAAMb,EAASvY,IAAQ,K,OAdjB,EAAAqZ,aAAqD,GACrD,EAAAC,kBAA+D,GAC/D,EAAAC,SAAmB,EAoGnB,EAAAC,aAAe,SAACjB,GACtB,EAAKW,UACL,EAAKK,SAAU,EACf,EAAKE,YAAclB,EACnB,EAAKa,aAGC,EAAAM,iBAAmB,WACzB,IAAMhd,EAAS,EAAKid,iBAEpB,OADA,EAAKC,yBACEld,GA8SD,EAAAmd,WAAa,SAAClZ,GACpB,SAAK2Y,kBAAkBQ,MAAOC,QAAQpZ,IAEhC,EAAAqZ,aAAe,SACrBC,GAEG,SAAKX,kBAAkBQ,MAAOI,UAAUD,IAErC,EAAAE,eAAiB,SACvBC,GAIG,SAAKd,kBAAkBQ,MAAOO,YAAYD,IAEvC,EAAAE,gBAAkB,SAACC,GACzB,EAAKjB,mBACH,EAAKA,kBAAkBQ,OACvB,EAAKR,kBAAkBQ,MAAOU,aAAaD,IAGvC,EAAAE,eAAiB,WACvB,EAAKnB,mBACH,EAAKA,kBAAkBQ,OACvB,EAAKR,kBAAkBQ,MAAOY,eAG1B,EAAAC,mBAAqB,SAI3BpC,GAKG,SAAKe,kBAAkBQ,MAAOc,gBAAgBrC,IAnbjD,EAAKa,UAAYA,E,EAlB6B,iBAqBzC,YAAAyB,QAAP,WACEngB,KAAKse,gBAEC,wBAAE8B,EAAA,EAAAA,KAAMhB,EAAA,EAAAA,MAUd,OATIgB,GAAQhB,IAAUpf,KAAK2e,aAAaS,SACtCpf,KAAKqgB,0BACLrgB,KAAK2e,aAAaS,MAAQA,GAG5Bpf,KAAKsgB,wBAEDtgB,KAAK8d,WAAW9d,KAAKkf,yBAElBlf,KAAKugB,uBAAyBvgB,KAAKgf,oBAGrC,YAAAwB,YAAP,WACE,OAAQxgB,KAAK6e,QAUT,CAAC7e,KAAK8e,aAAc9e,KAAKmgB,WATzB,CACEngB,KAAK8e,aACL,CACE2B,SAAS,EACTC,cAAe,IAAcC,MAC7BC,QAAQ,EACRC,UAAM9W,KAOT,YAAA+W,UAAP,WACE,IAAMjD,EAAU7d,KAAKge,aACrB,GAAIH,EAAQuC,OAAwB,IAAhBvC,EAAQkD,IAAe,OAAO,EAGlD,IAAMC,EAAMhhB,KAAK4e,kBAAkBQ,MAEnC,QADsB4B,EAAIC,mBACLR,SAAUO,EAAIhf,UAG9B,YAAAkf,aAAP,SAAoB,G,IAAE,oBAAAC,YAAA,IAAO,GAAP,EAQpB,OAPAnhB,KAAK8d,WAAY,EAEZqD,IAAQnhB,KAAK6e,SAChB7e,KAAKohB,yBAGPphB,KAAK+d,gBAAkB/d,KAAKge,aACrBhe,KAAKqe,QAAQgD,KAAKrhB,OAGpB,YAAAwe,QAAP,WACExe,KAAKqgB,iCACErgB,KAAK4e,kBAAkBQ,aACvBpf,KAAK2e,aAAa3c,QAGpB,YAAAgc,WAAP,WACE,IAAMH,EAAU,YAAMG,WAAU,WAkBhC,OAhBIhe,KAAK+e,cACPlB,EAAQ5X,UAAS,2BACZ4X,EAAQ5X,WACRjG,KAAK+e,YAAY9Y,WAEtB4X,EAAQvY,QAAO,2BACVuY,EAAQvY,SACRtF,KAAK+e,YAAYzZ,UAKpBtF,KAAK6e,gBACAhB,EAAQuC,KAGVvC,GAGF,YAAAyD,aAAP,WACE,OAAOthB,KAAKsF,SAAWtF,KAAKsF,QAAQic,gBAgB9B,YAAAhB,oBAAR,WACE,IAoBIve,EApBEwf,GAAwC,IAA1BxhB,KAAKge,aAAa+C,IAChCU,EAAgBzhB,KAAKse,gBAAgBnZ,OAAOuc,sBAE5CC,EAAa,aACjBlB,SAAS,EACTC,cAAe,IAAcD,QAC7BG,QAAQ,EACRC,UAAM9W,EACN6X,OAAO,EACPzc,OAAQnF,KAAKmF,QACVnF,KAAK6hB,yBAKV,OAAIL,IAAgBxhB,KAAKshB,gBAAkBG,IACzCzhB,KAAK2e,aAAa3c,OAAS2f,EACpBA,IAIL3hB,KAAKshB,iBACPtf,EACEhC,KAAKsF,QAAQic,eAAgBO,gBAC3B9hB,KACAA,KAAKgf,mBACF2C,GAGF3f,IAGD,YAAA+f,8BAAR,WACE,IAAMlE,EAAU7d,KAAKge,aACrBhe,KAAKye,mBAAmBZ,EAAQuB,MAAO,IAAaxZ,OACpD,IAAMoc,EAAcnE,EAAQmE,aAAe,QAY3C,OAPEhiB,KAAKshB,gBACoB,iBAAxBzD,EAAQoE,aACiB,sBAAxBpE,EAAQoE,cAEVpE,EAAQoE,YAAc,eAGxB,2BACKpE,GAAO,CACVmE,YAAW,EACX1c,QAASuY,EAAQvY,QACjB4c,SAAU,CAAEC,eAAgB,CAAEH,YAAW,OAIrC,YAAAI,0BAAR,W,QAUE,GANIpiB,KAAKshB,iBACPthB,KAAK4e,kBAAkBQ,MAAQpf,KAAKsF,QAASic,eAAgBc,iBAC3DriB,KAAKge,gBAIJhe,KAAK4e,kBAAkBQ,MAAO,CACjC,IAAMkD,EAAyBtiB,KAAK+hB,gCAEpC/hB,KAAK2e,aAAa2D,uBAAsB,2BACnCA,GAAsB,CACzBld,SAAU,OAEZpF,KAAK4e,kBAAkBQ,MAAQpf,KAAKse,gBAAgBnZ,OAAOod,WAAU,eAChED,IAGDtiB,KAAKshB,iBACqB,QAA5B,EAAY,QAAZ,EAAAthB,KAAKsF,eAAO,eAAEic,sBAAc,SAAEiB,sBAC5BxiB,KAAK4e,kBAAkBQ,MACvBkD,MAMA,YAAAhC,sBAAR,WAEE,GAAKtgB,KAAK4e,kBAAkBQ,MAA5B,CAKA,IAAMqD,EAA4B,OAAH,IAAG,CAAH,eAC1BziB,KAAK+hB,iCAA+B,CACvC3c,SAAU,OAITgZ,YACCqE,EACAziB,KAAK2e,aAAa2D,0BAGpBtiB,KAAK2e,aAAa2D,uBAAyBG,EAC3CziB,KAAK4e,kBACFQ,MAAOnB,WAAWwE,GAKlBC,OAAM,qBAtBT1iB,KAAKoiB,6BA0BD,YAAAlD,uBAAR,sBACE,IAAIlf,KAAK4e,kBAAkB+D,eAAgB3iB,KAAKge,aAAaoC,KAA7D,CAEA,IAAMwC,EAAW5iB,KAAK4e,kBAAkBQ,MACxCpf,KAAK4e,kBAAkB+D,aAAeC,EAASC,UAAU,CACvD/gB,KAAM,SAAC,G,IAAE2e,EAAA,EAAAA,QAASC,EAAA,EAAAA,cAAeG,EAAA,EAAAA,KACzBiC,EAAiB,EAAKnE,aAAa3c,OAIvC8gB,GACAA,EAAerC,UAAYA,GAC3BqC,EAAepC,gBAAkBA,GACjCtC,YAAQ0E,EAAejC,KAAMA,IAK/B,EAAKnC,aAEPla,MAAO,SAACA,GAEN,GADA,EAAKue,sBACAve,EAAM3E,eAAe,iBAAkB,MAAM2E,EAElD,IAAMse,EAAiB,EAAKnE,aAAa3c,QAEtC8gB,GAAkBA,EAAerC,UACjCrC,YAAQ5Z,EAAO,EAAKma,aAAana,UAElC,EAAKma,aAAana,MAAQA,EAC1B,EAAKka,kBAML,YAAAqE,mBAAR,WACE/iB,KAAKqgB,0BASL,IAAM2C,EAAYhjB,KAAK4e,kBAAkBQ,MAAO6D,eAC1CC,EAAaljB,KAAK4e,kBAAkBQ,MAAO+D,gBACjDnjB,KAAK4e,kBAAkBQ,MAAOgE,mBAC9BpjB,KAAKkf,yBACL1f,OAAOa,OAAOL,KAAK4e,kBAAkBQ,MAAQ,CAC3C4D,UAAS,EACTE,WAAU,KAIN,YAAAjE,eAAR,WACE,IAAIjd,EAAchC,KAAK6hB,wBACjBhE,EAAU7d,KAAKge,aAKrB,GAAIH,EAAQuC,KACVpe,EAAS,OAAH,IAAG,CAAH,eACDA,GAAM,CACT6e,UAAM9W,EACNvF,WAAOuF,EACP0W,SAAS,EACTG,QAAQ,QAEL,CAEL,IAAMyC,EAAgBrjB,KAAK4e,kBAAkBQ,MAAO6B,mBAC5CR,EAAA,EAAAA,QAAS6C,EAAA,EAAAA,QAAS5C,EAAA,EAAAA,cAAevP,EAAA,EAAAA,OACnC3M,EAAA,EAAAA,MAAOqc,EAAA,EAAAA,KAgBb,GAZI1P,GAAUA,EAAOxQ,OAAS,IAC5B6D,EAAQ,IAAI,IAAY,CAAE+e,cAAepS,KAG3CnP,EAAS,OAAH,IAAG,CAAH,eACDA,GAAM,CACTye,QAAO,EACPC,cAAa,EACblc,MAAK,EACLoc,QAAQ,IAGNH,EAAS,CACX,IAAM9B,EACJ3e,KAAK2e,aAAa3c,QAAUhC,KAAK2e,aAAa3c,OAAO6e,KACvD7e,EAAO6e,KACLlC,GAAgBkC,E,2BAEPlC,GACAkC,GAELlC,GAAgBkC,OACjB,GAAIrc,EACThF,OAAOa,OAAO2B,EAAQ,CACpB6e,MAAO7gB,KAAK4e,kBAAkBQ,MAAO+D,iBAAoB,IACtDtC,WAEA,CACG,IAAAoB,EAAA,qCAAAA,YAER,GADQ,EAAAuB,iBAGL3C,GACDyC,GACgB,eAAhBrB,EAeA,OALAziB,OAAOa,OAAO2B,EAAQ,CACpBye,SAAS,EACTC,cAAe,IAAcD,UAE/Bze,EAAOqd,UACArd,EAGTA,EAAO6e,KAAOA,GAgBlB,OAZA7e,EAAOmD,OAASnF,KAAKmF,OACrBnF,KAAK2e,aAAa8B,QACfzgB,KAAK2e,aAAa3c,QAAUhC,KAAK2e,aAAa3c,OAAOye,UAAY,EACpEzgB,KAAK2e,aAAa3c,OAASA,EAM3BhC,KAAK4e,kBAAkBQ,OACrBpf,KAAK4e,kBAAkBQ,MAAMqE,wBAExBzhB,GAGD,YAAAof,uBAAR,WAEE,GADiBphB,KAAK4e,kBAAkBQ,OACtBpf,KAAK2e,aAAa3c,OAApC,CAEM,+BAAE6e,EAAA,EAAAA,KAAMJ,EAAA,EAAAA,QAASjc,EAAA,EAAAA,MAEvB,IAAKic,EAAS,CACN,wBAAErB,EAAA,EAAAA,MAAOnZ,EAAA,EAAAA,UAAWyd,EAAA,EAAAA,YAAaC,EAAA,EAAAA,QAGvC,GACE3jB,KAAK+d,kBACJ/d,KAAK2e,aAAa8B,SACnBrC,YAAQpe,KAAK+d,gBAAgBqB,MAAOA,IACpChB,YAAQpe,KAAK+d,gBAAgB9X,UAAWA,GAExC,OAGEyd,IAAgBlf,EAClBkf,EAAY7C,GACH8C,GAAWnf,GACpBmf,EAAQnf,MAKN,YAAA6b,wBAAR,WACMrgB,KAAK4e,kBAAkB+D,eACzB3iB,KAAK4e,kBAAkB+D,aAAaiB,qBAC7B5jB,KAAK4e,kBAAkB+D,eA0C1B,YAAAd,sBAAR,WAEE,MAAO,CACL5b,UAFiBjG,KAAK4e,kBAAkBQ,MAElBnZ,UACtBoZ,QAASrf,KAAKmf,WACdK,UAAWxf,KAAKsf,aAChBK,YAAa3f,KAAKyf,eAClBK,aAAc9f,KAAK4f,gBACnBI,YAAahgB,KAAK+f,eAClBG,gBAAiBlgB,KAAKigB,qBAhd5B,CAAkD4D,ICZlD,YASE,WAAY,G,IACVhG,EAAA,EAAAA,QACAvY,EAAA,EAAAA,QACAtD,EAAA,EAAAA,OACA8hB,EAAA,EAAAA,UAJF,EAWE,YAAMjG,EAASvY,IAAQ,K,OAuBjB,EAAAye,YAAc,SACpBC,QAAA,IAAAA,MAGI,IAEJ,EAAKC,kBACL,IAAMC,EAAa,EAAKC,wBAExB,OAAO,EAAKC,OAAOJ,GAChB9hB,MAAK,SAACmiB,GAEL,OADA,EAAKC,oBAAoBD,EAAUH,GAC5BG,KAER3B,OAAM,SAACle,GAEN,GADA,EAAK+f,gBAAgB/f,EAAO0f,IACvB,EAAKlG,aAAa2F,QAAS,MAAMnf,MAtC1C,EAAKia,mBAAmBZ,EAAQ2G,SAAU,IAAa3e,UACvD,EAAK7D,OAASA,EACd,EAAK8hB,UAAYA,EACjB,EAAKW,qBAAuB,E,EArBtB,iBAwBD,YAAAtE,QAAP,SAAene,GAIb,OAHAhC,KAAK8d,WAAY,EACjB9d,KAAKye,mBAAmBze,KAAKge,aAAawG,SAAU,IAAa3e,UACjE7D,EAAOmD,OAASnF,KAAKse,gBAAgBnZ,OAC9B,CAACnF,KAAK+jB,YAAa/hB,IAGrB,YAAAkf,aAAP,WAEE,OADAlhB,KAAK8d,WAAY,EACV9d,KAAKqe,QAAQgD,KAAKrhB,OAGpB,YAAAwe,QAAP,aAwBQ,YAAA4F,OAAR,SACEJ,GAEM,wBACJQ,EAAA,EAAAA,SACAve,EAAA,EAAAA,UACAye,EAAA,EAAAA,mBACAC,EAAA,EAAAA,OACA,IAAArf,QAAA,kBACA,IAAAsf,2BAAA,IAAsB,GAAtB,EACA3C,EAAA,EAAAA,YAEI4C,EAAgB,OAAH,IAAG,CAAH,GAAQb,GAErBc,EAAkBtlB,OAAOa,OAC7B,GACA4F,EACA4e,EAAc5e,WAIhB,cAFO4e,EAAc5e,UAEdjG,KAAKse,gBAAgBnZ,OAAOif,OAAM,aACvCI,SAAQ,EACRE,mBAAkB,EAClBK,eACEF,EAAcE,gBAAkB/kB,KAAKge,aAAa+G,eACpDH,oBAAmB,EACnBD,OAAM,EACNrf,QAAS0f,EACT/C,YAAW,EACXhc,UAAW6e,GACRD,KAIC,YAAAZ,gBAAR,WACOjkB,KAAKgC,OAAOye,SAAYzgB,KAAKge,aAAaiH,eAC7CjlB,KAAKklB,aAAa,CAChBzE,SAAS,EACTjc,WAAOuF,EACP8W,UAAM9W,EACN6W,QAAQ,KAKN,YAAA0D,oBAAR,SACED,EACAH,GAEM,wBAAER,EAAA,EAAAA,YAAauB,EAAA,EAAAA,cAEbpE,EAAA,EAAAA,KAAM1P,EAAA,EAAAA,OACR3M,EACJ2M,GAAUA,EAAOxQ,OAAS,EACtB,IAAI,IAAY,CAAE4iB,cAAepS,SACjCpH,EAKF/J,KAAKmlB,qBAAqBjB,KAAgBe,GAC5CjlB,KAAKklB,aAAa,CAChBtE,QAAQ,EACRH,SAAS,EACTI,KAAI,EACJrc,MAAK,IAPPkf,GAAcA,EAAY7C,IAatB,YAAA0D,gBAAR,SAAwB/f,EAAoB0f,GAClC,IAAAP,EAAA,kBAAAA,QAEJ3jB,KAAKmlB,qBAAqBjB,IAC5BlkB,KAAKklB,aAAa,CAChBzE,SAAS,EACTjc,MAAK,EACLqc,UAAM9W,EACN6W,QAAQ,IAIR+C,GACFA,EAAQnf,IAIJ,YAAA2f,sBAAR,WACE,QAASnkB,KAAKykB,sBAGR,YAAAU,qBAAR,SAA6BjB,GAC3B,OAAOlkB,KAAKykB,uBAAyBP,GAG/B,YAAAgB,aAAR,SAAqBljB,IAEjBhC,KAAK8d,WACH9d,KAAK8iB,gBAAmB1E,YAAQpe,KAAK8iB,eAAgB9gB,KAEvDhC,KAAK8jB,UAAU9hB,GACfhC,KAAK8iB,eAAiB9gB,IAtK5B,CAGU6hB,ICXV,YAOE,WAAY,G,IACVhG,EAAA,EAAAA,QACAvY,EAAA,EAAAA,QACAwe,EAAA,EAAAA,UAHF,EASE,YAAMjG,EAASvY,IAAQ,K,OAXjB,EAAAsZ,kBAAmD,GAYzD,EAAKkF,UAAYA,EACjB,EAAKsB,WAAWvH,G,EAfV,iBAkBD,YAAAsC,QAAP,SAAene,GACb,IAA+B,IAA3BhC,KAAKge,aAAaoC,KAEpB,OADApgB,KAAKwe,UACE,CACLiC,SAAS,EACTjc,WAAOuF,EACP8W,UAAM9W,EACN9D,UAAWjG,KAAKge,aAAa/X,WAIjC,IAAIod,EAAgBrhB,EAChBhC,KAAKse,gBAAgBC,QACvB8E,EAAgBrjB,KAAKqlB,oBAGjB,IAAAC,EAAA,kBAAAA,kBAqBN,MApBiC,mBAAtBA,IACTA,IAAsBA,EAAkBtlB,KAAKge,gBAIvB,IAAtBsH,GACAtlB,KAAK+d,iBACLve,OAAOyJ,KAAKjJ,KAAK+d,iBAAiBpd,OAAS,IAC1CX,KAAK+d,gBAAgB4E,eAAiB3iB,KAAKge,aAAa2E,eACtDvE,YAAQpe,KAAK+d,gBAAgB9X,UAAWjG,KAAKge,aAAa/X,YAC3DjG,KAAK+d,gBAAgBqC,OAASpgB,KAAKge,aAAaoC,QAElDpgB,KAAKwe,UACL6E,EAAgBrjB,KAAKqlB,oBAGvBrlB,KAAKolB,WAAWplB,KAAKge,cACrBhe,KAAKulB,oBAELvlB,KAAK+d,gBAAkB/d,KAAKge,aAC5B,2BAAYqF,GAAa,CAAEpd,UAAWjG,KAAKge,aAAa/X,aAGnD,YAAAib,aAAP,WACElhB,KAAK8d,WAAY,GAGZ,YAAAU,QAAP,WACExe,KAAKwlB,yBACExlB,KAAK4e,kBAAkBQ,OAGxB,YAAAgG,WAAR,SAAmBvH,GACb7d,KAAK4e,kBAAkBQ,QAAoC,IAA3Bpf,KAAKge,aAAaoC,OACtDpgB,KAAK4e,kBAAkBQ,MAAQpf,KAAKse,gBAAgBnZ,OAAO0d,UAAU,CACnEzD,MAAOvB,EAAQ8E,aACf1c,UAAW4X,EAAQ5X,UACnBgc,YAAapE,EAAQoE,gBAIjB,YAAAsD,kBAAR,WACMvlB,KAAK4e,kBAAkB+D,eAC3B3iB,KAAK4e,kBAAkB+D,aAAe3iB,KAAK4e,kBAAkBQ,MAAOyD,UAClE,CACE/gB,KAAM9B,KAAKylB,kBAAkBpE,KAAKrhB,MAClCwE,MAAOxE,KAAK0lB,YAAYrE,KAAKrhB,MAC7B2lB,SAAU3lB,KAAK4lB,qBAAqBvE,KAAKrhB,UAKvC,YAAAqlB,iBAAR,WACE,MAAO,CACL5E,SAAS,EACTjc,WAAOuF,EACP8W,UAAM9W,IAIF,YAAAmb,aAAR,SAAqBljB,GACfhC,KAAK8d,WACP9d,KAAK8jB,UAAU9hB,IAIX,YAAAyjB,kBAAR,SAA0BzjB,GAChB,IAAA6jB,EAAA,kBAAAA,mBAER7lB,KAAKklB,aAAa,CAChBrE,KAAM7e,EAAO6e,KACbJ,SAAS,EACTjc,WAAOuF,IAGL8b,GACFA,EAAmB,CACjB1gB,OAAQnF,KAAKse,gBAAgBnZ,OAC7B2gB,iBAAkB9jB,KAKhB,YAAA0jB,YAAR,SAAoBlhB,GAClBxE,KAAKklB,aAAa,CAChB1gB,MAAK,EACLic,SAAS,KAIL,YAAAmF,qBAAR,WACU,IAAAG,EAAA,kBAAAA,uBACJA,GAAwBA,IAC5B/lB,KAAKwlB,mBAGC,YAAAA,gBAAR,WACMxlB,KAAK4e,kBAAkB+D,eACzB3iB,KAAK4e,kBAAkB+D,aAAaiB,qBAC7B5jB,KAAK4e,kBAAkB+D,eAzIpC,CAGUkB,G,SCJMmC,IACN,IAAA7gB,EAAA,8BAAAA,OAMR,OALA,iBAKOA,GCKT,wBAEU,KAAA8gB,cAAgB,IAAIxgB,IAMpB,KAAAygB,cAAgB,IAAIzgB,IAGrB,YAAA+c,sBAAP,SACE2D,EACAC,GAEApmB,KAAKqmB,gBAAgBD,GAAOD,WAAaA,GAIpC,YAAA9D,iBAAP,SACE+D,GAEA,OAAOpmB,KAAKqmB,gBAAgBD,GAAOD,YAG9B,YAAArE,gBAAP,SACEwE,EACAC,GAGA,OADavmB,KAAKqmB,gBAAgBC,EAActI,cACtCxN,KAWH+V,KAVLvmB,KAAKimB,cAActV,IACjB2V,EAActI,aACd,IAAIxc,SAAQ,SAAAC,GACVA,EAAQ6kB,EAAcxF,iBAKnB,OAKJ,YAAA0F,YAAP,WACE,OAAOxmB,KAAKimB,cAAcjT,KAAO,GAG5B,YAAAyT,wBAAP,sBACQC,EAA2B,GAejC,OAdA1mB,KAAKimB,cAAc7d,SAAQ,SAACue,EAASL,GAUnC,EAAKD,gBAAgBC,GAAe9V,MAAO,EAC3CkW,EAAStjB,KAAKujB,MAEhB3mB,KAAKimB,cAAc1S,QACZ/R,QAAQolB,IAAIF,IAGb,YAAAL,gBAAR,SACED,GAEQ,IAAAF,EAAA,KAAAA,cACA9G,EAAA,EAAAA,MAAOnZ,EAAA,EAAAA,UACT4gB,EAASX,EAAc/f,IAAIiZ,IAAU,IAAI3Z,IAC1CygB,EAAczV,IAAI2O,IAAQ8G,EAAcvV,IAAIyO,EAAOyH,GACxD,IAAMC,EAAkBje,KAAKC,UAAU7C,GACjCmN,EAAOyT,EAAO1gB,IAAI2gB,IAjFnB,CACLtW,MAAM,EACN2V,WAAY,MAiFZ,OADKU,EAAOpW,IAAIqW,IAAkBD,EAAOlW,IAAImW,EAAiB1T,GACvDA,GA7EX,I,cChBA,IAOI2T,EACAC,EARAriB,EAAUsiB,EAAOpT,QAAU,GAU/B,SAASqT,IACL,MAAM,IAAIjjB,MAAM,mCAEpB,SAASkjB,IACL,MAAM,IAAIljB,MAAM,qCAsBpB,SAASmjB,EAAWC,GAChB,GAAIN,IAAqBO,WAErB,OAAOA,WAAWD,EAAK,GAG3B,IAAKN,IAAqBG,IAAqBH,IAAqBO,WAEhE,OADAP,EAAmBO,WACZA,WAAWD,EAAK,GAE3B,IAEI,OAAON,EAAiBM,EAAK,GAC/B,MAAMtmB,GACJ,IAEI,OAAOgmB,EAAiBnmB,KAAK,KAAMymB,EAAK,GAC1C,MAAMtmB,GAEJ,OAAOgmB,EAAiBnmB,KAAKZ,KAAMqnB,EAAK,MAvCnD,WACG,IAEQN,EADsB,mBAAfO,WACYA,WAEAJ,EAEzB,MAAOnmB,GACLgmB,EAAmBG,EAEvB,IAEQF,EADwB,mBAAjBO,aACcA,aAEAJ,EAE3B,MAAOpmB,GACLimB,EAAqBG,GAjB5B,GAwED,IAEIK,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAa7mB,OACb8mB,EAAQD,EAAavO,OAAOwO,GAE5BE,GAAc,EAEdF,EAAM9mB,QACNknB,KAIR,SAASA,IACL,IAAIH,EAAJ,CAGA,IAAII,EAAUV,EAAWQ,GACzBF,GAAW,EAGX,IADA,IAAIjO,EAAMgO,EAAM9mB,OACV8Y,GAAK,CAGP,IAFA+N,EAAeC,EACfA,EAAQ,KACCE,EAAalO,GACd+N,GACAA,EAAaG,GAAYI,MAGjCJ,GAAc,EACdlO,EAAMgO,EAAM9mB,OAEhB6mB,EAAe,KACfE,GAAW,EAnEf,SAAyBM,GACrB,GAAIhB,IAAuBO,aAEvB,OAAOA,aAAaS,GAGxB,IAAKhB,IAAuBG,IAAwBH,IAAuBO,aAEvE,OADAP,EAAqBO,aACdA,aAAaS,GAExB,IAEWhB,EAAmBgB,GAC5B,MAAOjnB,GACL,IAEI,OAAOimB,EAAmBpmB,KAAK,KAAMonB,GACvC,MAAOjnB,GAGL,OAAOimB,EAAmBpmB,KAAKZ,KAAMgoB,KAgD7CC,CAAgBH,IAiBpB,SAASI,EAAKb,EAAKta,GACf/M,KAAKqnB,IAAMA,EACXrnB,KAAK+M,MAAQA,EAYjB,SAASob,KA5BTxjB,EAAQyjB,SAAW,SAAUf,GACzB,IAAI5e,EAAO,IAAI9I,MAAMe,UAAUC,OAAS,GACxC,GAAID,UAAUC,OAAS,EACnB,IAAK,IAAIH,EAAI,EAAGA,EAAIE,UAAUC,OAAQH,IAClCiI,EAAKjI,EAAI,GAAKE,UAAUF,GAGhCinB,EAAMrkB,KAAK,IAAI8kB,EAAKb,EAAK5e,IACJ,IAAjBgf,EAAM9mB,QAAiB+mB,GACvBN,EAAWS,IASnBK,EAAKhoB,UAAU6nB,IAAM,WACjB/nB,KAAKqnB,IAAIxmB,MAAM,KAAMb,KAAK+M,QAE9BpI,EAAQ0jB,MAAQ,UAChB1jB,EAAQ2jB,SAAU,EAClB3jB,EAAQD,IAAM,GACdC,EAAQ4jB,KAAO,GACf5jB,EAAQ6jB,QAAU,GAClB7jB,EAAQ8jB,SAAW,GAInB9jB,EAAQ+jB,GAAKP,EACbxjB,EAAQgkB,YAAcR,EACtBxjB,EAAQikB,KAAOT,EACfxjB,EAAQkkB,IAAMV,EACdxjB,EAAQmkB,eAAiBX,EACzBxjB,EAAQokB,mBAAqBZ,EAC7BxjB,EAAQqkB,KAAOb,EACfxjB,EAAQskB,gBAAkBd,EAC1BxjB,EAAQukB,oBAAsBf,EAE9BxjB,EAAQwkB,UAAY,SAAUplB,GAAQ,MAAO,IAE7CY,EAAQykB,QAAU,SAAUrlB,GACxB,MAAM,IAAIE,MAAM,qCAGpBU,EAAQ0kB,IAAM,WAAc,MAAO,KACnC1kB,EAAQ2kB,MAAQ,SAAU9b,GACtB,MAAM,IAAIvJ,MAAM,mCAEpBU,EAAQ4kB,MAAQ,WAAa,OAAO,I,uICpLxBC,E,8DAgDZ,SAAgBC,EACd/I,GAEA,OAAOA,EAAgB,GAnDzB,SAAY8I,GAMV,yBAMA,mCAMA,6BAMA,yBAOA,mBAKA,qBAKA,qBAzCF,CAAYA,MAAa,KCOzB,+B,+CAQA,OARmCE,iBAC1B,YAAC,KAAR,WACE,OAAO1pB,MAGF,YAAC,gBAAR,WACE,OAAOA,MAEX,EARA,CAAmC0pB,K,SCVnBC,EAAmB/nB,GACjC,OAAOjC,MAAM2S,QAAQ1Q,IAAUA,EAAMjB,OAAS,ECUhD,ICkBYipB,EDGZ,cAaE,WAAY,G,IAlCgBC,EACxBjmB,EAkCF2f,EAAA,EAAAA,cACAuG,EAAA,EAAAA,aACAC,EAAA,EAAAA,aACAC,EAAA,EAAAA,UAJF,EAWE,YAAMD,IAAa,K,OACnB,EAAKxG,cAAgBA,GAAiB,GACtC,EAAKuG,aAAeA,GAAgB,KAKlC,EAAKlmB,QAHFmmB,IAhDHnmB,EAAU,GAEV+lB,GAHwBE,EAkDY,GA/ChBtG,gBACtBsG,EAAItG,cAAcnb,SAAQ,SAAC6hB,GACzB,IAAMF,EAAeE,EACjBA,EAAarmB,QACb,2BACJA,GAAW,kBAAkBmmB,EAAY,QAIzCF,EAAIC,eACNlmB,GAAW,kBAAoBimB,EAAIC,aAAalmB,QAAU,MAI5DA,EAAUA,EAAQqW,QAAQ,MAAO,KAsC/B,EAAK+P,UAAYA,EAIhB,EAAatqB,UAAYwqB,EAAYhqB,U,EAE1C,OAxCiC,iBAwCjC,EAxCA,CAAiC+D,QCHjC,SAAY2lB,GACV,uBACA,yBACA,mBAHF,CAAYA,MAAS,KCiCd,IAQP,cAuBE,WAAY,G,IACVO,EAAA,EAAAA,aACAtM,EAAA,EAAAA,QACA,IAAAuM,uBAAA,IAAkB,GAAlB,EAHF,EASE,aAAM,SAACC,GACL,SAAKC,YAAYD,OAClB,KAlBK,EAAAE,UAAY,IAAI9W,IAChB,EAAA7M,cAAgB,IAAI6M,IAoB1B,EAAK+W,YAAa,EAGlB,EAAK3M,QAAUA,EACf,EAAK5X,UAAY4X,EAAQ5X,WAAc,GACvC,EAAKwkB,QAAUN,EAAaO,kBAC5B,EAAKN,gBAAkBA,EAEvB,IAAMO,EAAQ,YAAuB9M,EAAQuB,O,OAC7C,EAAKwL,UAAYD,GAASA,EAAM5mB,MAAQ4mB,EAAM5mB,KAAKnC,MAGnD,EAAKuoB,aAAeA,E,EAqjBxB,OAnmBU,iBAiDD,YAAAnoB,OAAP,sBACE,OAAO,IAAIR,SAAQ,SAACC,EAASC,GAC3B,IAAM2oB,EAA+C,CACnDvoB,KAAM,SAACE,GACLP,EAAQO,GAYR,EAAKuoB,UAAUM,OAAOR,GACjB,EAAKE,UAAUvX,MAClB,EAAKmX,aAAaW,YAAY,EAAKL,SAGrCnD,YAAW,WACT3E,EAAaiB,gBACZ,IAELpf,MAAO9C,GAEHihB,EAAe,EAAKE,UAAUwH,OAMjC,YAAAhH,cAAP,WACE,IAAMrhB,EAAShC,KAAKihB,mBAIpB,YAHoBlX,IAAhB/H,EAAO6e,OACT7e,EAAO6e,KAAO,IAET7e,GASF,YAAAif,iBAAP,WACE,GAAIjhB,KAAKwqB,WAAY,CACX,IAAAtH,EAAA,KAAAA,WACR,MAAO,CACLrC,MAAO7gB,KAAKgjB,WAAaE,GAAcA,EAAWrC,WAAQ,EAC1Drc,MAAOxE,KAAKgjB,UACZvC,SAAS,EACTC,cAAe8I,EAAchlB,OAI3B,IAEFxC,EAvHN+oB,EACAC,EAoHQ,gDAAEnK,EAAA,EAAAA,KAAMyC,EAAA,EAAAA,QACR2H,EAAkBjrB,KAAKmqB,aAAae,WAAW/kB,IAAInG,KAAKyqB,SAGtDxI,EAAA,aAAAA,YAEFkJ,EACY,iBAAhBlJ,GACgB,aAAhBA,EAEF,GAAIgJ,EAAiB,CACX,IAAAvK,EAAA,EAAAA,cAER,GAlIJqK,EAkIiBE,OAjIjB,KAAAD,EAiIkChrB,KAAK6d,QAAQuN,eAjI/CJ,EAAA,QACGD,IACHA,EAAWjB,cACC,SAAXkB,GAAqBrB,EAAgBoB,EAAWxH,gBA+H3C,MAAO,CACL1C,UAAM,EACNJ,SAAS,EACTC,cAAa,EACblc,MAAO,IAAI0lB,EAAY,CACrB3G,cAAe0H,EAAgB1H,cAC/BuG,aAAcmB,EAAgBnB,gBAUhCmB,EAAgBhlB,YAClBjG,KAAK6d,QAAQ5X,UAAS,2BACjBjG,KAAK6d,QAAQ5X,WACZglB,EAAgBhlB,WAEtBjG,KAAKiG,UAAYjG,KAAK6d,QAAQ5X,WAGhCjE,EAAS,CACP6e,KAAI,EACJJ,QAASgJ,EAAyB/I,GAClCA,cAAa,GAGXuK,EAAgB1H,eAA8C,QAA7BvjB,KAAK6d,QAAQuN,cAChDppB,EAAOmP,OAAS8Z,EAAgB1H,mBAG7B,CAOL,IAAM9C,EAAU0K,GACb7H,GAA2B,eAAhBrB,EAEdjgB,EAAS,CACP6e,KAAI,EACJJ,QAAO,EACPC,cAAeD,EAAU+I,EAAc/I,QAAU+I,EAAc7I,OAQnE,OAJK2C,GACHtjB,KAAKqrB,iBAAgB,2BAAMrpB,GAAM,CAAE4f,OAAO,KAG5C,2BAAY5f,GAAM,CAAEshB,QAAO,KAKtB,YAAAgI,0BAAP,SAAiCC,GACvB,WAAAC,mBACR,QACEC,GACAF,GACAE,EAAS/K,gBAAkB6K,EAAU7K,eACrC+K,EAAS7J,QAAU2J,EAAU3J,OAC7B,YAAQ6J,EAAS5K,KAAM0K,EAAU1K,QAM9B,YAAAsC,cAAP,WACE,OAAOnjB,KAAKkjB,YAGP,YAAAD,aAAP,WACE,OAAOjjB,KAAKgjB,WAGP,YAAAI,iBAAP,kBACSpjB,KAAKkjB,kBACLljB,KAAKwrB,0BACLxrB,KAAKgjB,UACZhjB,KAAKwqB,YAAa,GAGb,YAAA/G,sBAAP,WACE,IAAMyH,EAAalrB,KAAKmqB,aAAae,WAAW/kB,IAAInG,KAAKyqB,SACrDS,IACFA,EAAWpB,aAAe,KAC1BoB,EAAW3H,cAAgB,KAWxB,YAAAlE,QAAP,SAAepZ,GACP,IAAAgc,EAAA,aAAAA,YAEN,MAAoB,eAAhBA,EACKzgB,QAAQE,OAAO,aAQJ,aAAhBugB,GACgB,sBAAhBA,IACFA,EAAc,gBAGX,YAAQjiB,KAAKiG,UAAWA,KAE3BjG,KAAKiG,UAAS,2BACTjG,KAAKiG,WACLA,IAIF,YAAQjG,KAAK6d,QAAQ5X,UAAWjG,KAAKiG,aAExCjG,KAAK6d,QAAQ5X,UAAS,2BACjBjG,KAAK6d,QAAQ5X,WACbjG,KAAKiG,YAILjG,KAAKmqB,aAAauB,WACvB1rB,KAAKyqB,QAAO,2BACPzqB,KAAK6d,SAAO,CAAEoE,YAAW,IAC9B2H,EAAUvK,WAIP,YAAAG,UAAP,SACED,GADF,WAOI,6BAGF,IAAMoM,EAAkB,2BAClBpM,EAAiBH,MAAQG,EAAgB,uCACxCvf,KAAK6d,SACL0B,GAAgB,CACnBtZ,UAAW,OAAF,IAAE,CAAF,eACJjG,KAAKiG,WACLsZ,EAAiBtZ,cAEvB,CACDgc,YAAa,iBAGT2J,EAAM5rB,KAAKmqB,aAAaO,kBAE9B,OAAO1qB,KAAKmqB,aACTuB,WACCE,EACAD,EACA/B,EAAUiC,OACV7rB,KAAKyqB,SAENvoB,MACC,SAAA4pB,GAQE,OAPA,EAAKnM,aAAY,SAACmD,GAChB,OAAAvD,EAAiBI,YAAYmD,EAAgB,CAC3CgJ,gBAAiBA,EAAgBjL,KACjC5a,UAAW0lB,EAAgB1lB,eAG/B,EAAKkkB,aAAa4B,UAAUH,GACrBE,KAET,SAAAtnB,GAEE,MADA,EAAK2lB,aAAa4B,UAAUH,GACtBpnB,MAQP,YAAA0b,gBAAP,SAIErC,GAJF,WAUQ8E,EAAe3iB,KAAKmqB,aACvB6B,yBAAyB,CACxB5M,MAAOvB,EAAQ7X,SACfC,UAAW4X,EAAQ5X,YAEpB4c,UAAU,CACT/gB,KAAM,SAACgkB,GACG,IAAAnG,EAAA,EAAAA,YACJA,GACF,EAAKA,aACH,SAACsM,EAAU,G,IAAEhmB,EAAA,EAAAA,UACX,OAAA0Z,EAAYsM,EAAU,CACpBnG,iBAAgB,EAChB7f,UAAS,QAKnBzB,MAAO,SAACqlB,GACFhM,EAAQ8F,SACV9F,EAAQ8F,QAAQkG,MASxB,OAFA7pB,KAAK4G,cAAc8M,IAAIiP,GAEhB,WACD,EAAK/b,cAAcikB,OAAOlI,IAC5BA,EAAaiB,gBAOZ,YAAA3F,WAAP,SACEiO,GAEQ,mBAAAjK,YACRjiB,KAAK6d,QAAU,2BACV7d,KAAK6d,SACLqO,GAGDA,EAAKrM,aACP7f,KAAK8f,aAAaoM,EAAKrM,cACQ,IAAtBqM,EAAKrM,cACd7f,KAAKggB,cAGC,IAAAiC,EAAA,EAAAA,YAER,OAAOjiB,KAAKmsB,aACVnsB,KAAK6d,QAAQ5X,UAGbmmB,IAAmBnK,IACE,eAAnBmK,GACmB,YAAnBA,GACgB,iBAAhBnK,GAEFiK,EAAKG,eA+BF,YAAAF,aAAP,SACElmB,EACAqmB,EACAD,GAOA,YARA,IAAAC,OAAA,QACA,IAAAD,OAAA,GAGArsB,KAAKwqB,YAAa,EAElBvkB,EAAYA,GAAajG,KAAKiG,WAEzBqmB,GAAY,YAAQrmB,EAAWjG,KAAKiG,WAIhCjG,KAAKuqB,UAAUvX,MAAQqZ,EAC1BrsB,KAAKgC,SACLR,QAAQC,WAGdzB,KAAKiG,UAAYjG,KAAK6d,QAAQ5X,UAAYA,EAGrCjG,KAAKuqB,UAAUvX,KAKbhT,KAAKmqB,aAAauB,WACvB1rB,KAAKyqB,QACLzqB,KAAK6d,SANErc,QAAQC,YAUZ,YAAAke,YAAP,SACED,GAKQ,IAAAyK,EAAA,KAAAA,aACF,6CACJrH,EAAA,EAAAA,eACA7c,EAAA,EAAAA,UACAD,EAAA,EAAAA,SAKIulB,EAAY,aAAsB,WACtC,OAAA7L,EAAMoD,EAAgB,CAAE7c,UAAS,OAG/BslB,IACFpB,EAAaoC,UAAUC,sBACrBxmB,EACAC,EACAslB,GAEFpB,EAAasC,qBAIV,YAAAzM,YAAP,WACEhgB,KAAKmqB,aAAauC,iBAAiB1sB,KAAKyqB,SACxCzqB,KAAK6d,QAAQgC,kBAAe9V,GAGvB,YAAA+V,aAAP,SAAoBD,GAClB8M,EAA0B3sB,MAC1BA,KAAK6d,QAAQgC,aAAeA,EAC5B7f,KAAKmqB,aAAayC,kBAAkB5sB,KAAK6d,QAAS7d,KAAKyqB,UAGjD,YAAAY,iBAAR,SAAyBE,GACvB,IAAMzI,EAAiB9iB,KAAKkjB,WAK5B,OAJAljB,KAAKkjB,WAAaqI,EAClBvrB,KAAKwrB,mBAAqBxrB,KAAKmqB,aAAa0C,uBACxCtB,EACA,YAAUA,GACPzI,GAGD,YAAAwH,YAAR,SAAoBD,GAApB,WAGE,IACE,IAAIyC,EAAezC,EAAiB0C,cAAcC,UAC9CF,IAAgBA,EAAYtoB,QAC9BsoB,EAAYtoB,MAAQyoB,GAEtB,UAEF,IAAMC,GAASltB,KAAKuqB,UAAUvX,KAY9B,OAXAhT,KAAKuqB,UAAU7W,IAAI2W,GAGfA,EAASvoB,MAAQ9B,KAAKkjB,YAAYmH,EAASvoB,KAAK9B,KAAKkjB,YACrDmH,EAAS7lB,OAASxE,KAAKgjB,WAAWqH,EAAS7lB,MAAMxE,KAAKgjB,WAGtDkK,GACFltB,KAAKmtB,aAGA,WACD,EAAK5C,UAAUM,OAAOR,KAAc,EAAKE,UAAUvX,MACrD,EAAKoa,kBAKH,YAAAD,WAAR,sBACUhD,EAAF,KAAEA,aAAcM,EAAhB,KAAgBA,QAElBzqB,KAAKoqB,iBACPD,EAAakD,mBAA0B5C,EAASzqB,MAG9CA,KAAK6d,QAAQgC,eACf8M,EAA0B3sB,MAC1BmqB,EAAayC,kBAAkB5sB,KAAK6d,QAAS4M,IAG/C,IAAM9G,EAAU,SAACnf,GAGf,EAAK6mB,iBAAgB,2BAChB,EAAKnI,YAAU,CAClB/R,OAAQ3M,EAAM+e,cACd7C,cAAe8I,EAAchlB,MAC7Bic,SAAS,KAEX6M,EAAuB,EAAK/C,UAAW,QAAS,EAAKvH,UAAYxe,IAGnE2lB,EAAaoD,aAAoB9C,EAASzqB,KAAK6d,QAAS,CACtD/b,KAAM,SAACE,GACL,GAAI,EAAKghB,WAAa,EAAKsI,0BAA0BtpB,GAAS,CAC5D,IAAM,EAAiB,EAAKqpB,iBAAiBrpB,GACvC,YAAE,IAAAod,MAAOnZ,EAAA,EAAAA,UAAW,IAAAgc,YAQtBkI,EAAaqD,UAAU,GAAOviB,iBAChCkf,EAAasD,gBAAgBC,qBAC3B,EACAznB,GACA/D,MAAK,SAAC+D,GACN,IAAM0nB,EAAoB,EAAK1nB,UAC/B,EAAKA,UAAY,EAAK4X,QAAQ5X,UAAYA,GAEvCjE,EAAOye,SACR,GACgB,eAAhB,GACA0J,EAAaqD,UAAU,GAAOI,cAC7B,YAAQD,EAAmB1nB,GAE5B,EAAKoZ,UAELiO,EAAuB,EAAK/C,UAAW,OAAQvoB,MAInDsrB,EAAuB,EAAK/C,UAAW,OAAQvoB,KAIrDwC,MAAOmf,IACNjB,MAAMiB,IAGH,YAAAyJ,cAAR,WACU,IAAAjD,EAAA,KAAAA,aAERnqB,KAAKwqB,YAAa,EAClBL,EAAauC,iBAAiB1sB,KAAKyqB,SAGnCzqB,KAAK4G,cAAcwB,SAAQ,SAAAylB,GAAO,OAAAA,EAAIjK,iBACtC5jB,KAAK4G,cAAc2M,QAEnB4W,EAAa2D,sBAAsB9tB,KAAKyqB,SACxCN,EAAa4B,UAAU/rB,KAAKyqB,SAE5BzqB,KAAKuqB,UAAUhX,SAEnB,EAtmBA,CAGUI,GAqmBV,SAASsZ,EAAyCzoB,IAIlD,SAAS8oB,EACP/C,EACAlmB,EACAuK,GAKA,IAAMmf,EAAqC,GAC3CxD,EAAUniB,SAAQ,SAAA4Y,GAAO,OAAAA,EAAI3c,IAAW0pB,EAAoB3qB,KAAK4d,MACjE+M,EAAoB3lB,SAAQ,SAAA4Y,GAAO,OAACA,EAAY3c,GAAQuK,MAG1D,SAAS+d,EACP/J,GAEQ,IAAAX,EAAA,UAAAA,YACR,mDCjsBF,8BACU,KAAA+L,MAAsD,GA0ChE,OAxCS,YAAAC,SAAP,WACE,OAAOjuB,KAAKguB,OAGP,YAAA7nB,IAAP,SAAW+d,GACT,OAAOlkB,KAAKguB,MAAM9J,IAGb,YAAAgK,aAAP,SACEhK,EACAM,EACAve,GAEAjG,KAAKguB,MAAM9J,GAAc,CACvBM,SAAQ,EACRve,UAAWA,GAAa,GACxBwa,SAAS,EACTjc,MAAO,OAIJ,YAAA2pB,kBAAP,SAAyBjK,EAAoB1f,GAC3C,IAAMggB,EAAWxkB,KAAKguB,MAAM9J,GACxBM,IACFA,EAAS/D,SAAU,EACnB+D,EAAShgB,MAAQA,IAId,YAAA4pB,mBAAP,SAA0BlK,GACxB,IAAMM,EAAWxkB,KAAKguB,MAAM9J,GACxBM,IACFA,EAAS/D,SAAU,EACnB+D,EAAShgB,MAAQ,OAId,YAAA6pB,MAAP,WACEruB,KAAKguB,MAAQ,IAEjB,EA3CA,GCcA,0BACU,KAAAA,MAAgD,G,OAEjD,YAAAC,SAAP,WACE,OAAOjuB,KAAKguB,OAGP,YAAA7nB,IAAP,SAAWskB,GACT,OAAOzqB,KAAKguB,MAAMvD,IAGb,YAAA6D,UAAP,SAAiBlP,GAUf,IAAMmP,EAAgBvuB,KAAKguB,MAAM5O,EAAMqL,SAMpC,aAAA8D,GACDA,EAAcvoB,WAAaoZ,EAAMpZ,UACjC,YAAQuoB,EAAcvoB,SAAUoZ,EAAMpZ,UACtC,IAMF,IAeE0a,EAdA,KACA,OACA,0BAGA,G,8BAEE,wBAAkC,EAAAza,a,8EAiBW,U,IAE/Csd,EAAgB,G,qBAMd,EAAa,iBAEf,uBACA,oBACA,sBACA,oBACA,kBACA,cAAe,E,gBAWf,qBAGqC,iBAArC,uBACE,aAAa,uB,0GAWZ,KAAK,OAAU,gBAEpBvjB,KAAKguB,MAAMvD,GAAS,kBACpBzqB,KAAKguB,MAAMvD,GAAS,cAAgB,wBAKpC,KACE,MAAO,0BACPzqB,KAAA,+BAE+B,iBAA/B,G,kGAWG,KAAK,OAAU,gBAMpB,KAAI,MAAO,gBAAwB,EACjCA,KAAA,yBAA8C,M,yDAMhC,8C,IACd+qB,EAAU,YAAa,KAAQ,SAC/BA,IACA,oB,EAC0B,kBAAG,K,+BAOjC,yC,WAEA,I,EACS,UAAU,MAAK,Y,IACpB,O,iBACgB,OAAC,SAAQ,Y,uEA1J/B,GCwDA,iBAME,WAAY,G,IACVvlB,EAAA,EAAAA,MACAL,EAAA,EAAAA,OACAqpB,EAAA,EAAAA,UACAC,EAAA,EAAAA,gBAEAzuB,KAAKwF,MAAQA,EAETL,IACFnF,KAAKmF,OAASA,GAGZqpB,GACFxuB,KAAK0uB,aAAaF,GAGhBC,GACFzuB,KAAK2uB,mBAAmBF,GAkX9B,OA9WS,YAAAC,aAAP,SAAoBF,GAApB,WACExuB,KAAKwuB,UAAYxuB,KAAKwuB,WAAa,GAC/B7uB,MAAM2S,QAAQkc,GAChBA,EAAUpmB,SAAQ,SAAAwmB,GAChB,EAAKJ,UAAY,YAAU,EAAKA,UAAWI,MAG7C5uB,KAAKwuB,UAAY,YAAUxuB,KAAKwuB,UAAWA,IAIxC,YAAAK,aAAP,SAAoBL,GAClBxuB,KAAKwuB,UAAY,GACjBxuB,KAAK0uB,aAAaF,IAGb,YAAAM,aAAP,WACE,OAAO9uB,KAAKwuB,WAAa,IAOd,YAAAO,aAAb,SAAiC,G,IAC/B/oB,EAAA,EAAAA,SACAgpB,EAAA,EAAAA,aACA1pB,EAAA,EAAAA,QACAW,EAAA,EAAAA,UACA,IAAAgpB,8BAAA,IAAyB,GAAzB,E,uFAQA,OAAIjpB,EACF,GAAOhG,KAAKkvB,gBACVlpB,EACAgpB,EAAanO,KACbvb,EACAW,EACAjG,KAAKyuB,gBACLQ,GACA/sB,MAAK,SAAAitB,GAAe,kCACjBH,GAAY,CACfnO,KAAMsO,EAAYntB,aAItB,GAAOgtB,UAGF,YAAAL,mBAAP,SAA0BF,GACxBzuB,KAAKyuB,gBAAkBA,GAGlB,YAAAW,mBAAP,WACE,OAAOpvB,KAAKyuB,iBAKP,YAAAY,YAAP,SAAmBrpB,GACjB,OAAI,YAAc,CAAC,UAAWA,IACxBhG,KAAKwuB,UACAxoB,EASJ,MAIF,YAAA4nB,YAAP,SAAmB5nB,GACjB,OAAOhG,KAAKwuB,UAAY,YAA6BxoB,GAAYA,GAG5D,YAAAspB,eAAP,SAAsBhqB,QAAA,IAAAA,MAAA,IACZ,IAAAE,EAAA,KAAAA,MAkBR,OAhBmB,OAAH,IAAG,CAAH,eACXF,GAAO,CACVE,MAAK,EAEL+pB,YAAa,SAAChoB,GACZ,GAAK/B,EAAckJ,OACjB,OAAQlJ,EAAckJ,OAAO8gB,iBAAiBjoB,GAE9C,sBAcK,YAAAmmB,qBAAb,SACE1nB,EACAC,EACAX,G,YADA,IAAAW,MAAA,SACA,IAAAX,MAAA,I,gFAEA,OAAIU,EACF,GAAOhG,KAAKkvB,gBACVlpB,EACAhG,KAAKyvB,wBAAwBzpB,EAAUC,IAAc,GACrDjG,KAAKsvB,eAAehqB,GACpBW,GACA/D,MAAK,SAAA2e,GAAQ,kCACV5a,GACA4a,EAAK6O,uBAIZ,kBACKzpB,WAIA,YAAA0pB,qBAAP,SAA4B3pB,GAC1B,IAAI4pB,GAAiB,EAkBrB,OAjBA,gBAAM5pB,EAAU,CACd6E,UAAW,CACTmD,MAAK,SAAClD,GACJ,GAAwB,WAApBA,EAAK/G,KAAKnC,OAAsBkJ,EAAKpK,YACvCkvB,EAAiB9kB,EAAKpK,UAAUsK,MAC9B,SAAAqD,GACE,MAAmB,WAAnBA,EAAItK,KAAKnC,OACU,iBAAnByM,EAAIzM,MAAM4E,OACU,IAApB6H,EAAIzM,MAAMA,UAGZ,OAAO,YAMVguB,GAID,YAAAH,wBAAR,SACEzpB,EACAC,GAEA,OAAOjG,KAAKwF,MAAMqqB,KAAK,CACrBzQ,MAAO,YAA2BpZ,GAClCC,UAAS,EACT6pB,mBAAmB,EACnBC,YAAY,IACX/tB,QAGS,YAAAktB,gBAAd,SACElpB,EACAgqB,EACA1qB,EACAW,EACAwoB,EACAQ,G,YAHA,IAAA3pB,MAAA,SACA,IAAAW,MAAA,SACA,IAAAwoB,MAAA,WAAyC,gBACzC,IAAAQ,OAAA,G,0GC/QkCxT,ED2SlC,OA1BMwU,EAAiB,YAAkBjqB,GACnCI,EAAY,YAAuBJ,GACnCkqB,EAAc,YAAkB9pB,GAEhC+pB,EAAuBF,EAC1BvpB,UAEG0pB,EAAuBD,GCxRK1U,EDyRR0U,GCxRjBE,OAAO,GAAGC,cAAgB7U,EAAI/K,MAAM,GDyRzC,QAEIlL,GAAF,EAAoBxF,MAAb,MAAEmF,EAAM,SACforB,EAA2B,CAC/BL,YAAW,EACX5qB,QAAS,OAAF,IAAE,CAAF,eACFA,GAAO,CACVE,MAAK,EACLL,OAAM,IAERc,UAAS,EACTwoB,gBAAe,EACf2B,qBAAoB,EACpBV,kBAAmB,GACnBT,uBAAsB,GAGxB,GAAOjvB,KAAKwwB,oBACVP,EAAe3kB,aACf0kB,EACAO,GACAruB,MAAK,SAAAF,GAAU,MAAC,CAChBA,OAAM,EACN0tB,kBAAmBa,EAAYb,8BAIrB,YAAAc,oBAAd,SACEllB,EACA0kB,EACAO,G,4GA+CA,OA7CQL,EAAoCK,EAAzB,YAAEjrB,EAAuBirB,EAAhB,QAAEtqB,EAAcsqB,EAAL,UACjCE,EAA0B,CAACT,GAE3B7P,EAAU,SAAO7W,GAAwB,+C,6CAC7C,OAAK,YAAcA,EAAWrD,GAK1B,YAAQqD,GACV,GAAOtJ,KAAK0wB,aAAapnB,EAAW0mB,EAAWO,GAAaruB,MAC1D,SAAAyuB,G,WAC6B,IAAhBA,GACTF,EAAertB,OAAK,MACjB,YAAuBkG,IAAaqnB,EAC7B,SAQd,YAAiBrnB,GACnBiD,EAAWjD,GAGXiD,EAAW2jB,EAAY5mB,EAAUvF,KAAKnC,OAClB,cAAoC,IAGtD2K,GAAYA,EAASqkB,gBACjBA,EAAgBrkB,EAASqkB,cAAc7sB,KAAKnC,MAC9C2uB,EAAY9B,gBAAgBuB,EAAWY,EAAetrB,IACxD,GAAOtF,KAAKwwB,oBACVjkB,EAASjB,aACT0kB,EACAO,GACAruB,MAAK,SAAA2uB,GACLJ,EAAertB,KAAKytB,O,KAjCxB,WAuCJ,GAAOrvB,QAAQolB,IAAItb,EAAaC,WAAWjE,IAAI6Y,IAAUje,MAAK,WAC5D,OAAO,YAAeuuB,cAIZ,YAAAC,aAAd,SACEzoB,EACA+nB,EACAO,G,oHAiCA,OA/BQtqB,EAAcsqB,EAAL,UACX/nB,EAAYP,EAAMlE,KAAKnC,MACvBkvB,EAAmB,YAAuB7oB,GAC1C8oB,EAAYvoB,IAAcsoB,EAC1BE,EAAgBhB,EAAUc,IAAqBd,EAAUxnB,GAC3DyoB,EAAgBzvB,QAAQC,QAAQuvB,GAOjCT,EAAYtB,yBACbjvB,KAAK2vB,qBAAqB1nB,KAEpBipB,EACJlB,EAAUmB,YAAcZ,EAAYH,sBAChCgB,EAAcpxB,KAAKwuB,WAAaxuB,KAAKwuB,UAAU0C,MAE7CzvB,EAAU2vB,EAAYL,EAAYvoB,EAAYsoB,MAElDG,EAAgBzvB,QAAQC,QAAQA,EAC9BuuB,EACA,YAAyB/nB,EAAOhC,GAChCsqB,EAAYjrB,QACZ,CAAE2C,MAAK,EAAEioB,YAAaK,EAAYL,iBAM1C,GAAOe,EAAc/uB,MAAK,SAACF,GAgBzB,YAhByB,IAAAA,MAAA,GAGrBiG,EAAME,YACRF,EAAME,WAAWC,SAAQ,SAAAC,GACM,WAAzBA,EAAUtE,KAAKnC,OAAsByG,EAAU3H,WACjD2H,EAAU3H,UAAU0H,SAAQ,SAAAiG,GACH,OAAnBA,EAAItK,KAAKnC,OAAqC,gBAAnByM,EAAIzM,MAAM4E,OACvC+pB,EAAYb,kBAAkBrhB,EAAIzM,MAAMA,OAASI,SAQtDiG,EAAMqD,aAMG,MAAVtJ,EAEKA,EAGLrC,MAAM2S,QAAQtQ,GACT,EAAKqvB,wBAAwBppB,EAAOjG,EAAQuuB,GAIjDtoB,EAAMqD,aACD,EAAKklB,oBACVvoB,EAAMqD,aACNtJ,EACAuuB,QAJJ,EAfSvuB,aAyBL,YAAAqvB,wBAAR,SACEppB,EACAjG,EACAuuB,GAHF,WAKE,OAAO/uB,QAAQolB,IACb5kB,EAAOsF,KAAI,SAAAgqB,GACT,OAAa,OAATA,EACK,KAIL3xB,MAAM2S,QAAQgf,GACT,EAAKD,wBAAwBppB,EAAOqpB,EAAMf,GAI/CtoB,EAAMqD,aACD,EAAKklB,oBAAoBvoB,EAAMqD,aAAcgmB,EAAMf,QAD5D,OAMR,EAzYA,G,SEpEgBgB,EAAaC,GAC3B,IAAMjH,EAAY,IAAI9W,IAClBoa,EAA2B,KAC/B,OAAO,IAAIla,GAAc,SAAA0W,GAavB,OAZAE,EAAU7W,IAAI2W,GACdwD,EAAMA,GAAO2D,EAAM3O,UAAU,CAC3B/gB,KAAI,SAACF,GACH2oB,EAAUniB,SAAQ,SAAA4Y,GAAO,OAAAA,EAAIlf,MAAQkf,EAAIlf,KAAKF,OAEhD4C,MAAK,SAACA,GACJ+lB,EAAUniB,SAAQ,SAAA4Y,GAAO,OAAAA,EAAIxc,OAASwc,EAAIxc,MAAMA,OAElDmhB,SAAQ,WACN4E,EAAUniB,SAAQ,SAAA4Y,GAAO,OAAAA,EAAI2E,UAAY3E,EAAI2E,iBAG1C,WACD4E,EAAUM,OAAOR,KAAcE,EAAUvX,MAAQ6a,IACnDA,EAAIjK,cACJiK,EAAM,UCkBN,IAAAhuB,EAAA,iBAAAA,eAgBR,aA6BE,WAAY,G,IACV4xB,EAAA,EAAAA,KACA,IAAAC,0BAAA,IAAqB,GAArB,EACA1D,EAAA,EAAAA,MACA,IAAA2D,mBAAA,IAAc,EAAd,eACA,IAAAC,eAAA,IAAU,GAAV,EACA,IAAAC,uBAAA,IAAkB,EAAlB,KACAC,EAAA,EAAAA,WACAjF,EAAA,EAAAA,uBAnCK,KAAAkF,cAA+B,IAAIC,EACnC,KAAA9G,WAAyB,IAAI+G,EAK5B,KAAAJ,gBAA0C,GAQ1C,KAAAK,UAAY,EAIZ,KAAAzrB,QAAkC,IAAIhB,IAOtC,KAAA0sB,oBAAsB,IAAI1sB,IAujB1B,KAAA2sB,eAAiB,IAAK,IAAgBniB,QAAUxK,KAkchD,KAAA4sB,wBAA0B,IAAI5sB,IAgP9B,KAAA6sB,qBAAuB,IAAI7sB,IAptCjCzF,KAAKyxB,KAAOA,EACZzxB,KAAK0xB,mBAAqBA,EAC1B1xB,KAAKusB,UAAYyB,EACjBhuB,KAAK2xB,YAAcA,EACnB3xB,KAAK6xB,gBAAkBA,EACvB7xB,KAAK8xB,WAAaA,GAAc,IAAIS,EAAW,CAAE/sB,MAAOwoB,EAAMwE,aAC9DxyB,KAAK4xB,QAAUA,EACf5xB,KAAK6sB,yBAA2BA,EA+wCpC,OAxwCS,YAAA4F,KAAP,sBACEzyB,KAAKyG,QAAQ2B,SAAQ,SAACsqB,EAAOjI,GAC3B,EAAKkI,qBAAqBlI,MAG5BzqB,KAAKmyB,oBAAoB/pB,SAAQ,SAAA1G,GAC/BA,EACE,gBAKO,YAAA0iB,OAAb,SAAuB,G,IACrBI,EAAA,EAAAA,SACAve,EAAA,EAAAA,UACAye,EAAA,EAAAA,mBACA,IAAAkO,cACA,IAAA7N,sBAAA,IAAiB,EAAjB,KACA,IAAAH,2BAAA,IAAsB,GAAtB,EACA,IAAAD,OACA,IAAAyG,mBAAA,IAAc,EAAd,SACAnJ,EAAA,EAAAA,YACA,IAAA3c,eAAA,IAAU,EAAV,K,sIAIE,iBAI2B,mCAIvB4e,EAAalkB,KAAK0qB,kBACxBlG,EAAWxkB,KAAKwtB,UAAUhJ,GAAUxe,SAEpChG,KAAK6yB,SAAS3O,GAAY,WAAM,MAAC,CAAEle,SAAUwe,MAE7Cve,EAAYjG,KAAK8yB,aAAatO,EAAUve,GAEpCjG,KAAKwtB,UAAUhJ,GAAUvZ,iBACf,GAAMjL,KAAK8xB,WAAWpE,qBAAqBlJ,EAAUve,EAAWX,IAD1E,M,OACFW,EAAY,S,iBAgDd,OA5CM8sB,EAEF,WACF,IAAMC,EAA+C,GAmBrD,OAjBIC,GACF,EAAKxsB,QAAQ2B,SAAQ,SAAC,EAAqBqiB,G,IAAnByI,EAAA,EAAAA,gBACtB,GAAIA,EAAiB,CACX,IAAAtI,EAAA,EAAAA,UAENA,GACA/qB,EAAee,KAAKqyB,EAAqBrI,KAEzCoI,EAAIvI,GAAW,CACb0I,QAASF,EAAoBrI,GAC7BxL,MAAO,EAAK8L,WAAW/kB,IAAIskB,SAO9BuI,GAGThzB,KAAK+xB,cAAc7D,aACjBhK,EACAM,EACAve,GAGFjG,KAAKusB,UAAU6G,iBAAiB,CAC9BlP,WAAU,EACVle,SAAUwe,EACVve,UAAS,EACT2sB,cAAeG,IACfpO,OAAQ0O,EACR3O,mBAAkB,IAGpB1kB,KAAKysB,mBAEC6G,EAAOtzB,KAEb,GAAO,IAAIwB,SAAQ,SAACC,EAASC,GAC3B,IAAI6xB,EACA/uB,EAEJ8uB,EAAKE,sBACHhP,EAAQ,2BAEHlf,GAAO,CACVof,mBAAkB,IAEpBze,GACA,GACA4c,UAAU,CACV/gB,KAAA,SAAKE,GACC,YAAsBA,IAA2B,SAAhBopB,EACnC5mB,EAAQ,IAAI0lB,EAAY,CACtB3G,cAAevhB,EAAOmP,UAK1BmiB,EAAKvB,cAAc3D,mBAAmBlK,GAElB,aAAhBjC,GACFqR,EAAK/G,UAAU6B,mBAAmB,CAChClK,WAAU,EACVliB,OAAM,EACNgE,SAAUwe,EACVve,UAAS,EACT2sB,cAAeG,IACfpO,OAAQ0O,IAIZE,EAAcvxB,IAGhBwC,MAAA,SAAMqlB,GACJyJ,EAAKvB,cAAc5D,kBAAkBjK,EAAY2F,GACjDyJ,EAAK/G,UAAUkH,qBAAqB,CAClCvP,WAAU,EACVQ,mBAAkB,IAEpB4O,EAAK7G,mBACL6G,EAAKT,SAAS3O,GAAY,WAAM,MAAC,CAAEle,SAAU,SAC7CtE,EACE,IAAIwoB,EAAY,CACdJ,aAAcD,MAKpBlE,SAAA,WAYE,GAXInhB,GACF8uB,EAAKvB,cAAc5D,kBAAkBjK,EAAY1f,GAGnD8uB,EAAK/G,UAAUkH,qBAAqB,CAClCvP,WAAU,EACVQ,mBAAkB,IAGpB4O,EAAK7G,mBAEDjoB,EACF9C,EAAO8C,OADT,CAO8B,mBAAnBugB,IACTA,EAAiBA,EAAewO,IAGlC,IAAMG,EAEA,GAEF/J,EAAgB5E,IAClBA,EAAe3c,SAAQ,SAAAurB,GACrB,GAA4B,iBAAjBA,EACTL,EAAK7sB,QAAQ2B,SAAQ,SAAC,G,IAAE8qB,EAAA,EAAAA,gBAEpBA,GACAA,EAAgBtI,YAAc+I,GAE9BD,EAAqBtwB,KAAK8vB,EAAgB7T,kBAGzC,CACL,IAAMuU,EAA6B,CACjCxU,MAAOuU,EAAavU,MACpBnZ,UAAW0tB,EAAa1tB,UACxBgc,YAAa,gBAGX0R,EAAaruB,UACfsuB,EAAatuB,QAAUquB,EAAaruB,SAGtCouB,EAAqBtwB,KAAKkwB,EAAKlU,MAAMwU,QAK3CpyB,QAAQolB,IACNhC,EAAsB8O,EAAuB,IAC7CxxB,MAAK,WACLoxB,EAAKT,SAAS3O,GAAY,WAAM,MAAC,CAAEle,SAAU,SAG3B,WAAhBolB,GACAmI,GACA,YAAsBA,WAEfA,EAAYpiB,OAGrB1P,EAAQ8xB,sBAOL,YAAA7H,WAAb,SACEjB,EACA5M,EACAgW,EAIAC,G,oKAGE,EAGEjW,EAHa,SAAfqE,OAAQ,IAAG,OAAI,EACf,EAEErE,EAFyB,YAA3BoE,OAAW,IAAG,gBAAa,EAC3B,EACEpE,EADU,QAAZvY,OAAO,IAAG,KAAE,EAGR8Z,EAAQpf,KAAKwtB,UAAU3P,EAAQuB,OAAOpZ,SAExCC,EAAYjG,KAAK8yB,aAAa1T,EAAOvB,EAAQ5X,WAE7CjG,KAAKwtB,UAAUpO,GAAOnU,iBACZ,GAAMjL,KAAK8xB,WAAWpE,qBAAqBtO,EAAOnZ,EAAWX,IADvE,M,OACFW,EAAY,S,iBA6Dd,GA1DA4X,EAAU,OAAH,IAAG,CAAH,eAAQA,GAAO,CAAE5X,UAAS,IAK7B8tB,EAFEC,EACY,iBAAhB/R,GAAkD,aAAhBA,EAK/B+R,IACG,EAAuBh0B,KAAKusB,UAAUiG,WAAW3C,KAAK,CAC1DzQ,MAAK,EACLnZ,UAAS,EACT6pB,mBAAmB,EACnBC,YAAY,IAJNpK,EAAQ,WAAE3jB,EAAM,SAQxB+xB,GAAepO,GAA4B,sBAAhB1D,EAC3BsR,EAAcvxB,GAGZiyB,EACFF,GAA+B,eAAhB9R,GAAgD,YAAhBA,EAG7C,YAAc,CAAC,QAAS7C,KAAQ6U,GAAc,GAE5CC,EAAYl0B,KAAKkyB,YAGjBiC,EAAyB,aAAhBlS,EACXjiB,KAAKo0B,iBAAiB3J,EAASrL,EAAOvB,QACtC9T,EAGJ/J,KAAK6yB,SAASpI,GAAS,WAAM,MAAC,CAC5BzkB,SAAUoZ,EACViV,cAAeH,EACfI,aAAa,EACbH,OAAM,MAGRn0B,KAAKu0B,WAAWT,GAEhB9zB,KAAKkrB,WAAWoD,UAAU,CACxB7D,QAAO,EACPzkB,SAAUoZ,EACVoV,uBAAwBP,EACxBhuB,UAAS,EACTwuB,OAAQZ,IAAcjK,EAAU8K,KAChCC,UAAWd,IAAcjK,EAAUvK,QACnC6C,SAAQ,EACR4R,oBAAmB,IAGrB9zB,KAAKysB,mBAEDwH,EAAa,CAyBf,GAxBMW,EAAgB50B,KAAK60B,aAAgB,CACzCX,UAAS,EACTzJ,QAAO,EACPzkB,SAAUoZ,EACVvB,QAAO,EACPiW,oBAAmB,IAClBpR,OAAM,SAAAle,GAGP,MAAkBA,ERtab3E,eAAe,iBQuaZ2E,GAEF0vB,GAAa,EAAKY,SAASrK,GAAS4J,gBACtC,EAAKnJ,WAAW6J,eAAetK,EAASjmB,EAAOsvB,GAC/C,EAAKS,WAAW9J,GAChB,EAAK8J,WAAWT,GAChB,EAAKrH,oBAED,IAAIvC,EAAY,CAAEJ,aAActlB,QAMtB,sBAAhByd,EACF,SAAO2S,GAKTA,EAAclS,OAAM,eAStB,OAJA1iB,KAAKkrB,WAAW8J,sBAAsBvK,GAAUwJ,GAChDj0B,KAAKu0B,WAAW9J,GAChBzqB,KAAKu0B,WAAWT,GAEZ9zB,KAAKwtB,UAAUpO,GAAO6V,mBACxB,GAAOj1B,KAAK8xB,WAAW/C,aAAa,CAClC/oB,SAAUoZ,EACV4P,aAAc,CAAEnO,KAAM0S,GACtBjuB,QAAO,EACPW,UAAS,EACTgpB,wBAAwB,IACvB/sB,MAAK,SAACF,GAQP,OAPA,EAAKkzB,gBACHzK,EACAzoB,EACA6b,EACAiW,GAEF,EAAKrH,mBACEzqB,OAIXhC,KAAKysB,mBAIL,GAAO,CAAE5L,KAAM0S,aAGT,YAAA2B,gBAAR,SACEzK,EACAzoB,EACA,EAKA8xB,G,IAJE7R,EAAA,EAAAA,YACAhc,EAAA,EAAAA,UACAmlB,EAAA,EAAAA,YAIkB,aAAhBnJ,EACFjiB,KAAK6yB,SAASpI,GAAS,WAAM,MAAC,CAC5B0K,QAAS,CAAEnzB,OAAQA,EAAO6e,KAAM8E,UAAU,OAG5C3lB,KAAKusB,UAAU2I,gBACblzB,EACAhC,KAAK80B,SAASrK,GAASzkB,SACvBC,EACA6tB,EACgB,WAAhB1I,GAA4C,QAAhBA,IAO3B,YAAAgK,yBAAP,SACE3K,EACA5M,EACAwM,GAHF,WAKE,SAASgL,EAAOhxB,EAA0BuK,GACxC,GAAIyb,EAAShmB,GACX,IACEgmB,EAAShmB,GAASuK,GAClB,MAAO7N,KAQb,OAAO,SACLkqB,EACAkK,GAOA,GAJA,EAAKZ,WAAW9J,GAAS,GAIpBQ,EAAL,CAEM,oBAAEiI,EAAA,EAAAA,gBAAiBltB,EAAA,EAAAA,SAEnBic,EAAciR,EAChBA,EAAgBrV,QAAQoE,YACxBpE,EAAQoE,YAGZ,GAAoB,YAAhBA,EAAJ,CAEA,IAAMxB,EAAUgJ,EAAyBwB,EAAgBvK,eACnDwC,EAAagQ,GAAmBA,EAAgB/P,gBAEhDmS,KACJpS,GACAA,EAAWxC,gBAAkBuK,EAAgBvK,eAGzC6U,EACJ1X,EAAQiS,oBACNqF,GAAWlK,EAAgB0C,mBAC5B2H,GAAwBzX,EAAQ2X,6BACjB,eAAhBvT,GACgB,sBAAhBA,EAEF,IAAIxB,GAAY8U,EAAhB,CAIA,IAAME,EAAmB9L,EAAgBsB,EAAgB1H,eAEnD6H,EAA2B8H,GAC5BA,EAAgBrV,QAAQuN,aACxBvN,EAAQuN,aACR,OAIL,GAAoB,SAAhBA,GAA0BqK,GAAoBxK,EAAgBnB,aAChE,OAAOuL,EAAO,QAAS,IAAInL,EAAY,CACrC3G,cAAe0H,EAAgB1H,cAC/BuG,aAAcmB,EAAgBnB,gBAIlC,IACE,IAAIjJ,OAAI,EACJ6U,OAAS,EAEb,GAAIP,EAOkB,aAAhBlT,GAA8C,iBAAhBA,GAChC,EAAK4Q,SAASpI,GAAS,WAAM,MAAC,CAAE0K,QAAS,SAG3CtU,EAAOsU,EAAQnzB,OACf0zB,GAAaP,EAAQxP,aAChB,CACL,IAAM3C,EAAYkQ,GAAmBA,EAAgBjQ,eAC/C0S,EACY,SAAhBvK,IACCpI,GAAaA,EAAUO,iBACtB0H,EAAgB1H,cAEpB,GAAIL,GAAcA,EAAWrC,OAAS8U,EACpC9U,EAAOqC,EAAWrC,KAClB6U,GAAY,MACP,CACL,IAAME,EAAa,EAAKrJ,UAAUiG,WAAW3C,KAAK,CAChDzQ,MAAOpZ,EACPC,UACEglB,EAAgB0C,mBAChB1C,EAAgBhlB,UAClB6pB,mBAAmB,EACnBC,YAAY,IAGdlP,EAAO+U,EAAW5zB,OAClB0zB,GAAaE,EAAWjQ,UAO5B,IAAM/D,EAAQ8T,KACZ7X,EAAQiS,mBACQ,eAAhB7N,GAGI4T,EAAwC,CAC5ChV,KAAMe,EAAQsB,GAAcA,EAAWrC,KAAOA,EAC9CJ,QAAO,EACPC,cAAeuK,EAAgBvK,cAC/BkB,MAAK,GAIa,QAAhBwJ,GAAyBqK,IAC3BI,EAAgB1kB,OAAS8Z,EAAgB1H,eAG3C8R,EAAO,OAAQQ,GAEf,MAAO/L,GACPuL,EAAO,QAAS,IAAInL,EAAY,CAAEJ,aAAY,WAiB7C,YAAA0D,UAAP,SAAiBxnB,GACP,IAAAosB,EAAA,KAAAA,eAER,IAAKA,EAAe3hB,IAAIzK,GAAW,CACjC,IAAMR,EAAQxF,KAAKusB,UAAUiG,WACvBsD,EAActwB,EAAMuwB,kBAAkB/vB,GACtCgwB,EAAU,YACdxwB,EAAMywB,iBAAiBH,IAEnBzG,EAAcrvB,KAAK8xB,WAAWzC,YAAYyG,GAC1ClI,EAAc5tB,KAAK8xB,WAAWlE,YAAYoI,GAE1C,EAAa,CACjBhwB,SAAU8vB,EAGV7qB,iBAAkB,YAAiB6qB,GACnCb,mBAAoBj1B,KAAK8xB,WAAWnC,qBAAqBmG,GACzDzG,YAAW,EACXzB,YAAW,EACXsI,YAAa,YACX,YAAuBJ,KAIrBpiB,EAAM,SAAC9I,GACPA,IAAQwnB,EAAe3hB,IAAI7F,IAC7BwnB,EAAezhB,IAAI/F,EAAK,IAM5B8I,EAAI1N,GACJ0N,EAAIoiB,GACJpiB,EAAI2b,GACJ3b,EAAIka,GAGN,OAAOwE,EAAejsB,IAAIH,IAGpB,YAAA8sB,aAAR,SACE9sB,EACAC,GAEA,kCACKjG,KAAKwtB,UAAUxnB,GAAUkwB,aACzBjwB,IAWA,YAAAsc,WAAP,SACE1E,EACAuM,QAAA,IAAAA,OAAA,GAEA,0CAMAvM,EAAQ5X,UAAYjG,KAAK8yB,aAAajV,EAAQuB,MAAOvB,EAAQ5X,gBAEV,IAAxC4X,EAAQ2X,8BACjB3X,EAAQ2X,6BAA8B,GAGxC,IAAIW,EAAqB,eAAKtY,GAE9B,OAAO,IAAIuY,EAA+B,CACxCjM,aAAcnqB,KACd6d,QAASsY,EACT/L,gBAAiBA,KAId,YAAAhL,MAAP,SAAgBvB,GAAhB,WAsBE,OAnBE,wBAIF,0CAMI,aAAAA,EAAA,sBAKA,aAAAA,EAAA,iBAIG,IAAIrc,SAA8B,SAACC,EAASC,GACjD,IAAM20B,EAAe,EAAK9T,WAAc1E,GAAS,GACjD,EAAKsU,oBAAoBxhB,IAAI,SAAS0lB,EAAa5L,QAAW/oB,GAC9D20B,EACGr0B,SACAE,KAAKT,EAASC,GAOdQ,MAAK,WACJ,SAAKiwB,oBAAoBtH,OAAO,SAASwL,EAAa5L,gBAKvD,YAAAC,gBAAP,WACE,OAAOrR,OAAOrZ,KAAKkyB,cAGd,YAAAoE,iBAAP,SAAwB7L,GACtBzqB,KAAKu2B,4BAA4B9L,GACjCzqB,KAAKysB,oBAGC,YAAA8J,4BAAR,SAAoC9L,GAClCzqB,KAAK0sB,iBAAiBjC,GACtBzqB,KAAKkrB,WAAWa,UAAUtB,GAC1BzqB,KAAKu0B,WAAW9J,IAGX,YAAA+L,iBAAP,SAAwB/L,EAAiBgM,GACvCz2B,KAAK6yB,SAASpI,GAAS,SAAC,GAEtB,OAFwB,EAAAtB,UACdzV,IAAI+iB,GACP,CAAEnC,aAAa,OAInB,YAAAF,iBAAP,SACE3J,EACAzkB,EACA6X,GAHF,WAKUsW,EAAA,iBAAAA,OACJA,GAAQA,IAaZ,OAAOn0B,KAAKusB,UAAUiG,WAAWkE,MAAM,CACrCtX,MAAOpZ,EACPC,UAAW4X,EAAQ5X,UACnB8pB,YAAY,EACZjN,eAhBqB,WACrB,IAAIA,EAAiB,KACboQ,EAAA,cAAAA,gBACR,GAAIA,EAAiB,CACnB,IAAMhQ,EAAagQ,EAAgB/P,gBAC/BD,IACFJ,EAAiBI,EAAWrC,MAIhC,OAAOiC,GAOP6T,SAAU,SAAAxB,GACR,EAAKtC,SAASpI,GAAS,WAAM,MAAC,CAAE6J,aAAa,EAAMa,QAAO,UAMzD,YAAA9H,mBAAP,SACE5C,EACAyI,GAEAlzB,KAAK6yB,SAASpI,GAAS,WAAM,MAAC,CAAEyI,gBAAe,OAG1C,YAAApF,sBAAP,SAA6BrD,GACnB,IAAA0J,EAAA,iBAAAA,OACRn0B,KAAK6yB,SAASpI,GAAS,WAAM,MAAC,CAAEyI,gBAAiB,SAC7CiB,GAAQA,KAGP,YAAAyC,WAAP,WAOE52B,KAAKmyB,oBAAoB/pB,SAAQ,SAAA1G,GAC/BA,EAAO,gBAKT,IAAMm1B,EAAqB,GAS3B,OARA72B,KAAKyG,QAAQ2B,SAAQ,SAAC,EAAqBqiB,GAAnB,EAAAyI,iBACD2D,EAASzzB,KAAKqnB,MAGrCzqB,KAAKkrB,WAAWmD,MAAMwI,GACtB72B,KAAK+xB,cAAc1D,QAGZruB,KAAKusB,UAAU8B,SAGjB,YAAAyI,WAAP,sBAOE,OAAO92B,KAAK42B,aAAa10B,MAAK,WAC5B,OAAO,EAAK60B,+BAIT,YAAAA,yBAAP,SACEC,GADF,gBACE,IAAAA,OAAA,GAEA,IAAMC,EAA6D,GAqBnE,OAnBAj3B,KAAKyG,QAAQ2B,SAAQ,SAAC,EAAqBqiB,G,IAAnByI,EAAA,EAAAA,gBACtB,GAAIA,EAAiB,CACnB,IAAMjR,EAAciR,EAAgBrV,QAAQoE,YAE5CiR,EAAgB9P,mBAEE,eAAhBnB,IACC+U,GAAkC,YAAhB/U,GAEnBgV,EAAwB7zB,KAAK8vB,EAAgB7T,WAG/C,EAAKwT,SAASpI,GAAS,WAAM,MAAC,CAAE0K,QAAS,SACzC,EAAKZ,WAAW9J,OAIpBzqB,KAAKysB,mBAEEjrB,QAAQolB,IAAIqQ,IAGd,YAAA1J,aAAP,SACE9C,EACA5M,EACAwM,GAMA,OAJArqB,KAAKw2B,iBACH/L,EACAzqB,KAAKo1B,yBAAyB3K,EAAS5M,EAASwM,IAE3CrqB,KAAK0rB,WAAcjB,EAAS5M,IAG9B,YAAAqZ,WAAP,SACEzM,EACA5M,EACA4Y,GAWA,OAPAz2B,KAAKw2B,iBAAiB/L,EAASgM,GAE/Bz2B,KAAK0rB,WAAcjB,EAAS5M,GAGzB6E,OAAM,eAEF+H,GAGF,YAAAuB,yBAAP,SAAyC,GAAzC,WACE5M,EAAA,EAAAA,MACA6C,EAAA,EAAAA,YACAhc,EAAA,EAAAA,UAEAmZ,EAAQpf,KAAKwtB,UAAUpO,GAAOpZ,SAC9BC,EAAYjG,KAAK8yB,aAAa1T,EAAOnZ,GAErC,IAAMkxB,EAAiB,SAAClxB,GACtB,SAAKutB,sBACHpU,EACA,GACAnZ,GACA,GACAqB,KAAI,SAAAtF,GAUJ,GATKigB,GAA+B,aAAhBA,IAClB,EAAKsK,UAAU6K,uBACbp1B,EACAod,EACAnZ,GAEF,EAAKwmB,oBAGH,YAAsBzqB,GACxB,MAAM,IAAIkoB,EAAY,CACpB3G,cAAevhB,EAAOmP,SAI1B,OAAOnP,MAGX,GAAIhC,KAAKwtB,UAAUpO,GAAOnU,iBAAkB,CAC1C,IAAM,EAAoBjL,KAAK8xB,WAAWpE,qBACxCtO,EACAnZ,GACA/D,KAAKi1B,GAEP,OAAO,IAAIxjB,GAA2B,SAAA0W,GACpC,IAAIwD,EAA2B,KAK/B,OAJA,EAAkB3rB,MAChB,SAAAikB,GAAc,OAAA0H,EAAM1H,EAAWtD,UAAUwH,KACzCA,EAAS7lB,OAEJ,WAAM,OAAAqpB,GAAOA,EAAIjK,kBAI5B,OAAOuT,EAAelxB,IAGjB,YAAA8lB,UAAP,SAAiBtB,GACfzqB,KAAK2yB,qBAAqBlI,GAC1BzqB,KAAKysB,oBAGC,YAAAkG,qBAAR,SAA6BlI,GAC3BzqB,KAAKu2B,4BAA4B9L,GACjCzqB,KAAK8qB,YAAYL,IAGZ,YAAAK,YAAP,SAAmBL,GAMjBzqB,KAAKmyB,oBAAoBtH,OAAO,SAASJ,GACzCzqB,KAAKmyB,oBAAoBtH,OAAO,gBAAgBJ,GAChDzqB,KAAK80B,SAASrK,GAAS7jB,cAAcwB,SAAQ,SAAA7B,GAAK,OAAAA,EAAEqd,iBACpD5jB,KAAKyG,QAAQokB,OAAOJ,IAGf,YAAA4M,sBAAP,SACEnE,EACAnD,QAAA,IAAAA,OAAA,GAKM,gBAAE9pB,EAAA,EAAAA,UAAWmZ,EAAA,EAAAA,MAAO6C,EAAA,EAAAA,YAAa6N,EAAA,EAAAA,kBACjC5M,EAAagQ,EAAgB/P,gBAC3BgS,EAAA,yBAAAA,QAER,GAAIA,GAAWA,EAAQxP,SACrB,MAAO,CAAE9E,KAAMsU,EAAQnzB,OAAQshB,SAAS,GAG1C,GAAoB,aAAhBrB,GAA8C,iBAAhBA,EAChC,MAAO,CAAEpB,UAAM9W,EAAWuZ,SAAS,GAG/B,sC,uFAAEthB,EAAA,EAAAA,OAAQ2jB,EAAA,EAAAA,SAQhB,MAAO,CACL9E,KAAO8E,GAAYmK,EAAqB9tB,OAAS,EACjDshB,SAAUqC,IAIP,YAAA2R,2BAAP,SACEC,GAMA,IAAIrE,EACJ,GAAmC,iBAAxBqE,EAAkC,CACnC,uBAAArE,gBAGR,kBAIAA,EAAkBsE,OAElBtE,EAAkBqE,EAGd,gBAAEtxB,EAAA,EAAAA,UAAWmZ,EAAA,EAAAA,MACnB,MAAO,CACL0D,eAAgB9iB,KAAKq3B,sBAAsBnE,GAAiB,GAAOrS,KACnE5a,UAAS,EACTD,SAAUoZ,IAIP,YAAAqN,iBAAP,sBACEzsB,KAAK2xB,cACL3xB,KAAKyG,QAAQ2B,SAAQ,SAACgL,EAAMvJ,GACtBuJ,EAAKkhB,aACPlhB,EAAK+V,UAAU/gB,SAAQ,SAAAquB,GAGjBA,GACFA,EAAS,EAAKvL,WAAW/kB,IAAI0D,GAAKuJ,EAAK+hB,gBAO1C,YAAA1H,cAAP,WACE,OAAOztB,KAAK8xB,YAQN,YAAA0B,sBAAR,SACEpU,EACA9Z,EACAW,EACAwxB,GAJF,IAMMtR,EANN,YAIE,IAAAsR,MAAyBz3B,KAAK0xB,oBAItB,IAAA9D,EAAA,kBAAAA,YACR,GAAIA,EAAa,CACT,IAAE,EAAF,KAAEyE,wBAAyBZ,EAA3B,KAA2BA,KAE3B/qB,EAAY,CAChB0Y,MAAOwO,EACP3nB,UAAS,EACTP,cAAe,YAAiBkoB,SAAgB,EAChDtoB,QAAStF,KAAKsvB,eAAc,2BACvBhqB,GAAO,CACVoyB,YAAaD,MAMjB,GAFAnyB,EAAUoB,EAAUpB,QAEhBmyB,EAAe,CACjB,IAAM,EAAc,EAAwBtxB,IAAIynB,IAAgB,IAAInoB,IACpE,EAAwBkL,IAAIid,EAAa,GAEzC,IAAM,EAAU/kB,KAAKC,UAAU7C,GAG/B,KAFAkgB,EAAa,EAAYhgB,IAAI,IAEZ,CACf,EAAYwK,IACV,EACAwV,EAAaoL,EACX,YAAQE,EAAM/qB,KAIlB,IAAM8X,EAAU,WACd,EAAYqM,OAAO,GACd,EAAY7X,MAAM,EAAwB6X,OAAO+C,GACtD,EAAWhK,eAGP,EAAauC,EAAWtD,UAAU,CACtC/gB,KAAM0c,EACNha,MAAOga,EACPmH,SAAUnH,UAKd2H,EAAaoL,EAAU,YAAQE,EAAM/qB,SAGvCyf,EAAaxS,EAAWgkB,GAAG,CAAE9W,KAAM,KACnCvb,EAAUtF,KAAKsvB,eAAehqB,GAGxB,IAAA+pB,EAAA,kBAAAA,YAYR,OAXIA,IACFlJ,EDjnCN,SACEA,EACAzG,GAEA,OAAO,IAAI/L,GAAc,SAAA0W,GACf,IAAAvoB,EAAA,EAAAA,KAAM0C,EAAA,EAAAA,MAAOmhB,EAAA,EAAAA,SACjBiS,EAAkB,EAClBC,GAAY,EAEVC,EAAuB,CAC3Bh2B,KAAA,SAAKF,KACDg2B,EACF,IAAIp2B,SAAQ,SAAAC,GACVA,EAAQie,EAAM9d,OACbM,MACD,SAAAF,KACI41B,EACF91B,GAAQA,EAAKlB,KAAKypB,EAAUroB,GAC5B61B,GAAaC,EAAQnS,cAEvB,SAAA5kB,KACI62B,EACFpzB,GAASA,EAAM5D,KAAKypB,EAAUtpB,OAIpCyD,MAAK,SAACzD,GACJyD,GAASA,EAAM5D,KAAKypB,EAAUtpB,IAEhC4kB,SAAQ,WACNkS,GAAY,EACPD,GACHjS,GAAYA,EAAS/kB,KAAKypB,KAK1BwD,EAAM1H,EAAWtD,UAAUiV,GACjC,OAAO,WAAM,OAAAjK,EAAIjK,kBC2kCFmU,CAAS5R,GAAY,SAAAnkB,GAChC,OAAO,EAAK8vB,WAAW/C,aAAa,CAClC/oB,SAAUqpB,EACVL,aAAchtB,EACdsD,QAAO,EACPW,UAAS,QAKRkgB,GAMD,YAAA0O,aAAR,SAAwB,GAAxB,IAcMgB,EACAmC,EAfN,OACE9D,EAAA,EAAAA,UACAzJ,EAAA,EAAAA,QACAzkB,EAAA,EAAAA,SACA6X,EAAA,EAAAA,QACAiW,EAAA,EAAAA,oBAQQ7tB,EAAA,EAAAA,UAAW,IAAAmlB,mBAAA,IAAc,EAAd,SAAsBnJ,EAAA,EAAAA,YAIzC,OAAO,IAAIzgB,SAA8B,SAACC,EAASC,GACjD,IAAMykB,EAAa,EAAKqN,sBACtBxtB,EACA6X,EAAQvY,QACRW,GAGIgyB,EAAS,gBAAgBxN,EAC/B,EAAK0H,oBAAoBxhB,IAAIsnB,EAAQv2B,GAErC,IAAM8c,EAAU,WACd,EAAK2T,oBAAoBtH,OAAOoN,GAChC,EAAKpF,SAASpI,GAAS,SAAC,GAAE,EAAA7jB,cACVikB,OAAOlI,OAInBA,EAAewD,EAAW7e,KAAI,SAACtF,GAqBnC,GApBIkyB,GAAa,EAAKY,SAASrK,GAAS4J,gBACtC,EAAKa,gBACHzK,EACAzoB,EACA6b,EACAiW,GAGF,EAAK5I,WAAWgK,gBACdzK,EACAzoB,EACA8xB,GAGF,EAAKS,WAAW9J,GAChB,EAAK8J,WAAWT,GAEhB,EAAKrH,oBAGa,SAAhBrB,GAA0BzB,EAAgB3nB,EAAOmP,QACnD,OAAOzP,EAAO,IAAIwoB,EAAY,CAC5B3G,cAAevhB,EAAOmP,UAQ1B,GAJoB,QAAhBia,IACF4M,EAAkBh2B,EAAOmP,QAGvB2iB,GAAuC,aAAhB7R,EAGzB4T,EAAkB7zB,EAAO6e,SACpB,CAEC,mC,yDAAE,IAAA7e,QAAQ,EAAA2jB,UAOA9H,EAAQiS,qBACtB+F,EAAkB,OAGrBhT,UAAU,CACXre,MAAA,SAAMA,GACJga,IACA9c,EAAO8C,IAGTmhB,SAAQ,WACNnH,IACA/c,EAAQ,CACNof,KAAMgV,EACN1kB,OAAQ6mB,EACRvX,SAAS,EACTC,cAAe8I,EAAc7I,MAC7BiB,OAAO,OAKb,EAAKiR,SAASpI,GAAS,SAAC,GAAE,EAAA7jB,cACV8M,IAAIiP,UAKhB,YAAAmS,SAAR,SAAiBrK,GACf,OACEzqB,KAAKyG,QAAQN,IAAIskB,IAAY,CAC3BtB,UAAW,IAAI1V,IACf6gB,aAAa,EACbtuB,SAAU,KACVmvB,QAAS,KACTd,cAAe,EACfnB,gBAAiB,KACjBtsB,cAAe,IAAI6M,MAKjB,YAAAof,SAAR,SACEpI,EACA0I,GAEA,IAAM/d,EAAOpV,KAAK80B,SAASrK,GACrByN,EAAU,OAAH,IAAG,CAAH,eAAQ9iB,GAAS+d,EAAQ/d,IACtCpV,KAAKyG,QAAQkK,IAAI8Z,EAASyN,IAGpB,YAAA3D,WAAR,SACE9J,EACA6J,QAAA,IAAAA,OAAA,GAEI7J,GACFzqB,KAAK6yB,SAASpI,GAAS,WAAM,MAAC,CAAE6J,YAAW,OAIvC,YAAAhF,eAAR,SAAuBhqB,QAAA,IAAAA,MAAA,IACrB,IAAM6yB,EAAan4B,KAAK8xB,WAAWxC,eAAehqB,GAClD,kCACK6yB,GAAU,CACbtG,gBAAiB7xB,KAAK6xB,mBAInB,YAAAuG,cAAP,SAAqB3N,GACnB,IAAMrL,EAAQpf,KAAKkrB,WAAW/kB,IAAIskB,GAElC,OACErL,GACAA,EAAMsB,gBAAkB8I,EAAc7I,OACtCvB,EAAMsB,gBAAkB8I,EAAchlB,OAWnC,YAAAooB,kBAAP,SACE/O,EACA4M,EACAgM,GAHF,WAKU5W,EAAA,EAAAA,aAQR,GANA,mBAMK7f,KAAK4xB,QAAS,CACjB,IAAIxe,EAAOpT,KAAKsyB,qBAAqBnsB,IAAIskB,GACpCrX,GACHpT,KAAKsyB,qBAAqB3hB,IAAI8Z,EAAUrX,EAAO,IAGjDA,EAAKilB,SAAWxY,EAChBzM,EAAKyK,QAAO,2BACPA,GAAO,CACVoE,YAAa,iBAGf,IAAM,EAAa,WACjB,IAAM7O,EAAO,EAAKkf,qBAAqBnsB,IAAIskB,GACvCrX,IACE,EAAKglB,cAAc3N,GACrB,IAEA,EAAKiB,WAAWjB,EAASrX,EAAKyK,QAAS+L,EAAU8K,MAAMxyB,KACrD,EACA,KAMF,EAAO,WACX,IAAMkR,EAAO,EAAKkf,qBAAqBnsB,IAAIskB,GACvCrX,IACFmU,aAAanU,EAAK0U,SAClB1U,EAAK0U,QAAUR,WAAW,EAAYlU,EAAKilB,YAI3C5B,GACFz2B,KAAKw2B,iBAAiB/L,EAASgM,GAGjC,IAGF,OAAOhM,GAGF,YAAAiC,iBAAP,SAAwBjC,GACtBzqB,KAAKsyB,qBAAqBzH,OAAOJ,IAErC,EAt0CA,GCjCA,aAGE,WAAY6N,GACVt4B,KAAKwF,MAAQ8yB,EAgLjB,OA7KS,YAAA9F,SAAP,WACE,OAAOxyB,KAAKwF,OAGP,YAAA0vB,gBAAP,SACElzB,EACAgE,EACAC,EACA6tB,EACAyE,QAAA,IAAAA,OAAA,GAEA,IAAIC,GAAmB,YAAsBx2B,GACzCu2B,GAAgB,YAAsBv2B,IAAWA,EAAO6e,OAC1D2X,GAAkB,IAEf1E,GAAuB0E,GAC1Bx4B,KAAKwF,MAAMizB,MAAM,CACfz2B,OAAQA,EAAO6e,KACf6X,OAAQ,aACRtZ,MAAOpZ,EACPC,UAAWA,KAKV,YAAAmxB,uBAAP,SACEp1B,EACAgE,EACAC,GAIK,YAAsBjE,IACzBhC,KAAKwF,MAAMizB,MAAM,CACfz2B,OAAQA,EAAO6e,KACf6X,OAAQ,oBACRtZ,MAAOpZ,EACPC,UAAWA,KAKV,YAAAmtB,iBAAP,SAAwB5O,GAAxB,IASQ,EATR,OAQMA,EAASE,qBAGT,EADyC,mBAAhCF,EAASE,mBACLF,EAASE,mBAAmBF,EAASve,WAErCue,EAASE,mBAGxB1kB,KAAKwF,MAAMmzB,6BAA4B,SAAAC,GACrC,IAAMC,EAAO,EAAKrzB,MAClB,EAAKA,MAAQozB,EAEb,IACE,EAAKxK,mBAAmB,CACtBlK,WAAYM,EAASN,WACrBliB,OAAQ,CAAE6e,KAAM,GAChB7a,SAAUwe,EAASxe,SACnBC,UAAWue,EAASve,UACpB2sB,cAAepO,EAASoO,cACxBjO,OAAQH,EAASG,SAPrB,QAUE,EAAKnf,MAAQqzB,KAEdrU,EAASN,cAIT,YAAAkK,mBAAP,SAA0B5J,GAA1B,WASE,IAAK,YAAsBA,EAASxiB,QAAS,CAC3C,IAAM,EAAoC,CAAC,CACzCA,OAAQwiB,EAASxiB,OAAO6e,KACxB6X,OAAQ,gBACRtZ,MAAOoF,EAASxe,SAChBC,UAAWue,EAASve,YAGd,IAAA2sB,cACJ,GACFpzB,OAAOyJ,KAAK,GAAeb,SAAQ,SAAAyB,GAC3B,WAAEuV,EAAA,EAAAA,MAAO+T,EAAA,EAAAA,QAGT,gB,4EAAE,IAAAnxB,OAOR,GAPoC,EAAA2jB,SAOtB,CAEZ,IAAMmT,EAAkB,aAAsB,WAC5C,OAAA3F,EAAQ4F,EAAoB,CAC1BC,eAAgBxU,EAASxiB,OACzB4oB,UAAW,YAAiBxL,EAAMpZ,gBAAa+D,EAC/CkvB,eAAgB7Z,EAAMnZ,eAKtB6yB,GACF,EAAY11B,KAAK,CACfpB,OAAQ82B,EACRJ,OAAQ,aACRtZ,MAAOA,EAAMpZ,SACbC,UAAWmZ,EAAMnZ,gBAO3BjG,KAAKwF,MAAM0zB,oBAAmB,SAAAN,GAC5B,EAAYxwB,SAAQ,SAAAqwB,GAAS,OAAAG,EAAEH,MAAMA,MAK7B,IAAA9T,EAAA,EAAAA,OACJA,GACF,aAAsB,WAAM,OAAAA,EAAOiU,EAAGpU,EAASxiB,gBAMhD,YAAAyxB,qBAAP,SAA4B,G,IAC1BvP,EAAA,EAAAA,WACA,EAAAQ,oBAME1kB,KAAKwF,MAAM2zB,iBAAiBjV,IAIzB,YAAAsI,sBAAP,SACExmB,EACAC,EACAslB,GAEAvrB,KAAKwF,MAAMizB,MAAM,CACfz2B,OAAQupB,EACRmN,OAAQ,aACRzyB,UAAS,EACTmZ,MAAOpZ,KAIJ,YAAAqoB,MAAP,WACE,OAAOruB,KAAKwF,MAAM6oB,SAEtB,EApLA,GCuCA,aAkDE,WAAYxQ,GAAZ,WA1CO,KAAAub,eAAiC,GAIhC,KAAAC,oBAAiD,GACjD,KAAAC,oBAAiD,GAuCrD,IAAA9zB,EAAA,EAAAA,MACA,IAAAosB,eAAA,IAAU,GAAV,EACA,IAAA2H,0BAAA,IAAqB,EAArB,IACAC,EAAA,EAAAA,kBACA,IAAA9H,0BAAA,IAAqB,GAArB,EACA0H,EAAA,EAAAA,eACA,IAAAvM,8BAAA,IAAyB,GAAzB,EACA2B,EAAA,EAAAA,UACAiL,EAAA,EAAAA,SACAhL,EAAA,EAAAA,gBACA,IAAA1qB,KACA,IAAAykB,QAGIiJ,EAAA,EAAAA,KAQN,IAJKA,GAAQjD,IACXiD,EAAO,IAAWiI,UAGfjI,IAASjsB,EACZ,MAAM,WAQRxF,KAAKyxB,KAAOA,EACZzxB,KAAKwF,MAAQA,EACbxF,KAAKguB,MAAQ,IAAI2L,EAAUn0B,GAC3BxF,KAAK0hB,sBAAwBkQ,GAAW2H,EAAqB,EAC7Dv5B,KAAK0xB,mBAAqBA,EAC1B1xB,KAAKo5B,eAAiBA,GAAkB,GACxCp5B,KAAKy5B,SAAWA,EAEZF,GACFjS,YACE,WAAM,OAAC,EAAK5F,uBAAwB,IACpC6X,GAIJv5B,KAAKuiB,WAAaviB,KAAKuiB,WAAWlB,KAAKrhB,MACvCA,KAAKof,MAAQpf,KAAKof,MAAMiC,KAAKrhB,MAC7BA,KAAKokB,OAASpkB,KAAKokB,OAAO/C,KAAKrhB,MAC/BA,KAAK82B,WAAa92B,KAAK82B,WAAWzV,KAAKrhB,MACvCA,KAAK+2B,yBAA2B/2B,KAAK+2B,yBAAyB1V,KAAKrhB,WAUpC,IAAtBw5B,IAEHA,GAAuC,oBAAXI,UAE/BA,OAAeC,kBAAoB75B,MAkCtCA,KAAKwoB,QCrNc,QDuNnBxoB,KAAK8xB,WAAa,IAAIS,EAAW,CAC/B/sB,MAAK,EACLL,OAAQnF,KACRwuB,UAAS,EACTC,gBAAe,IAGjBzuB,KAAKmqB,aAAe,IAAI2P,EAAa,CACnCrI,KAAMzxB,KAAKyxB,KACXzD,MAAOhuB,KAAKguB,MACZ0D,mBAAkB,EAClBE,QAAO,EACPC,gBAAiB,CACf9tB,KAAMg2B,EACNvR,QAASwR,GAEXlI,WAAY9xB,KAAK8xB,WACjBjF,uBAAsB,EACtB8E,YAAa,WACP,EAAKsI,gBACP,EAAKA,eAAe,CAClBC,OAAQ,GACRC,MAAO,CACL1zB,QAAS,EAAK0jB,aAAae,WAAW+C,WACtCtnB,UAAW,EAAKwjB,aAAa4H,cAAc9D,YAE7CmM,0BAA2B,EAAK50B,MAAM60B,SAAQ,QAyV1D,OA9US,YAAA5H,KAAP,WACEzyB,KAAKmqB,aAAasI,QAsBb,YAAAlQ,WAAP,SACE1E,GAkBA,OAhBI7d,KAAKo5B,eAAe7W,aACtB1E,EAAU,2BACL7d,KAAKo5B,eAAe7W,YACpB1E,KAML7d,KAAK0hB,uBACoB,iBAAxB7D,EAAQoE,aACiB,sBAAxBpE,EAAQoE,cAEVpE,EAAU,OAAH,IAAG,CAAH,eAAQA,GAAO,CAAEoE,YAAa,iBAGhCjiB,KAAKmqB,aAAa5H,WAA0B1E,IAY9C,YAAAuB,MAAP,SACEvB,GAoBA,OAlBI7d,KAAKo5B,eAAeha,QACtBvB,EAAU,2BAAK7d,KAAKo5B,eAAeha,OAAUvB,IAK/C,mDAQI7d,KAAK0hB,uBAAiD,iBAAxB7D,EAAQoE,cACxCpE,EAAU,OAAH,IAAG,CAAH,eAAQA,GAAO,CAAEoE,YAAa,iBAGhCjiB,KAAKmqB,aAAa/K,MAASvB,IAU7B,YAAAuG,OAAP,SACEvG,GASA,OAPI7d,KAAKo5B,eAAehV,SACtBvG,EAAU,2BACL7d,KAAKo5B,eAAehV,QACpBvG,IAIA7d,KAAKmqB,aAAa/F,OAAUvG,IAO9B,YAAAgF,UAAP,SACEhF,GAEA,OAAO7d,KAAKmqB,aAAa6B,yBAA4BnO,IAYhD,YAAAyc,UAAP,SACEzc,EACAkS,GAEA,YAFA,IAAAA,OAAA,GAEO/vB,KAAKwF,MAAM80B,UAAyBzc,EAASkS,IAiB/C,YAAAwK,aAAP,SACE1c,EACAkS,GAEA,YAFA,IAAAA,OAAA,GAEO/vB,KAAKwF,MAAM+0B,aAA4B1c,EAASkS,IAQlD,YAAAyK,WAAP,SACE3c,GAEA,IAAM7b,EAAShC,KAAKwF,MAAMg1B,WAA8B3c,GAExD,OADA7d,KAAKmqB,aAAasC,mBACXzqB,GAcF,YAAAy4B,cAAP,SACE5c,GAEA,IAAM7b,EAAShC,KAAKwF,MAAMi1B,cAAiC5c,GAE3D,OADA7d,KAAKmqB,aAAasC,mBACXzqB,GAaF,YAAA04B,UAAP,SACE7c,GAEA,IAAM7b,EAAShC,KAAKwF,MAAMk1B,UAAiB7c,GAE3C,OADA7d,KAAKmqB,aAAasC,mBACXzqB,GAGF,YAAA24B,wBAAP,SAA+BC,GAC7B56B,KAAKi6B,eAAiBW,GAGjB,YAAAC,aAAP,SAAoBC,GAClB,OAAO,YAAQ96B,KAAKyxB,KAAMqJ,IAMrB,YAAAC,iBAAP,WAKE,OAAO/6B,KAAKmqB,cAmBP,YAAA2M,WAAP,sBACE,OAAOt1B,QAAQC,UACZS,MAAK,WAAM,SAAKioB,aAAayM,gBAC7B10B,MAAK,WAAM,OAAAV,QAAQolB,IAAI,EAAKyS,oBAAoB/xB,KAAI,SAAAwO,GAAM,OAAAA,WAC1D5T,MAAK,WAAM,SAAK60B,+BAOd,YAAAH,WAAP,sBACE,OAAOp1B,QAAQC,UACZS,MAAK,WAAM,SAAKioB,aAAayM,gBAC7B10B,MAAK,WAAM,OAAAV,QAAQolB,IAAI,EAAK0S,oBAAoBhyB,KAAI,SAAAwO,GAAM,OAAAA,YAQxD,YAAAklB,aAAP,SAAoBJ,GAApB,WAEE,OADA56B,KAAKq5B,oBAAoBj2B,KAAKw3B,GACvB,WACL,EAAKvB,oBAAsB,EAAKA,oBAAoB/yB,QAAO,SAAAsyB,GAAK,OAAAA,IAAMgC,OASnE,YAAAK,aAAP,SAAoBL,GAApB,WAEE,OADA56B,KAAKs5B,oBAAoBl2B,KAAKw3B,GACvB,WACL,EAAKtB,oBAAsB,EAAKA,oBAAoBhzB,QAAO,SAAAsyB,GAAK,OAAAA,IAAMgC,OAgBnE,YAAA7D,yBAAP,SACEC,GAEA,OAAOh3B,KAAKmqB,aAAa4M,yBAAyBC,IAM7C,YAAAqD,QAAP,SAAetK,GACb,OAAO/vB,KAAKwF,MAAM60B,QAAQtK,IAUrB,YAAAmL,QAAP,SAAeC,GACb,OAAOn7B,KAAKwF,MAAM01B,QAAQC,IAMrB,YAAAzM,aAAP,SAAoBF,GAClBxuB,KAAK8xB,WAAWpD,aAAaF,IAMxB,YAAAK,aAAP,SAAoBL,GAClBxuB,KAAK8xB,WAAWjD,aAAaL,IAMxB,YAAAM,aAAP,WACE,OAAO9uB,KAAK8xB,WAAWhD,gBAMlB,YAAAsM,6BAAP,SAAoC3M,GAClCzuB,KAAK8xB,WAAWnD,mBAAmBF,IAEvC,EA3gBA,I,sKErCA,YAEE,WAAY7qB,EAAkB6tB,GAA9B,MACE,YAAM7tB,IAAQ,K,OACd,EAAK6tB,KAAOA,E,EAJe,iBAA/B,CAA+BxtB,O,SAQfo3B,EAAc5J,GAC5B,OAAOA,EAAK6J,QAAQ36B,QAAU,E,SAoChB46B,EAAaC,GAC3B,OAAO,IAAI,KAAc,SAAAnR,GACvBA,EAAS7lB,MAAMg3B,M,SAuBHC,EACdC,EACAh1B,GAEA,IAAIpB,EAAU,OAAH,IAAG,CAAH,GAAQo2B,GAyBnB,OAfAl8B,OAAOoU,eAAelN,EAAW,aAAc,CAC7Ci1B,YAAY,EACZ/5B,MAXiB,SAAAE,GAEfwD,EADkB,mBAATxD,EACC,OAAH,IAAG,CAAH,GAAQwD,EAAYxD,EAAKwD,IAEtB,OAAH,IAAG,CAAH,GAAQA,EAAYxD,MAU/BtC,OAAOoU,eAAelN,EAAW,aAAc,CAC7Ci1B,YAAY,EACZ/5B,MATiB,WAAM,sBAAM0D,MAY/B9F,OAAOoU,eAAelN,EAAW,QAAS,CACxCi1B,YAAY,EACZ/5B,MAAO,WAAM,O,SAMM8E,GAGb,IAAA0Y,EAAA,EAAAA,MAAOnZ,EAAA,EAAAA,UAAWP,EAAAgB,EAAAhB,cAC1B,OAAOmD,KAAKC,UAAU,CAACpD,EAAe0Z,EAAOnZ,IAV9B21B,CAAOl1B,MAGfA,EC1GT,SAASm1B,EAAY54B,EAAI64B,GACvB,OAAOA,EAAUA,EAAQ74B,GAAM,IAAW00B,KAG5C,SAASoE,EAAOjE,GACd,MAA0B,mBAAZA,EAAyB,IAAIkE,EAAWlE,GAAWA,EAGnE,SAAgB4B,IACd,OAAO,IAAIsC,GAAW,WAAM,WAAWrE,QAGzC,SAAgBsE,EAAKC,GACnB,OAAqB,IAAjBA,EAAMv7B,OAAqB+4B,IACxBwC,EAAM50B,IAAIy0B,GAAQI,QAAO,SAAC51B,EAAGjE,GAAM,OAAAiE,EAAE0S,OAAO3W,MAGrD,SAAgBuZ,EACd7O,EACAovB,EACAC,GAEA,IAAMC,EAAWP,EAAOK,GAClBG,EAAYR,EAAOM,GAAS,IAAIL,EAAWH,IAEjD,OAAIR,EAAciB,IAAajB,EAAckB,GACpC,IAAIP,GAAW,SAAAt1B,GACpB,OAAOsG,EAAKtG,GACR41B,EAAShB,QAAQ50B,IAAc,IAAWixB,KAC1C4E,EAAUjB,QAAQ50B,IAAc,IAAWixB,QAG1C,IAAIqE,GAAW,SAACt1B,EAAWo1B,GAChC,OAAO9uB,EAAKtG,GACR41B,EAAShB,QAAQ50B,EAAWo1B,IAAY,IAAWnE,KACnD4E,EAAUjB,QAAQ50B,EAAWo1B,IAAY,IAAWnE,QAM9D,IAAa1e,EAAS,SACpBiU,EACAsP,GAEA,IAAMC,EAAYV,EAAO7O,GACzB,GAAImO,EAAcoB,GAOhB,OAAOA,EAET,IAAMC,EAAWX,EAAOS,GAExB,OAAInB,EAAcqB,GACT,IAAIV,GACT,SAAAt1B,GACE,OAAA+1B,EAAUnB,QACR50B,GACA,SAAAzD,GAAM,OAAAy5B,EAASpB,QAAQr4B,IAAO,IAAW00B,SACtC,IAAWA,QAGb,IAAIqE,GAAW,SAACt1B,EAAWo1B,GAChC,OACEW,EAAUnB,QAAQ50B,GAAW,SAAAzD,GAC3B,OAAOy5B,EAASpB,QAAQr4B,EAAI64B,IAAY,IAAWnE,SAC/C,IAAWA,SAMzB,aAME,WAAY2D,GACNA,IAASt7B,KAAKs7B,QAAUA,GAqBhC,OAlBS,YAAAzf,MAAP,SACE7O,EACAovB,EACAC,GAEA,OAAOr8B,KAAKiZ,OAAO4C,EAAM7O,EAAMovB,EAAMC,GAAS,IAAIL,EAAWH,MAGxD,YAAA5iB,OAAP,SAAcnX,GACZ,OAAOmX,EAAOjZ,KAAM8B,IAGf,YAAAw5B,QAAP,SACE50B,EACAo1B,GAEA,MAAM,YAzBM,EAAApC,MAAQA,EACR,EAAAuC,KAAOA,EACP,EAAApgB,MAAQA,EACR,EAAAsE,QAAUA,EAwB1B,EA5BA,G,SA8BgBA,EACdsR,EACA/qB,GAEA,OACE+qB,EAAK6J,QACHG,EACE/0B,EAAUpB,Q,SDvDiBoB,GACjC,IAAMi2B,EAAuC,CAC3C12B,UAAWS,EAAUT,WAAa,GAClC22B,WAAYl2B,EAAUk2B,YAAc,GACpCl3B,cAAegB,EAAUhB,cACzB0Z,MAAO1Y,EAAU0Y,OAWnB,OAPKud,EAAqBj3B,gBACxBi3B,EAAqBj3B,cACmB,iBAA/Bi3B,EAAqBvd,MACxB,YAAiBud,EAAqBvd,OACtC,IAGDud,ECwCDE,C,SD5H0Bn2B,GAQhC,IAPA,IAAMo2B,EAAmB,CACvB,QACA,gBACA,YACA,aACA,WAEc,MAAAt9B,OAAOyJ,KAAKvC,GAAZ,eAAwB,CAAnC,IAAIkC,EAAG,KACV,GAAIk0B,EAAiB97B,QAAQ4H,GAAO,EAClC,MAAM,WAIV,OAAOlC,EC8GkBq2B,CAAkBr2B,OAEpC,IAAWixB,O,gBCvIpB,IAEIqF,EAFS9mB,EAAQ,IAEF8mB,MAInB,SAASC,EAAUC,GACjB,OAAOA,EAAOjjB,QAAQ,UAAW,KAAKkjB,OAIxC,IAAIC,EAAW,GAGXC,EAAoB,GAexB,IAAIC,GAAwB,EA2F5B,IAAIC,GAAgC,EACpC,SAASC,EAAc5yB,GACrB,IAAI6yB,EAAWR,EAAUryB,GAEzB,GAAIwyB,EAASK,GACX,OAAOL,EAASK,GAGlB,IAAIC,EAASV,EAAMpyB,EAAK,CAAE2yB,8BAA+BA,IACzD,IAAKG,GAA0B,aAAhBA,EAAOl3B,KACpB,MAAM,IAAIvC,MAAM,iCASlB,OAHAy5B,EA5DF,SAASC,EAAS/yB,EAAKgzB,GACrB,IAAIC,EAAUr+B,OAAOU,UAAUkQ,SAASxP,KAAKgK,GAE7C,GAAgB,mBAAZizB,EACF,OAAOjzB,EAAItD,KAAI,SAAUhI,GACvB,OAAOq+B,EAASr+B,EAAGs+B,MAIvB,GAAgB,oBAAZC,EACF,MAAM,IAAI55B,MAAM,qBAKd25B,GAAwBhzB,EAAIkzB,YACvBlzB,EAAIkzB,IAITlzB,EAAIkzB,aACClzB,EAAIkzB,IAAIC,kBACRnzB,EAAIkzB,IAAIE,UAGjB,IACIp1B,EACAhH,EACAq8B,EAHAh1B,EAAOzJ,OAAOyJ,KAAK2B,GAKvB,IAAKhC,KAAOK,EACNA,EAAKpJ,eAAe+I,KACtBhH,EAAQgJ,EAAI3B,EAAKL,IAGC,qBAFlBq1B,EAAYz+B,OAAOU,UAAUkQ,SAASxP,KAAKgB,KAEU,mBAAdq8B,IACrCrzB,EAAI3B,EAAKL,IAAQ+0B,EAAS/7B,GAAO,KAKvC,OAAOgJ,EAmBE+yB,CADTD,EAzGF,SAA0BQ,GAIxB,IAHA,IAfuBJ,EAenBK,EAAiB,GACjB93B,EAAc,GAET7F,EAAI,EAAGA,EAAI09B,EAAI73B,YAAY1F,OAAQH,IAAK,CAC/C,IAAI4L,EAAqB8xB,EAAI73B,YAAY7F,GAEzC,GAAgC,uBAA5B4L,EAAmB5F,KAA+B,CACpD,IAAI2E,EAAeiB,EAAmBrI,KAAKnC,MACvCuQ,EAtBD8qB,GADgBa,EAuBa1xB,EAAmB0xB,KAtBlCpyB,OAAOtJ,KAAKg8B,UAAUN,EAAIO,MAAOP,EAAIQ,MAyBlDjB,EAAkBx9B,eAAesL,KAAkBkyB,EAAkBlyB,GAAcgH,IAIjFmrB,GACFh5B,QAAQC,KAAK,+BAAiC4G,EAAjC,iMAKfkyB,EAAkBlyB,GAAcgH,IAAa,GAEnCkrB,EAAkBx9B,eAAesL,KAC3CkyB,EAAkBlyB,GAAgB,GAClCkyB,EAAkBlyB,GAAcgH,IAAa,GAG1CgsB,EAAehsB,KAClBgsB,EAAehsB,IAAa,EAC5B9L,EAAYjD,KAAKgJ,SAGnB/F,EAAYjD,KAAKgJ,GAKrB,OADA8xB,EAAI73B,YAAcA,EACX63B,EAkEEK,CAAiBb,IACA,GAC1BN,EAASK,GAAYC,EAEdA,EAYT,SAASc,IAQP,IAPA,IAAI/1B,EAAO9I,MAAMO,UAAUwQ,MAAM9P,KAAKF,WAElC+9B,EAAWh2B,EAAK,GAGhBzG,EAA+B,iBAAdy8B,EAA0BA,EAAWA,EAAS,GAE1Dj+B,EAAI,EAAGA,EAAIiI,EAAK9H,OAAQH,IAC3BiI,EAAKjI,IAAMiI,EAAKjI,GAAGgG,MAAyB,aAAjBiC,EAAKjI,GAAGgG,KACrCxE,GAAUyG,EAAKjI,GAAGs9B,IAAIpyB,OAAOtJ,KAE7BJ,GAAUyG,EAAKjI,GAGjBwB,GAAUy8B,EAASj+B,GAGrB,OAAOg9B,EAAcx7B,GAIvBw8B,EAAIjpB,QAAUipB,EACdA,EAAIE,YAzJJ,WACEtB,EAAW,GACXC,EAAoB,IAwJtBmB,EAAIG,wBAvGJ,WACErB,GAAwB,GAuG1BkB,EAAII,oCAlCJ,WACErB,GAAgC,GAkClCiB,EAAIK,qCA/BJ,WACEtB,GAAgC,GAgClCtW,EAAOpT,QAAU2qB,G,6BCjLjBh/B,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQmpB,MA4BR,SAAetxB,EAAQmS,GAErB,OADa,IAAIihB,EAAOpzB,EAAQmS,GAClB2f,iBA7BhB3pB,EAAQkrB,WA2CR,SAAoBrzB,EAAQmS,GAC1B,IAAI9X,EAAS,IAAI+4B,EAAOpzB,EAAQmS,GAChC9X,EAAOi5B,YAAYC,EAAW3iB,UAAUC,KACxC,IAAI3a,EAAQmE,EAAOm5B,mBAAkB,GAErC,OADAn5B,EAAOi5B,YAAYC,EAAW3iB,UAAUE,KACjC5a,GA/CTiS,EAAQsrB,UA6DR,SAAmBzzB,EAAQmS,GACzB,IAAI9X,EAAS,IAAI+4B,EAAOpzB,EAAQmS,GAChC9X,EAAOi5B,YAAYC,EAAW3iB,UAAUC,KACxC,IAAI5W,EAAOI,EAAOq5B,qBAElB,OADAr5B,EAAOi5B,YAAYC,EAAW3iB,UAAUE,KACjC7W,GAhET,IAAI2P,EAAW+pB,EAAuBnpB,EAAQ,KAE1CopB,EAAaD,EAAuBnpB,EAAQ,KAE5CqpB,EAAgBF,EAAuBnpB,EAAQ,KAE/CspB,EAAetpB,EAAQ,IAEvBupB,EAASvpB,EAAQ,IAEjBwpB,EAAUxpB,EAAQ,IAElBypB,EAASzpB,EAAQ,IAEjB0pB,EAAqB1pB,EAAQ,IAE7B+oB,EAAa/oB,EAAQ,IAEzB,SAASmpB,EAAuB93B,GAAO,OAAOA,GAAOA,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,GAiDvF,IAAIu3B,EAEJ,WACE,SAASA,EAAOpzB,EAAQmS,GACtB,IAAIgiB,EAA8B,iBAAXn0B,EAAsB,IAAIg0B,EAAQI,OAAOp0B,GAAUA,EAC1Em0B,aAAqBH,EAAQI,SAAU,EAAIR,EAAW/pB,SAAS,EAAG,kCAAkC0D,QAAO,EAAI3D,EAASC,SAASsqB,KACjI7/B,KAAK2/B,QAAS,EAAIA,EAAOI,aAAaF,GACtC7/B,KAAKggC,SAAWniB,GAAW,GAO7B,IAAIoiB,EAASnB,EAAO5+B,UAy5CpB,OAv5CA+/B,EAAOC,UAAY,WACjB,IAAIC,EAAQngC,KAAKg/B,YAAYC,EAAW3iB,UAAUiB,MAClD,MAAO,CACL/W,KAAMi5B,EAAOW,KAAK7iB,KAClB3b,MAAOu+B,EAAMv+B,MACbk8B,IAAK99B,KAAK89B,IAAIqC,KASlBF,EAAOzC,cAAgB,WACrB,IAAIa,EAAQr+B,KAAK2/B,OAAOQ,MACxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAKC,SAClBh6B,YAAarG,KAAKsgC,KAAKrB,EAAW3iB,UAAUC,IAAKvc,KAAKugC,gBAAiBtB,EAAW3iB,UAAUE,KAC5FshB,IAAK99B,KAAK89B,IAAIO,KAelB4B,EAAOM,gBAAkB,WACvB,GAAIvgC,KAAKwgC,KAAKvB,EAAW3iB,UAAUiB,MACjC,OAAQvd,KAAK2/B,OAAOQ,MAAMv+B,OACxB,IAAK,QACL,IAAK,WACL,IAAK,eACH,OAAO5B,KAAKygC,2BAEd,IAAK,WACH,OAAOzgC,KAAK0gC,0BAEd,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,YACL,IAAK,QACL,IAAK,OACL,IAAK,QACL,IAAK,YACH,OAAO1gC,KAAK2gC,4BAEd,IAAK,SACH,OAAO3gC,KAAK4gC,+BAEX,IAAI5gC,KAAKwgC,KAAKvB,EAAW3iB,UAAUc,SACxC,OAAOpd,KAAKygC,2BACP,GAAIzgC,KAAK6gC,kBACd,OAAO7gC,KAAK2gC,4BAGd,MAAM3gC,KAAK8gC,cAUbb,EAAOQ,yBAA2B,WAChC,IAAIpC,EAAQr+B,KAAK2/B,OAAOQ,MAExB,GAAIngC,KAAKwgC,KAAKvB,EAAW3iB,UAAUc,SACjC,MAAO,CACL5W,KAAMi5B,EAAOW,KAAKW,qBAClBr6B,UAAW,QACX3C,UAAMgG,EACN0C,oBAAqB,GACrBtE,WAAY,GACZmD,aAActL,KAAKghC,oBACnBlD,IAAK99B,KAAK89B,IAAIO,IAIlB,IACIt6B,EADA2C,EAAY1G,KAAKihC,qBAOrB,OAJIjhC,KAAKwgC,KAAKvB,EAAW3iB,UAAUiB,QACjCxZ,EAAO/D,KAAKkgC,aAGP,CACL15B,KAAMi5B,EAAOW,KAAKW,qBAClBr6B,UAAWA,EACX3C,KAAMA,EACN0I,oBAAqBzM,KAAKkhC,2BAC1B/4B,WAAYnI,KAAKmhC,iBAAgB,GACjC71B,aAActL,KAAKghC,oBACnBlD,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOgB,mBAAqB,WAC1B,IAAIG,EAAiBphC,KAAKg/B,YAAYC,EAAW3iB,UAAUiB,MAE3D,OAAQ6jB,EAAex/B,OACrB,IAAK,QACH,MAAO,QAET,IAAK,WACH,MAAO,WAET,IAAK,eACH,MAAO,eAGX,MAAM5B,KAAK8gC,WAAWM,IAOxBnB,EAAOiB,yBAA2B,WAChC,OAAOlhC,KAAKqhC,aAAapC,EAAW3iB,UAAUM,QAAS5c,KAAKshC,wBAAyBrC,EAAW3iB,UAAUO,UAO5GojB,EAAOqB,wBAA0B,WAC/B,IAAIjD,EAAQr+B,KAAK2/B,OAAOQ,MACxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAKmB,oBAClB30B,SAAU5M,KAAKwhC,gBACf77B,MAAO3F,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OAAQ/c,KAAKo/B,sBAC1DzyB,aAAc3M,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUU,QAAUhd,KAAKk/B,mBAAkB,QAAQn1B,EACrG5B,WAAYnI,KAAKmhC,iBAAgB,GACjCrD,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOuB,cAAgB,WACrB,IAAInD,EAAQr+B,KAAK2/B,OAAOQ,MAExB,OADAngC,KAAKg/B,YAAYC,EAAW3iB,UAAUI,QAC/B,CACLlW,KAAMi5B,EAAOW,KAAKsB,SAClB39B,KAAM/D,KAAKkgC,YACXpC,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOe,kBAAoB,WACzB,IAAI3C,EAAQr+B,KAAK2/B,OAAOQ,MACxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAKuB,cAClBp2B,WAAYvL,KAAKsgC,KAAKrB,EAAW3iB,UAAUc,QAASpd,KAAK4hC,eAAgB3C,EAAW3iB,UAAUgB,SAC9FwgB,IAAK99B,KAAK89B,IAAIO,KAWlB4B,EAAO2B,eAAiB,WACtB,OAAO5hC,KAAKwgC,KAAKvB,EAAW3iB,UAAUQ,QAAU9c,KAAK6hC,gBAAkB7hC,KAAK8hC,cAS9E7B,EAAO6B,WAAa,WAClB,IAEI14B,EACArF,EAHAs6B,EAAQr+B,KAAK2/B,OAAOQ,MACpB4B,EAAc/hC,KAAKkgC,YAWvB,OAPIlgC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUS,QAChD3T,EAAQ24B,EACRh+B,EAAO/D,KAAKkgC,aAEZn8B,EAAOg+B,EAGF,CACLv7B,KAAMi5B,EAAOW,KAAK4B,MAClB54B,MAAOA,EACPrF,KAAMA,EACNrD,UAAWV,KAAKiiC,gBAAe,GAC/B95B,WAAYnI,KAAKmhC,iBAAgB,GACjC71B,aAActL,KAAKwgC,KAAKvB,EAAW3iB,UAAUc,SAAWpd,KAAKghC,yBAAsBj3B,EACnF+zB,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOgC,eAAiB,SAAwBC,GAC9C,IAAI5Q,EAAO4Q,EAAUliC,KAAKmiC,mBAAqBniC,KAAKoiC,cACpD,OAAOpiC,KAAKqhC,aAAapC,EAAW3iB,UAAUM,QAAS0U,EAAM2N,EAAW3iB,UAAUO,UAOpFojB,EAAOmC,cAAgB,WACrB,IAAI/D,EAAQr+B,KAAK2/B,OAAOQ,MACpBp8B,EAAO/D,KAAKkgC,YAEhB,OADAlgC,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OAC/B,CACLvW,KAAMi5B,EAAOW,KAAKiC,SAClBt+B,KAAMA,EACNnC,MAAO5B,KAAKk/B,mBAAkB,GAC9BpB,IAAK99B,KAAK89B,IAAIO,KAIlB4B,EAAOkC,mBAAqB,WAC1B,IAAI9D,EAAQr+B,KAAK2/B,OAAOQ,MACxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAKiC,SAClBt+B,KAAM/D,KAAKkgC,YACXt+B,OAAQ5B,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OAAQ/c,KAAKk/B,mBAAkB,IAC7EpB,IAAK99B,KAAK89B,IAAIO,KAalB4B,EAAO4B,cAAgB,WACrB,IAAIxD,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAKg/B,YAAYC,EAAW3iB,UAAUQ,QACtC,IAAIwlB,EAAmBtiC,KAAKuiC,sBAAsB,MAElD,OAAKD,GAAoBtiC,KAAKwgC,KAAKvB,EAAW3iB,UAAUiB,MAC/C,CACL/W,KAAMi5B,EAAOW,KAAKoC,gBAClBz+B,KAAM/D,KAAKyiC,oBACXt6B,WAAYnI,KAAKmhC,iBAAgB,GACjCrD,IAAK99B,KAAK89B,IAAIO,IAIX,CACL73B,KAAMi5B,EAAOW,KAAKsC,gBAClB9R,cAAe0R,EAAmBtiC,KAAK2iC,sBAAmB54B,EAC1D5B,WAAYnI,KAAKmhC,iBAAgB,GACjC71B,aAActL,KAAKghC,oBACnBlD,IAAK99B,KAAK89B,IAAIO,KAWlB4B,EAAOS,wBAA0B,WAC/B,IAAIrC,EAAQr+B,KAAK2/B,OAAOQ,MAKxB,OAJAngC,KAAK4iC,cAAc,YAIf5iC,KAAKggC,SAASzC,8BACT,CACL/2B,KAAMi5B,EAAOW,KAAKyC,oBAClB9+B,KAAM/D,KAAKyiC,oBACXh2B,oBAAqBzM,KAAKkhC,2BAC1BtQ,eAAgB5wB,KAAK4iC,cAAc,MAAO5iC,KAAK2iC,kBAC/Cx6B,WAAYnI,KAAKmhC,iBAAgB,GACjC71B,aAActL,KAAKghC,oBACnBlD,IAAK99B,KAAK89B,IAAIO,IAIX,CACL73B,KAAMi5B,EAAOW,KAAKyC,oBAClB9+B,KAAM/D,KAAKyiC,oBACX7R,eAAgB5wB,KAAK4iC,cAAc,MAAO5iC,KAAK2iC,kBAC/Cx6B,WAAYnI,KAAKmhC,iBAAgB,GACjC71B,aAActL,KAAKghC,oBACnBlD,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOwC,kBAAoB,WACzB,GAAgC,OAA5BziC,KAAK2/B,OAAOQ,MAAMv+B,MACpB,MAAM5B,KAAK8gC,aAGb,OAAO9gC,KAAKkgC,aAuBdD,EAAOf,kBAAoB,SAA2BgD,GACpD,IAAI/B,EAAQngC,KAAK2/B,OAAOQ,MAExB,OAAQA,EAAM35B,MACZ,KAAKy4B,EAAW3iB,UAAUY,UACxB,OAAOld,KAAK8iC,UAAUZ,GAExB,KAAKjD,EAAW3iB,UAAUc,QACxB,OAAOpd,KAAK+iC,YAAYb,GAE1B,KAAKjD,EAAW3iB,UAAUkB,IAGxB,OAFAxd,KAAK2/B,OAAOqD,UAEL,CACLx8B,KAAMi5B,EAAOW,KAAK5iB,IAClB5b,MAAOu+B,EAAMv+B,MACbk8B,IAAK99B,KAAK89B,IAAIqC,IAGlB,KAAKlB,EAAW3iB,UAAUmB,MAGxB,OAFAzd,KAAK2/B,OAAOqD,UAEL,CACLx8B,KAAMi5B,EAAOW,KAAK3iB,MAClB7b,MAAOu+B,EAAMv+B,MACbk8B,IAAK99B,KAAK89B,IAAIqC,IAGlB,KAAKlB,EAAW3iB,UAAUoB,OAC1B,KAAKuhB,EAAW3iB,UAAUqB,aACxB,OAAO3d,KAAKijC,qBAEd,KAAKhE,EAAW3iB,UAAUiB,KACxB,MAAoB,SAAhB4iB,EAAMv+B,OAAoC,UAAhBu+B,EAAMv+B,OAClC5B,KAAK2/B,OAAOqD,UAEL,CACLx8B,KAAMi5B,EAAOW,KAAK8C,QAClBthC,MAAuB,SAAhBu+B,EAAMv+B,MACbk8B,IAAK99B,KAAK89B,IAAIqC,KAES,SAAhBA,EAAMv+B,OACf5B,KAAK2/B,OAAOqD,UAEL,CACLx8B,KAAMi5B,EAAOW,KAAK+C,KAClBrF,IAAK99B,KAAK89B,IAAIqC,MAIlBngC,KAAK2/B,OAAOqD,UAEL,CACLx8B,KAAMi5B,EAAOW,KAAKgD,KAClBxhC,MAAOu+B,EAAMv+B,MACbk8B,IAAK99B,KAAK89B,IAAIqC,KAGlB,KAAKlB,EAAW3iB,UAAUI,OACxB,IAAKwlB,EACH,OAAOliC,KAAKwhC,gBAMlB,MAAMxhC,KAAK8gC,cAGbb,EAAOgD,mBAAqB,WAC1B,IAAI9C,EAAQngC,KAAK2/B,OAAOQ,MAIxB,OAFAngC,KAAK2/B,OAAOqD,UAEL,CACLx8B,KAAMi5B,EAAOW,KAAK1iB,OAClB9b,MAAOu+B,EAAMv+B,MACbyhC,MAAOlD,EAAM35B,OAASy4B,EAAW3iB,UAAUqB,aAC3CmgB,IAAK99B,KAAK89B,IAAIqC,KAUlBF,EAAO6C,UAAY,SAAmBZ,GACpC,IAAIoB,EAAQtjC,KAERq+B,EAAQr+B,KAAK2/B,OAAOQ,MAMxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAKmD,KAClB57B,OAAQ3H,KAAKwjC,IAAIvE,EAAW3iB,UAAUY,WAN7B,WACT,OAAOomB,EAAMpE,kBAAkBgD,KAKwBjD,EAAW3iB,UAAUa,WAC5E2gB,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAO8C,YAAc,SAAqBb,GACxC,IAAIuB,EAASzjC,KAETq+B,EAAQr+B,KAAK2/B,OAAOQ,MAMxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAKsD,OAClBr8B,OAAQrH,KAAKwjC,IAAIvE,EAAW3iB,UAAUc,SAN7B,WACT,OAAOqmB,EAAOE,iBAAiBzB,KAKsBjD,EAAW3iB,UAAUgB,SAC1EwgB,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAO0D,iBAAmB,SAA0BzB,GAClD,IAAI7D,EAAQr+B,KAAK2/B,OAAOQ,MACpBp8B,EAAO/D,KAAKkgC,YAEhB,OADAlgC,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OAC/B,CACLvW,KAAMi5B,EAAOW,KAAKwD,aAClB7/B,KAAMA,EACNnC,MAAO5B,KAAKk/B,kBAAkBgD,GAC9BpE,IAAK99B,KAAK89B,IAAIO,KASlB4B,EAAOkB,gBAAkB,SAAyBe,GAGhD,IAFA,IAAI/5B,EAAa,GAEVnI,KAAKwgC,KAAKvB,EAAW3iB,UAAUW,KACpC9U,EAAW/E,KAAKpD,KAAK6jC,eAAe3B,IAGtC,OAAO/5B,GAOT83B,EAAO4D,eAAiB,SAAwB3B,GAC9C,IAAI7D,EAAQr+B,KAAK2/B,OAAOQ,MAExB,OADAngC,KAAKg/B,YAAYC,EAAW3iB,UAAUW,IAC/B,CACLzW,KAAMi5B,EAAOW,KAAK0D,UAClB//B,KAAM/D,KAAKkgC,YACXx/B,UAAWV,KAAKiiC,eAAeC,GAC/BpE,IAAK99B,KAAK89B,IAAIO,KAYlB4B,EAAOb,mBAAqB,WAC1B,IACIz5B,EADA04B,EAAQr+B,KAAK2/B,OAAOQ,MAexB,OAZIngC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUY,YAChDvX,EAAO3F,KAAKo/B,qBACZp/B,KAAKg/B,YAAYC,EAAW3iB,UAAUa,WACtCxX,EAAO,CACLa,KAAMi5B,EAAOW,KAAK2D,UAClBp+B,KAAMA,EACNm4B,IAAK99B,KAAK89B,IAAIO,KAGhB14B,EAAO3F,KAAK2iC,iBAGV3iC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUG,MACzC,CACLjW,KAAMi5B,EAAOW,KAAK4D,cAClBr+B,KAAMA,EACNm4B,IAAK99B,KAAK89B,IAAIO,IAIX14B,GAOTs6B,EAAO0C,eAAiB,WACtB,IAAItE,EAAQr+B,KAAK2/B,OAAOQ,MACxB,MAAO,CACL35B,KAAMi5B,EAAOW,KAAK6D,WAClBlgC,KAAM/D,KAAKkgC,YACXpC,IAAK99B,KAAK89B,IAAIO,KAoBlB4B,EAAOU,0BAA4B,WAEjC,IAAIuD,EAAelkC,KAAK6gC,kBAAoB7gC,KAAK2/B,OAAOwE,YAAcnkC,KAAK2/B,OAAOQ,MAElF,GAAI+D,EAAa19B,OAASy4B,EAAW3iB,UAAUiB,KAC7C,OAAQ2mB,EAAatiC,OACnB,IAAK,SACH,OAAO5B,KAAKokC,wBAEd,IAAK,SACH,OAAOpkC,KAAKqkC,4BAEd,IAAK,OACH,OAAOrkC,KAAKskC,4BAEd,IAAK,YACH,OAAOtkC,KAAKukC,+BAEd,IAAK,QACH,OAAOvkC,KAAKwkC,2BAEd,IAAK,OACH,OAAOxkC,KAAKykC,0BAEd,IAAK,QACH,OAAOzkC,KAAK0kC,iCAEd,IAAK,YACH,OAAO1kC,KAAK2kC,2BAIlB,MAAM3kC,KAAK8gC,WAAWoD,IAGxBjE,EAAOY,gBAAkB,WACvB,OAAO7gC,KAAKwgC,KAAKvB,EAAW3iB,UAAUoB,SAAW1d,KAAKwgC,KAAKvB,EAAW3iB,UAAUqB,eAOlFsiB,EAAO2E,iBAAmB,WACxB,GAAI5kC,KAAK6gC,kBACP,OAAO7gC,KAAKijC,sBAQhBhD,EAAOmE,sBAAwB,WAC7B,IAAI/F,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB,IAAIz6B,EAAanI,KAAKmhC,iBAAgB,GAClC0D,EAAiB7kC,KAAKsgC,KAAKrB,EAAW3iB,UAAUc,QAASpd,KAAK8kC,6BAA8B7F,EAAW3iB,UAAUgB,SACrH,MAAO,CACL9W,KAAMi5B,EAAOW,KAAK2E,kBAClB58B,WAAYA,EACZ08B,eAAgBA,EAChB/G,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAO6E,6BAA+B,WACpC,IAAIzG,EAAQr+B,KAAK2/B,OAAOQ,MACpBz5B,EAAY1G,KAAKihC,qBACrBjhC,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OACtC,IAAIpX,EAAO3F,KAAK2iC,iBAChB,MAAO,CACLn8B,KAAMi5B,EAAOW,KAAK4E,0BAClBt+B,UAAWA,EACXf,KAAMA,EACNm4B,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOoE,0BAA4B,WACjC,IAAIhG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,UACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GACtC,MAAO,CACL36B,KAAMi5B,EAAOW,KAAK6E,uBAClBtqB,YAAaA,EACb5W,KAAMA,EACNoE,WAAYA,EACZ21B,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAOqE,0BAA4B,WACjC,IAAIjG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,QACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZgF,EAAallC,KAAKmlC,4BAClBh9B,EAAanI,KAAKmhC,iBAAgB,GAClC95B,EAASrH,KAAKolC,wBAClB,MAAO,CACL5+B,KAAMi5B,EAAOW,KAAKiF,uBAClB1qB,YAAaA,EACb5W,KAAMA,EACNmhC,WAAYA,EACZ/8B,WAAYA,EACZd,OAAQA,EACRy2B,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAOkF,0BAA4B,WACjC,IAAIG,EAAQ,GAEZ,GAAItlC,KAAKuiC,sBAAsB,cAAe,CAE5CviC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUK,KAE9C,GACE2oB,EAAMliC,KAAKpD,KAAK2iC,wBACT3iC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUK,MACvD3c,KAAKggC,SAASuF,oCAAsCvlC,KAAKwgC,KAAKvB,EAAW3iB,UAAUiB,OAGrF,OAAO+nB,GAOTrF,EAAOmF,sBAAwB,WAE7B,OAAIplC,KAAKggC,SAASwF,2BAA6BxlC,KAAKwgC,KAAKvB,EAAW3iB,UAAUc,UAAYpd,KAAK2/B,OAAOwE,YAAY39B,OAASy4B,EAAW3iB,UAAUgB,SAC9Itd,KAAK2/B,OAAOqD,UAEZhjC,KAAK2/B,OAAOqD,UAEL,IAGFhjC,KAAKqhC,aAAapC,EAAW3iB,UAAUc,QAASpd,KAAKylC,qBAAsBxG,EAAW3iB,UAAUgB,UAQzG2iB,EAAOwF,qBAAuB,WAC5B,IAAIpH,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACnB7gC,EAAO/D,KAAKkgC,YACZz3B,EAAOzI,KAAK0lC,oBAChB1lC,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OACtC,IAAIpX,EAAO3F,KAAKo/B,qBACZj3B,EAAanI,KAAKmhC,iBAAgB,GACtC,MAAO,CACL36B,KAAMi5B,EAAOW,KAAKuF,iBAClBhrB,YAAaA,EACb5W,KAAMA,EACNrD,UAAW+H,EACX9C,KAAMA,EACNwC,WAAYA,EACZ21B,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOyF,kBAAoB,WACzB,OAAO1lC,KAAKqhC,aAAapC,EAAW3iB,UAAUM,QAAS5c,KAAK4lC,mBAAoB3G,EAAW3iB,UAAUO,UAQvGojB,EAAO2F,mBAAqB,WAC1B,IAAIvH,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACnB7gC,EAAO/D,KAAKkgC,YAChBlgC,KAAKg/B,YAAYC,EAAW3iB,UAAUS,OACtC,IACIpQ,EADAhH,EAAO3F,KAAKo/B,qBAGZp/B,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUU,UAChDrQ,EAAe3M,KAAKk/B,mBAAkB,IAGxC,IAAI/2B,EAAanI,KAAKmhC,iBAAgB,GACtC,MAAO,CACL36B,KAAMi5B,EAAOW,KAAKyF,uBAClBlrB,YAAaA,EACb5W,KAAMA,EACN4B,KAAMA,EACNgH,aAAcA,EACdxE,WAAYA,EACZ21B,IAAK99B,KAAK89B,IAAIO,KASlB4B,EAAOsE,6BAA+B,WACpC,IAAIlG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,aACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClC95B,EAASrH,KAAKolC,wBAClB,MAAO,CACL5+B,KAAMi5B,EAAOW,KAAK0F,0BAClBnrB,YAAaA,EACb5W,KAAMA,EACNoE,WAAYA,EACZd,OAAQA,EACRy2B,IAAK99B,KAAK89B,IAAIO,KASlB4B,EAAOuE,yBAA2B,WAChC,IAAInG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,SACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClCmE,EAAQtlC,KAAK+lC,wBACjB,MAAO,CACLv/B,KAAMi5B,EAAOW,KAAK4F,sBAClBrrB,YAAaA,EACb5W,KAAMA,EACNoE,WAAYA,EACZm9B,MAAOA,EACPxH,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAO8F,sBAAwB,WAC7B,IAAIT,EAAQ,GAEZ,GAAItlC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUU,QAAS,CAEzDhd,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUe,MAE9C,GACEioB,EAAMliC,KAAKpD,KAAK2iC,wBACT3iC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUe,OAGzD,OAAOioB,GAQTrF,EAAOwE,wBAA0B,WAC/B,IAAIpG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,QACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClCx5B,EAAS3H,KAAKimC,4BAClB,MAAO,CACLz/B,KAAMi5B,EAAOW,KAAK8F,qBAClBvrB,YAAaA,EACb5W,KAAMA,EACNoE,WAAYA,EACZR,OAAQA,EACRm2B,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOgG,0BAA4B,WACjC,OAAOjmC,KAAKqhC,aAAapC,EAAW3iB,UAAUc,QAASpd,KAAKmmC,yBAA0BlH,EAAW3iB,UAAUgB,UAS7G2iB,EAAOkG,yBAA2B,WAChC,IAAI9H,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACnB7gC,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GACtC,MAAO,CACL36B,KAAMi5B,EAAOW,KAAKgG,sBAClBzrB,YAAaA,EACb5W,KAAMA,EACNoE,WAAYA,EACZ21B,IAAK99B,KAAK89B,IAAIO,KASlB4B,EAAOyE,+BAAiC,WACtC,IAAIrG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,SACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClC95B,EAASrH,KAAKqmC,6BAClB,MAAO,CACL7/B,KAAMi5B,EAAOW,KAAKkG,6BAClB3rB,YAAaA,EACb5W,KAAMA,EACNoE,WAAYA,EACZd,OAAQA,EACRy2B,IAAK99B,KAAK89B,IAAIO,KAQlB4B,EAAOoG,2BAA6B,WAClC,OAAOrmC,KAAKqhC,aAAapC,EAAW3iB,UAAUc,QAASpd,KAAK4lC,mBAAoB3G,EAAW3iB,UAAUgB,UAiBvG2iB,EAAOW,yBAA2B,WAChC,IAAIsD,EAAelkC,KAAK2/B,OAAOwE,YAE/B,GAAID,EAAa19B,OAASy4B,EAAW3iB,UAAUiB,KAC7C,OAAQ2mB,EAAatiC,OACnB,IAAK,SACH,OAAO5B,KAAKumC,uBAEd,IAAK,SACH,OAAOvmC,KAAKwmC,2BAEd,IAAK,OACH,OAAOxmC,KAAKymC,2BAEd,IAAK,YACH,OAAOzmC,KAAK0mC,8BAEd,IAAK,QACH,OAAO1mC,KAAK2mC,0BAEd,IAAK,OACH,OAAO3mC,KAAK4mC,yBAEd,IAAK,QACH,OAAO5mC,KAAK6mC,gCAIlB,MAAM7mC,KAAK8gC,WAAWoD,IASxBjE,EAAOsG,qBAAuB,WAC5B,IAAIlI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,UACnB,IAAIz6B,EAAanI,KAAKmhC,iBAAgB,GAClC0D,EAAiB7kC,KAAKqhC,aAAapC,EAAW3iB,UAAUc,QAASpd,KAAK8kC,6BAA8B7F,EAAW3iB,UAAUgB,SAE7H,GAA0B,IAAtBnV,EAAWxH,QAA0C,IAA1BkkC,EAAelkC,OAC5C,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAK0G,iBAClB3+B,WAAYA,EACZ08B,eAAgBA,EAChB/G,IAAK99B,KAAK89B,IAAIO,KASlB4B,EAAOuG,yBAA2B,WAChC,IAAInI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,UACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAEtC,GAA0B,IAAtBh5B,EAAWxH,OACb,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAK2G,sBAClBhjC,KAAMA,EACNoE,WAAYA,EACZ21B,IAAK99B,KAAK89B,IAAIO,KAWlB4B,EAAOwG,yBAA2B,WAChC,IAAIpI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,QACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZgF,EAAallC,KAAKmlC,4BAClBh9B,EAAanI,KAAKmhC,iBAAgB,GAClC95B,EAASrH,KAAKolC,wBAElB,GAA0B,IAAtBF,EAAWvkC,QAAsC,IAAtBwH,EAAWxH,QAAkC,IAAlB0G,EAAO1G,OAC/D,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAK4G,sBAClBjjC,KAAMA,EACNmhC,WAAYA,EACZ/8B,WAAYA,EACZd,OAAQA,EACRy2B,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAOyG,4BAA8B,WACnC,IAAIrI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,aACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClC95B,EAASrH,KAAKolC,wBAElB,GAA0B,IAAtBj9B,EAAWxH,QAAkC,IAAlB0G,EAAO1G,OACpC,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAK6G,yBAClBljC,KAAMA,EACNoE,WAAYA,EACZd,OAAQA,EACRy2B,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAO0G,wBAA0B,WAC/B,IAAItI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,SACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClCmE,EAAQtlC,KAAK+lC,wBAEjB,GAA0B,IAAtB59B,EAAWxH,QAAiC,IAAjB2kC,EAAM3kC,OACnC,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAK8G,qBAClBnjC,KAAMA,EACNoE,WAAYA,EACZm9B,MAAOA,EACPxH,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAO2G,uBAAyB,WAC9B,IAAIvI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,QACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClCx5B,EAAS3H,KAAKimC,4BAElB,GAA0B,IAAtB99B,EAAWxH,QAAkC,IAAlBgH,EAAOhH,OACpC,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAK+G,oBAClBpjC,KAAMA,EACNoE,WAAYA,EACZR,OAAQA,EACRm2B,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAO4G,8BAAgC,WACrC,IAAIxI,EAAQr+B,KAAK2/B,OAAOQ,MACxBngC,KAAK4iC,cAAc,UACnB5iC,KAAK4iC,cAAc,SACnB,IAAI7+B,EAAO/D,KAAKkgC,YACZ/3B,EAAanI,KAAKmhC,iBAAgB,GAClC95B,EAASrH,KAAKqmC,6BAElB,GAA0B,IAAtBl+B,EAAWxH,QAAkC,IAAlB0G,EAAO1G,OACpC,MAAMX,KAAK8gC,aAGb,MAAO,CACLt6B,KAAMi5B,EAAOW,KAAKgH,4BAClBrjC,KAAMA,EACNoE,WAAYA,EACZd,OAAQA,EACRy2B,IAAK99B,KAAK89B,IAAIO,KASlB4B,EAAO0E,yBAA2B,WAChC,IAAItG,EAAQr+B,KAAK2/B,OAAOQ,MACpBxlB,EAAc3a,KAAK4kC,mBACvB5kC,KAAK4iC,cAAc,aACnB5iC,KAAKg/B,YAAYC,EAAW3iB,UAAUW,IACtC,IAAIlZ,EAAO/D,KAAKkgC,YACZz3B,EAAOzI,KAAK0lC,oBACZ2B,EAAarnC,KAAKuiC,sBAAsB,cAC5CviC,KAAK4iC,cAAc,MACnB,IAAI0E,EAAYtnC,KAAKunC,0BACrB,MAAO,CACL/gC,KAAMi5B,EAAOW,KAAKoH,qBAClB7sB,YAAaA,EACb5W,KAAMA,EACNrD,UAAW+H,EACX4+B,WAAYA,EACZC,UAAWA,EACXxJ,IAAK99B,KAAK89B,IAAIO,KAUlB4B,EAAOsH,wBAA0B,WAE/BvnC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUe,MAC9C,IAAIiqB,EAAY,GAEhB,GACEA,EAAUlkC,KAAKpD,KAAKynC,gCACbznC,KAAKyhC,oBAAoBxC,EAAW3iB,UAAUe,OAEvD,OAAOiqB,GA+BTrH,EAAOwH,uBAAyB,WAC9B,IAAIpJ,EAAQr+B,KAAK2/B,OAAOQ,MACpBp8B,EAAO/D,KAAKkgC,YAEhB,QAAyDn2B,IAArD61B,EAAmB8H,kBAAkB3jC,EAAKnC,OAC5C,OAAOmC,EAGT,MAAM/D,KAAK8gC,WAAWzC,IASxB4B,EAAOnC,IAAM,SAAaC,GACxB,IAAK/9B,KAAKggC,SAAS2H,WACjB,OAAO,IAAIC,EAAI7J,EAAY/9B,KAAK2/B,OAAOkI,UAAW7nC,KAAK2/B,OAAOj0B,SAQlEu0B,EAAOO,KAAO,SAAch6B,GAC1B,OAAOxG,KAAK2/B,OAAOQ,MAAM35B,OAASA,GAQpCy5B,EAAOjB,YAAc,SAAqBx4B,GACxC,IAAI25B,EAAQngC,KAAK2/B,OAAOQ,MAExB,GAAIA,EAAM35B,OAASA,EAGjB,OAFAxG,KAAK2/B,OAAOqD,UAEL7C,EAGT,MAAM,EAAIX,EAAa/kB,aAAaza,KAAK2/B,OAAOj0B,OAAQy0B,EAAM9B,MAAO,YAAYplB,OAAOzS,EAAM,YAAYyS,OAAO6uB,EAAa3H,MAQhIF,EAAOwB,oBAAsB,SAA6Bj7B,GACxD,IAAI25B,EAAQngC,KAAK2/B,OAAOQ,MAExB,GAAIA,EAAM35B,OAASA,EAGjB,OAFAxG,KAAK2/B,OAAOqD,UAEL7C,GAWXF,EAAO2C,cAAgB,SAAuBhhC,GAC5C,IAAIu+B,EAAQngC,KAAK2/B,OAAOQ,MAExB,GAAIA,EAAM35B,OAASy4B,EAAW3iB,UAAUiB,MAAQ4iB,EAAMv+B,QAAUA,EAG9D,MAAM,EAAI49B,EAAa/kB,aAAaza,KAAK2/B,OAAOj0B,OAAQy0B,EAAM9B,MAAO,aAAcplB,OAAOrX,EAAO,aAAcqX,OAAO6uB,EAAa3H,KAFnIngC,KAAK2/B,OAAOqD,WAWhB/C,EAAOsC,sBAAwB,SAA+B3gC,GAC5D,IAAIu+B,EAAQngC,KAAK2/B,OAAOQ,MAExB,OAAIA,EAAM35B,OAASy4B,EAAW3iB,UAAUiB,MAAQ4iB,EAAMv+B,QAAUA,IAC9D5B,KAAK2/B,OAAOqD,WAEL,IAWX/C,EAAOa,WAAa,SAAoBiH,GACtC,IAAI5H,EAAQ4H,GAAW/nC,KAAK2/B,OAAOQ,MACnC,OAAO,EAAIX,EAAa/kB,aAAaza,KAAK2/B,OAAOj0B,OAAQy0B,EAAM9B,MAAO,cAAcplB,OAAO6uB,EAAa3H,MAU1GF,EAAOuD,IAAM,SAAawE,EAAUC,EAASC,GAC3CloC,KAAKg/B,YAAYgJ,GAGjB,IAFA,IAAIG,EAAQ,IAEJnoC,KAAKyhC,oBAAoByG,IAC/BC,EAAM/kC,KAAK6kC,EAAQrnC,KAAKZ,OAG1B,OAAOmoC,GAWTlI,EAAOoB,aAAe,SAAsB2G,EAAUC,EAASC,GAC7D,GAAIloC,KAAKyhC,oBAAoBuG,GAAW,CACtC,IAAIG,EAAQ,GAEZ,GACEA,EAAM/kC,KAAK6kC,EAAQrnC,KAAKZ,cAChBA,KAAKyhC,oBAAoByG,IAEnC,OAAOC,EAGT,MAAO,IAUTlI,EAAOK,KAAO,SAAc0H,EAAUC,EAASC,GAC7CloC,KAAKg/B,YAAYgJ,GACjB,IAAIG,EAAQ,GAEZ,GACEA,EAAM/kC,KAAK6kC,EAAQrnC,KAAKZ,cAChBA,KAAKyhC,oBAAoByG,IAEnC,OAAOC,GAGFrJ,EAr6CT,GAw6CA,SAAS8I,EAAI7J,EAAYC,EAAUtyB,GACjC1L,KAAKq+B,MAAQN,EAAWM,MACxBr+B,KAAKs+B,IAAMN,EAASM,IACpBt+B,KAAK+9B,WAAaA,EAClB/9B,KAAKg+B,SAAWA,EAChBh+B,KAAK0L,OAASA,EAchB,SAASo8B,EAAa3H,GACpB,IAAIv+B,EAAQu+B,EAAMv+B,MAClB,OAAOA,EAAQ,GAAGqX,OAAOknB,EAAM35B,KAAM,MAAOyS,OAAOrX,EAAO,KAAQu+B,EAAM35B,MAZ1E,EAAI+4B,EAAchqB,SAASqyB,GAAK,WAC9B,MAAO,CACLvJ,MAAOr+B,KAAKq+B,MACZC,IAAKt+B,KAAKs+B,S,6BChgDd9+B,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQgH,aAAeA,EACvBhH,EAAQu0B,WAAaA,EAErB,IAMgC7gC,EAN5B8gC,GAM4B9gC,EANW2O,EAAQ,MAME3O,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,GAJnF+gC,EAAYpyB,EAAQ,IAEpBqyB,EAAiBryB,EAAQ,IAI7B,SAAS2E,EACTjX,EAASukC,EAAOz8B,EAAQ88B,EAAWj0B,EAAMk0B,EAAe7L,GAEtD,IAAI8L,EAAS/oC,MAAM2S,QAAQ61B,GAA0B,IAAjBA,EAAMxnC,OAAewnC,OAAQp+B,EAAYo+B,EAAQ,CAACA,QAASp+B,EAG3F21B,EAAUh0B,EAEd,IAAKg0B,GAAWgJ,EAAQ,CACtB,IAAI59B,EAAO49B,EAAO,GAClBhJ,EAAU50B,GAAQA,EAAKgzB,KAAOhzB,EAAKgzB,IAAIpyB,OAGzC,IAgBIi9B,EAhBAC,EAAaJ,GAEZI,GAAcF,IACjBE,EAAaF,EAAOvM,QAAO,SAAU0M,EAAM/9B,GAKzC,OAJIA,EAAKgzB,KACP+K,EAAKzlC,KAAK0H,EAAKgzB,IAAIO,OAGdwK,IACN,KAGDD,GAAoC,IAAtBA,EAAWjoC,SAC3BioC,OAAa7+B,GAKXy+B,GAAa98B,EACfi9B,EAAaH,EAAUlhC,KAAI,SAAUwhC,GACnC,OAAO,EAAIR,EAAUxtB,aAAapP,EAAQo9B,MAEnCJ,IACTC,EAAaD,EAAOvM,QAAO,SAAU0M,EAAM/9B,GAKzC,OAJIA,EAAKgzB,KACP+K,EAAKzlC,MAAK,EAAIklC,EAAUxtB,aAAahQ,EAAKgzB,IAAIpyB,OAAQZ,EAAKgzB,IAAIO,QAG1DwK,IACN,KAGL,IAAIE,EAAcnM,EAElB,GAAmB,MAAfmM,GAAwC,MAAjBN,EAAuB,CAChD,IAAIO,EAAqBP,EAAc7L,YAEnC,EAAIyL,EAAc9yB,SAASyzB,KAC7BD,EAAcC,GAIlBxpC,OAAOypC,iBAAiBjpC,KAAM,CAC5B4D,QAAS,CACPhC,MAAOgC,EAIP+3B,YAAY,EACZuN,UAAU,GAEZ5B,UAAW,CAGT1lC,MAAO+mC,QAAc5+B,EAIrB4xB,WAAYnjB,QAAQmwB,IAEtBp0B,KAAM,CAGJ3S,MAAO2S,QAAQxK,EAIf4xB,WAAYnjB,QAAQjE,IAEtB4zB,MAAO,CACLvmC,MAAO8mC,QAAU3+B,GAEnB2B,OAAQ,CACN9J,MAAO89B,QAAW31B,GAEpBy+B,UAAW,CACT5mC,MAAOgnC,QAAc7+B,GAEvB0+B,cAAe,CACb7mC,MAAO6mC,GAET7L,WAAY,CAGVh7B,MAAOmnC,QAAeh/B,EAItB4xB,WAAYnjB,QAAQuwB,MAIpBN,GAAiBA,EAAct0B,MACjC3U,OAAOoU,eAAe5T,KAAM,QAAS,CACnC4B,MAAO6mC,EAAct0B,MACrB+0B,UAAU,EACVC,cAAc,IAEPllC,MAAMmlC,kBACfnlC,MAAMmlC,kBAAkBppC,KAAM6a,GAE9Brb,OAAOoU,eAAe5T,KAAM,QAAS,CACnC4B,MAAOqC,QAAQkQ,MACf+0B,UAAU,EACVC,cAAc,IAuBpB,SAASf,EAAW5jC,GAClB,IAAI6kC,EAAS7kC,EAAMZ,QAEnB,GAAIY,EAAM2jC,MACR,IAAK,IAAItzB,EAAM,EAAGy0B,EAAgB9kC,EAAM2jC,MAAOtzB,EAAMy0B,EAAc3oC,OAAQkU,IAAO,CAChF,IAAI/J,EAAOw+B,EAAcz0B,GAErB/J,EAAKgzB,MACPuL,GAAU,QAAS,EAAId,EAAegB,eAAez+B,EAAKgzB,WAGzD,GAAIt5B,EAAMkH,QAAUlH,EAAM8iC,UAC/B,IAAK,IAAIkC,EAAM,EAAGC,EAAoBjlC,EAAM8iC,UAAWkC,EAAMC,EAAkB9oC,OAAQ6oC,IAAO,CAC5F,IAAIE,EAAWD,EAAkBD,GACjCH,GAAU,QAAS,EAAId,EAAeoB,qBAAqBnlC,EAAMkH,OAAQg+B,GAI7E,OAAOL,EApCTxuB,EAAa3a,UAAYV,OAAOW,OAAO8D,MAAM/D,UAAW,CACtDD,YAAa,CACX2B,MAAOiZ,GAET9W,KAAM,CACJnC,MAAO,gBAETwO,SAAU,CACRxO,MAAO,WACL,OAAOwmC,EAAWpoC,W,6BC5IxB,SAAS+Y,EAAQxR,GAAwT,OAAtOwR,EAArD,mBAAXjW,QAAoD,iBAApBA,OAAOC,SAAmC,SAAiBwE,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,mBAAXzE,QAAyByE,EAAItH,cAAgB6C,QAAUyE,IAAQzE,OAAO5C,UAAY,gBAAkBqH,IAAyBA,GALxV/H,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0B,QAQR,SAAsB3T,GACpB,MAAyB,UAAlBmX,EAAQnX,IAAgC,OAAVA,I,6BCZvCpC,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ01B,cAQR,SAAuBG,GACrB,OAAOC,EAAoBD,EAASh+B,QAAQ,EAAI48B,EAAUxtB,aAAa4uB,EAASh+B,OAAQg+B,EAASrL,SARnGxqB,EAAQ81B,oBAAsBA,EAE9B,IAAIrB,EAAYpyB,EAAQ,IAaxB,SAASyzB,EAAoBj+B,EAAQk+B,GACnC,IAAIC,EAAwBn+B,EAAOo+B,eAAe5uB,OAAS,EACvD9Y,EAAO2nC,EAAWF,GAAyBn+B,EAAOtJ,KAClD4nC,EAAYJ,EAAe3uB,KAAO,EAClCgvB,EAAav+B,EAAOo+B,eAAe7uB,KAAO,EAC1CivB,EAAUN,EAAe3uB,KAAOgvB,EAChCE,EAAuC,IAAxBP,EAAe3uB,KAAa4uB,EAAwB,EACnEO,EAAYR,EAAe1uB,OAASivB,EACpCE,EAAc,GAAGpxB,OAAOvN,EAAO3H,KAAM,KAAKkV,OAAOixB,EAAS,KAAKjxB,OAAOmxB,EAAW,MACjF/uB,EAAQjZ,EAAKyZ,MAAM,gBACnByuB,EAAejvB,EAAM2uB,GAEzB,GAAIM,EAAa3pC,OAAS,IAAK,CAK7B,IAJA,IAAI4pC,EAAe7wB,KAAK8wB,MAAMJ,EAAY,IACtCK,EAAmBL,EAAY,GAC/BM,EAAW,GAENlqC,EAAI,EAAGA,EAAI8pC,EAAa3pC,OAAQH,GAAK,GAC5CkqC,EAAStnC,KAAKknC,EAAa55B,MAAMlQ,EAAGA,EAAI,KAG1C,OAAO6pC,EAAcM,EAAmB,CAAC,CAAC,GAAG1xB,OAAOixB,GAAUQ,EAAS,KAAKzxB,OAAOyxB,EAASh6B,MAAM,EAAG65B,EAAe,GAAGjjC,KAAI,SAAUsjC,GACnI,MAAO,CAAC,GAAIA,MACV,CAAC,CAAC,IAAKb,EAAWU,EAAmB,GAAK,KAAM,CAAC,GAAIC,EAASH,EAAe,OAGnF,OAAOF,EAAcM,EAAmB,CACxC,CAAC,GAAG1xB,OAAOixB,EAAU,GAAI7uB,EAAM2uB,EAAY,IAAK,CAAC,GAAG/wB,OAAOixB,GAAUI,GAAe,CAAC,GAAIP,EAAWK,EAAY,GAAK,KAAM,CAAC,GAAGnxB,OAAOixB,EAAU,GAAI7uB,EAAM2uB,EAAY,MAGxK,SAASW,EAAmBtvB,GAC1B,IAAIwvB,EAAgBxvB,EAAM/U,QAAO,SAAUwkC,GACjCA,EAAK,GAEb,YAAgB/gC,IADL+gC,EAAK,MAGdC,EAASrxB,KAAKsxB,IAAInqC,MAAM6Y,KAAMmxB,EAAcvjC,KAAI,SAAU2jC,GAE5D,OADaA,EAAM,GACLtqC,WAEhB,OAAOkqC,EAAcvjC,KAAI,SAAU4jC,GACjC,IAUezvB,EAVX0vB,EAASD,EAAM,GACfjwB,EAAOiwB,EAAM,GACjB,OASKnB,EATOgB,GAQGtvB,EARK0vB,GASMxqC,QAAU8a,GATLR,EAAO,MAAQA,EAAO,SACpDnB,KAAK,MAGV,SAASiwB,EAAWtwB,GAClB,OAAO9Z,MAAM8Z,EAAM,GAAGK,KAAK,O,6BCnE7Bta,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQusB,UAAO,EAKf,IAAIA,EAAO5gC,OAAO+R,OAAO,CAEvBgM,KAAM,OAEN8iB,SAAU,WACVU,qBAAsB,sBACtBQ,oBAAqB,qBACrBI,cAAe,eACfK,MAAO,QACPK,SAAU,WAEVG,gBAAiB,iBACjBE,gBAAiB,iBACjBG,oBAAqB,qBAErBnB,SAAU,WACVlkB,IAAK,WACLC,MAAO,aACPC,OAAQ,cACRwlB,QAAS,eACTC,KAAM,YACNC,KAAM,YACNG,KAAM,YACNG,OAAQ,cACRE,aAAc,cAEdE,UAAW,YAEXG,WAAY,YACZF,UAAW,WACXC,cAAe,cAEfe,kBAAmB,mBACnBC,0BAA2B,0BAE3BC,uBAAwB,uBACxBI,uBAAwB,uBACxBM,iBAAkB,kBAClBE,uBAAwB,uBACxBC,0BAA2B,0BAC3BE,sBAAuB,sBACvBE,qBAAsB,qBACtBE,sBAAuB,sBACvBE,6BAA8B,4BAE9BkB,qBAAsB,sBAEtBV,iBAAkB,kBAElBC,sBAAuB,sBACvBC,sBAAuB,sBACvBC,yBAA0B,yBAC1BC,qBAAsB,qBACtBC,oBAAqB,oBACrBC,4BAA6B,6BAM/BvzB,EAAQusB,KAAOA,G,6BCpEf5gC,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQisB,YAAS,EAEjB,IAAIR,EAAaD,EAAuBnpB,EAAQ,KAE5Ck1B,EAAqB/L,EAAuBnpB,EAAQ,KAExD,SAASmpB,EAAuB93B,GAAO,OAAOA,GAAOA,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,GAUvF,IAAIu4B,EAAS,SAAgB19B,EAAM2B,EAAM+lC,GACvC9pC,KAAKoC,KAAOA,EACZpC,KAAK+D,KAAOA,GAAQ,kBACpB/D,KAAK8pC,eAAiBA,GAAkB,CACtC7uB,KAAM,EACNC,OAAQ,GAEVlb,KAAK8pC,eAAe7uB,KAAO,IAAK,EAAIqkB,EAAW/pB,SAAS,EAAG,4DAC3DvV,KAAK8pC,eAAe5uB,OAAS,IAAK,EAAIokB,EAAW/pB,SAAS,EAAG,+DAI/D1B,EAAQisB,OAASA,GACjB,EAAIsL,EAAmB71B,SAASuqB,I,6BChChCtgC,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0B,QAeR,SAA2BgF,GACH,mBAAXzX,QAAyBA,OAAOuoC,aACzC7rC,OAAOoU,eAAe2G,EAAYra,UAAW4C,OAAOuoC,YAAa,CAC/DllC,IAAK,WACH,OAAOnG,KAAKC,YAAY8D,U,6BCtBhCvE,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQksB,YAqBR,SAAqBr0B,EAAQmS,GAC3B,IAAIytB,EAAmB,IAAIC,EAAItM,EAAW3iB,UAAUC,IAAK,EAAG,EAAG,EAAG,EAAG,MAWrE,MAVY,CACV7Q,OAAQA,EACRmS,QAASA,EACTgqB,UAAWyD,EACXnL,MAAOmL,EACPrwB,KAAM,EACNuwB,UAAW,EACXxI,QAASyI,EACTtH,UAAWA,IA9BftwB,EAAQ63B,kBA2DR,SAA2BvL,GACzB,IAAI35B,EAAO25B,EAAM35B,KACjB,OAAOA,IAASy4B,EAAW3iB,UAAUG,MAAQjW,IAASy4B,EAAW3iB,UAAUI,QAAUlW,IAASy4B,EAAW3iB,UAAUK,KAAOnW,IAASy4B,EAAW3iB,UAAUM,SAAWpW,IAASy4B,EAAW3iB,UAAUO,SAAWrW,IAASy4B,EAAW3iB,UAAUQ,QAAUtW,IAASy4B,EAAW3iB,UAAUS,OAASvW,IAASy4B,EAAW3iB,UAAUU,QAAUxW,IAASy4B,EAAW3iB,UAAUW,IAAMzW,IAASy4B,EAAW3iB,UAAUY,WAAa1W,IAASy4B,EAAW3iB,UAAUa,WAAa3W,IAASy4B,EAAW3iB,UAAUc,SAAW5W,IAASy4B,EAAW3iB,UAAUe,MAAQ7W,IAASy4B,EAAW3iB,UAAUgB,SA3D5iB,IAQgC/V,EAR5Bg4B,GAQ4Bh4B,EARW2O,EAAQ,MAQE3O,EAAI4O,WAAa5O,EAAM,CAAEgO,QAAShO,GANnFi4B,EAAetpB,EAAQ,IAEvBy1B,EAAez1B,EAAQ,IAEvB+oB,EAAa/oB,EAAQ,IA2BzB,SAASu1B,IAGP,OAFAzrC,KAAK6nC,UAAY7nC,KAAKmgC,MACVngC,KAAKmgC,MAAQngC,KAAKmkC,YAIhC,SAASA,IACP,IAAIhE,EAAQngC,KAAKmgC,MAEjB,GAAIA,EAAM35B,OAASy4B,EAAW3iB,UAAUE,IACtC,GAEE2jB,EAAQA,EAAMr+B,OAASq+B,EAAMr+B,KAAO8pC,EAAU5rC,KAAMmgC,UAC7CA,EAAM35B,OAASy4B,EAAW3iB,UAAUsB,SAG/C,OAAOuiB,EAiBT,SAASoL,EAAI/kC,EAAM63B,EAAOC,EAAKrjB,EAAMC,EAAQ9F,EAAMxT,GACjD5B,KAAKwG,KAAOA,EACZxG,KAAKq+B,MAAQA,EACbr+B,KAAKs+B,IAAMA,EACXt+B,KAAKib,KAAOA,EACZjb,KAAKkb,OAASA,EACdlb,KAAK4B,MAAQA,EACb5B,KAAKoV,KAAOA,EACZpV,KAAK8B,KAAO,KAad,SAAS+pC,EAAcC,GACrB,OACEC,MAAMD,GAAQ7M,EAAW3iB,UAAUE,IACnCsvB,EAAO,IAASjjC,KAAKC,UAAUuQ,OAAO2yB,aAAaF,IACnD,OAAQ7yB,QAAQ,KAAO6yB,EAAK17B,SAAS,IAAIkgB,eAAe5f,OAAO,GAAI,KAYvE,SAASk7B,EAAUK,EAAO72B,GACxB,IAAI1J,EAASugC,EAAMvgC,OACftJ,EAAOsJ,EAAOtJ,KACd8pC,EAAa9pC,EAAKzB,OAClBmoC,EAmLN,SAAiC1mC,EAAM+pC,EAAeF,GACpD,IAAIC,EAAa9pC,EAAKzB,OAClB+Z,EAAWyxB,EAEf,KAAOzxB,EAAWwxB,GAAY,CAC5B,IAAIJ,EAAO1pC,EAAKgqC,WAAW1xB,GAE3B,GAAa,IAAToxB,GAAuB,KAATA,GAAwB,KAATA,GAAwB,QAATA,IAC5CpxB,OACG,GAAa,KAAToxB,IAEPpxB,IACAuxB,EAAMhxB,KACRgxB,EAAMT,UAAY9wB,MACb,IAAa,KAAToxB,EAWT,MATsC,KAAlC1pC,EAAKgqC,WAAW1xB,EAAW,GAC7BA,GAAY,IAEVA,IAGFuxB,EAAMhxB,KACRgxB,EAAMT,UAAY9wB,GAMtB,OAAOA,EAhNG2xB,CAAwBjqC,EAAMgT,EAAKkpB,IAAK2N,GAC9ChxB,EAAOgxB,EAAMhxB,KACbqxB,EAAM,EAAIxD,EAAMmD,EAAMT,UAE1B,GAAI1C,GAAOoD,EACT,OAAO,IAAIX,EAAItM,EAAW3iB,UAAUE,IAAK0vB,EAAYA,EAAYjxB,EAAMqxB,EAAKl3B,GAG9E,IAAI02B,EAAO1pC,EAAKgqC,WAAWtD,GAE3B,OAAQgD,GAEN,KAAK,GACH,OAAO,IAAIP,EAAItM,EAAW3iB,UAAUG,KAAMqsB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGrE,KAAK,GACH,OAwMN,SAAqB1J,EAAQ2yB,EAAOpjB,EAAMqxB,EAAKl3B,GAC7C,IACI02B,EADA1pC,EAAOsJ,EAAOtJ,KAEdsY,EAAW2jB,EAEf,GACEyN,EAAO1pC,EAAKgqC,aAAa1xB,UACjBqxB,MAAMD,KAChBA,EAAO,IAAmB,IAATA,IAEjB,OAAO,IAAIP,EAAItM,EAAW3iB,UAAUsB,QAASygB,EAAO3jB,EAAUO,EAAMqxB,EAAKl3B,EAAMhT,EAAKsO,MAAM2tB,EAAQ,EAAG3jB,IAlN1F6xB,CAAY7gC,EAAQo9B,EAAK7tB,EAAMqxB,EAAKl3B,GAG7C,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUI,OAAQosB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGvE,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUK,IAAKmsB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGpE,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUM,QAASksB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGxE,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUO,QAASisB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGxE,KAAK,GACH,GAAiC,KAA7BhT,EAAKgqC,WAAWtD,EAAM,IAA0C,KAA7B1mC,EAAKgqC,WAAWtD,EAAM,GAC3D,OAAO,IAAIyC,EAAItM,EAAW3iB,UAAUQ,OAAQgsB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGvE,MAGF,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUS,MAAO+rB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGtE,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUU,OAAQ8rB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGvE,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUW,GAAI6rB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGnE,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUY,UAAW4rB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAG1E,KAAK,GACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUa,UAAW2rB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAG1E,KAAK,IACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUc,QAAS0rB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGxE,KAAK,IACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUe,KAAMyrB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGrE,KAAK,IACH,OAAO,IAAIm2B,EAAItM,EAAW3iB,UAAUgB,QAASwrB,EAAKA,EAAM,EAAG7tB,EAAMqxB,EAAKl3B,GAGxE,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACH,OA+WN,SAAkB1J,EAAQ2yB,EAAOpjB,EAAMqxB,EAAKl3B,GAC1C,IAAIhT,EAAOsJ,EAAOtJ,KACd8pC,EAAa9pC,EAAKzB,OAClB+Z,EAAW2jB,EAAQ,EACnByN,EAAO,EAEX,KAAOpxB,IAAawxB,IAAeH,MAAMD,EAAO1pC,EAAKgqC,WAAW1xB,MAAwB,KAAToxB,GAC/EA,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,QAElBpxB,EAGJ,OAAO,IAAI6wB,EAAItM,EAAW3iB,UAAUiB,KAAM8gB,EAAO3jB,EAAUO,EAAMqxB,EAAKl3B,EAAMhT,EAAKsO,MAAM2tB,EAAO3jB,IA7XnF8xB,CAAS9gC,EAAQo9B,EAAK7tB,EAAMqxB,EAAKl3B,GAG1C,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACH,OA+FN,SAAoB1J,EAAQ2yB,EAAOoO,EAAWxxB,EAAMqxB,EAAKl3B,GACvD,IAAIhT,EAAOsJ,EAAOtJ,KACd0pC,EAAOW,EACP/xB,EAAW2jB,EACXqO,GAAU,EAED,KAATZ,IAEFA,EAAO1pC,EAAKgqC,aAAa1xB,IAG3B,GAAa,KAAToxB,GAIF,IAFAA,EAAO1pC,EAAKgqC,aAAa1xB,KAEb,IAAMoxB,GAAQ,GACxB,MAAM,EAAItM,EAAa/kB,aAAa/O,EAAQgP,EAAU,6CAA6CzB,OAAO4yB,EAAcC,GAAO,WAGjIpxB,EAAWiyB,EAAWjhC,EAAQgP,EAAUoxB,GACxCA,EAAO1pC,EAAKgqC,WAAW1xB,GAGZ,KAAToxB,IAEFY,GAAU,EACVZ,EAAO1pC,EAAKgqC,aAAa1xB,GACzBA,EAAWiyB,EAAWjhC,EAAQgP,EAAUoxB,GACxCA,EAAO1pC,EAAKgqC,WAAW1xB,IAGZ,KAAToxB,GAAwB,MAATA,IAEjBY,GAAU,EAGG,MAFbZ,EAAO1pC,EAAKgqC,aAAa1xB,KAEG,KAAToxB,IAEjBA,EAAO1pC,EAAKgqC,aAAa1xB,IAG3BA,EAAWiyB,EAAWjhC,EAAQgP,EAAUoxB,GACxCA,EAAO1pC,EAAKgqC,WAAW1xB,IAIzB,GAAa,KAAToxB,GAAwB,KAATA,GAAwB,MAATA,EAChC,MAAM,EAAItM,EAAa/kB,aAAa/O,EAAQgP,EAAU,2CAA2CzB,OAAO4yB,EAAcC,GAAO,MAG/H,OAAO,IAAIP,EAAImB,EAAUzN,EAAW3iB,UAAUmB,MAAQwhB,EAAW3iB,UAAUkB,IAAK6gB,EAAO3jB,EAAUO,EAAMqxB,EAAKl3B,EAAMhT,EAAKsO,MAAM2tB,EAAO3jB,IAjJzHkyB,CAAWlhC,EAAQo9B,EAAKgD,EAAM7wB,EAAMqxB,EAAKl3B,GAGlD,KAAK,GACH,OAAiC,KAA7BhT,EAAKgqC,WAAWtD,EAAM,IAA0C,KAA7B1mC,EAAKgqC,WAAWtD,EAAM,GAyQnE,SAAyBp9B,EAAQ2yB,EAAOpjB,EAAMqxB,EAAKl3B,EAAM62B,GACvD,IAAI7pC,EAAOsJ,EAAOtJ,KACdsY,EAAW2jB,EAAQ,EACnBwO,EAAanyB,EACboxB,EAAO,EACPgB,EAAW,GAEf,KAAOpyB,EAAWtY,EAAKzB,SAAWorC,MAAMD,EAAO1pC,EAAKgqC,WAAW1xB,KAAY,CAEzE,GAAa,KAAToxB,GAAiD,KAAlC1pC,EAAKgqC,WAAW1xB,EAAW,IAA+C,KAAlCtY,EAAKgqC,WAAW1xB,EAAW,GAEpF,OADAoyB,GAAY1qC,EAAKsO,MAAMm8B,EAAYnyB,GAC5B,IAAI6wB,EAAItM,EAAW3iB,UAAUqB,aAAc0gB,EAAO3jB,EAAW,EAAGO,EAAMqxB,EAAKl3B,GAAM,EAAIu2B,EAAahwB,wBAAwBmxB,IAInI,GAAIhB,EAAO,IAAmB,IAATA,GAA4B,KAATA,GAA4B,KAATA,EACzD,MAAM,EAAItM,EAAa/kB,aAAa/O,EAAQgP,EAAU,oCAAoCzB,OAAO4yB,EAAcC,GAAO,MAG3G,KAATA,KAEApxB,IACAuxB,EAAMhxB,KACRgxB,EAAMT,UAAY9wB,GACA,KAAToxB,GAE6B,KAAlC1pC,EAAKgqC,WAAW1xB,EAAW,GAC7BA,GAAY,IAEVA,IAGFuxB,EAAMhxB,KACRgxB,EAAMT,UAAY9wB,GAEX,KAAToxB,GAAiD,KAAlC1pC,EAAKgqC,WAAW1xB,EAAW,IAA+C,KAAlCtY,EAAKgqC,WAAW1xB,EAAW,IAA+C,KAAlCtY,EAAKgqC,WAAW1xB,EAAW,IACxHoyB,GAAY1qC,EAAKsO,MAAMm8B,EAAYnyB,GAAY,MAE/CmyB,EADAnyB,GAAY,KAGVA,EAIN,MAAM,EAAI8kB,EAAa/kB,aAAa/O,EAAQgP,EAAU,wBApTzCqyB,CAAgBrhC,EAAQo9B,EAAK7tB,EAAMqxB,EAAKl3B,EAAM62B,GA2K7D,SAAoBvgC,EAAQ2yB,EAAOpjB,EAAMqxB,EAAKl3B,GAC5C,IAAIhT,EAAOsJ,EAAOtJ,KACdsY,EAAW2jB,EAAQ,EACnBwO,EAAanyB,EACboxB,EAAO,EACPlqC,EAAQ,GAEZ,KAAO8Y,EAAWtY,EAAKzB,SAAWorC,MAAMD,EAAO1pC,EAAKgqC,WAAW1xB,KACtD,KAAToxB,GAA4B,KAATA,GAAiB,CAElC,GAAa,KAATA,EAEF,OADAlqC,GAASQ,EAAKsO,MAAMm8B,EAAYnyB,GACzB,IAAI6wB,EAAItM,EAAW3iB,UAAUoB,OAAQ2gB,EAAO3jB,EAAW,EAAGO,EAAMqxB,EAAKl3B,EAAMxT,GAIpF,GAAIkqC,EAAO,IAAmB,IAATA,EACnB,MAAM,EAAItM,EAAa/kB,aAAa/O,EAAQgP,EAAU,oCAAoCzB,OAAO4yB,EAAcC,GAAO,MAKxH,KAFEpxB,EAEW,KAAToxB,EAAa,CAKf,OAHAlqC,GAASQ,EAAKsO,MAAMm8B,EAAYnyB,EAAW,GAC3CoxB,EAAO1pC,EAAKgqC,WAAW1xB,IAGrB,KAAK,GACH9Y,GAAS,IACT,MAEF,KAAK,GACHA,GAAS,IACT,MAEF,KAAK,GACHA,GAAS,KACT,MAEF,KAAK,GACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IAGD,IAAIorC,GAwFKvpC,EAxFkBrB,EAAKgqC,WAAW1xB,EAAW,GAwF1Cnb,EAxF8C6C,EAAKgqC,WAAW1xB,EAAW,GAwFtEke,EAxF0Ex2B,EAAKgqC,WAAW1xB,EAAW,GAwFlGpb,EAxFsG8C,EAAKgqC,WAAW1xB,EAAW,GAyFtJuyB,EAASxpC,IAAM,GAAKwpC,EAAS1tC,IAAM,EAAI0tC,EAASrU,IAAM,EAAIqU,EAAS3tC,IAvFhE,GAAI0tC,EAAW,EAAG,CAChB,IAAIE,EAAkB9qC,EAAKsO,MAAMgK,EAAW,EAAGA,EAAW,GAC1D,MAAM,EAAI8kB,EAAa/kB,aAAa/O,EAAQgP,EAAU,yCAAyCzB,OAAOi0B,EAAiB,MAGzHtrC,GAASyX,OAAO2yB,aAAagB,GAC7BtyB,GAAY,EACZ,MAGJ,QACE,MAAM,EAAI8kB,EAAa/kB,aAAa/O,EAAQgP,EAAU,wCAAwCzB,OAAOI,OAAO2yB,aAAaF,GAAO,QAGlIpxB,EACFmyB,EAAanyB,GAuEnB,IAAqBjX,EAAGlE,EAAGq5B,EAAGt5B,EAnE5B,MAAM,EAAIkgC,EAAa/kB,aAAa/O,EAAQgP,EAAU,wBA5P3CyyB,CAAWzhC,EAAQo9B,EAAK7tB,EAAMqxB,EAAKl3B,GAG9C,MAAM,EAAIoqB,EAAa/kB,aAAa/O,EAAQo9B,EAO9C,SAAoCgD,GAClC,GAAIA,EAAO,IAAmB,IAATA,GAA4B,KAATA,GAA4B,KAATA,EACzD,MAAO,wCAAwC7yB,OAAO4yB,EAAcC,GAAO,KAG7E,GAAa,KAATA,EAEF,MAAO,kFAGT,MAAO,yCAAyC7yB,OAAO4yB,EAAcC,GAAO,KAjB3BsB,CAA2BtB,IA6I9E,SAASa,EAAWjhC,EAAQ2yB,EAAOoO,GACjC,IAAIrqC,EAAOsJ,EAAOtJ,KACdsY,EAAW2jB,EACXyN,EAAOW,EAEX,GAAIX,GAAQ,IAAMA,GAAQ,GAAI,CAE5B,GACEA,EAAO1pC,EAAKgqC,aAAa1xB,SAClBoxB,GAAQ,IAAMA,GAAQ,IAG/B,OAAOpxB,EAGT,MAAM,EAAI8kB,EAAa/kB,aAAa/O,EAAQgP,EAAU,2CAA2CzB,OAAO4yB,EAAcC,GAAO,MA6K/H,SAASmB,EAASxpC,GAChB,OAAOA,GAAK,IAAMA,GAAK,GAAKA,EAAI,GAC9BA,GAAK,IAAMA,GAAK,GAAKA,EAAI,GACzBA,GAAK,IAAMA,GAAK,IAAMA,EAAI,IACzB,GApgBL,EAAI87B,EAAchqB,SAASg2B,GAAK,WAC9B,MAAO,CACL/kC,KAAMxG,KAAKwG,KACX5E,MAAO5B,KAAK4B,MACZqZ,KAAMjb,KAAKib,KACXC,OAAQlb,KAAKkb,Y,6BCzFjB1b,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ6zB,uBAAoB,EAK5B,IAAIA,EAAoBloC,OAAO+R,OAAO,CAEpC87B,MAAO,QACPC,SAAU,WACVC,aAAc,eACdvL,MAAO,QACPa,oBAAqB,sBACrBL,gBAAiB,kBACjBE,gBAAiB,kBACjBnB,oBAAqB,sBAErBiM,OAAQ,SACRC,OAAQ,SACR/J,OAAQ,SACRiC,iBAAkB,mBAClB+H,oBAAqB,sBACrBC,UAAW,YACXC,MAAO,QACPxK,KAAM,OACNyK,WAAY,aACZC,aAAc,eACdC,uBAAwB,2BAM1Bl6B,EAAQ6zB,kBAAoBA,G,8BCrC5B,kBAGI3zB,EAHJ,QAMEA,EADkB,oBAATuf,KACFA,KACoB,oBAAXsG,OACTA,YACoB,IAAXoU,EACTA,EAEA/mB,EAKT,IAAIjlB,EAASisC,YAASl6B,GACP/R,Q,yCClBf,IAAIO,EAGJA,EAAK,WACJ,OAAOvC,KADH,GAIL,IAECuC,EAAIA,GAAK,IAAIqC,SAAS,cAAb,GACR,MAAO7D,GAEc,iBAAX64B,SAAqBr3B,EAAIq3B,QAOrC3S,EAAOpT,QAAUtR,G,cCnBjB0kB,EAAOpT,QAAU,SAASq6B,GACzB,IAAKA,EAAeC,gBAAiB,CACpC,IAAIlnB,EAASznB,OAAOW,OAAO+tC,GAEtBjnB,EAAO7hB,WAAU6hB,EAAO7hB,SAAW,IACxC5F,OAAOoU,eAAeqT,EAAQ,SAAU,CACvC0U,YAAY,EACZx1B,IAAK,WACJ,OAAO8gB,EAAOmnB,KAGhB5uC,OAAOoU,eAAeqT,EAAQ,KAAM,CACnC0U,YAAY,EACZx1B,IAAK,WACJ,OAAO8gB,EAAOzmB,KAGhBhB,OAAOoU,eAAeqT,EAAQ,UAAW,CACxC0U,YAAY,IAEb1U,EAAOknB,gBAAkB,EAE1B,OAAOlnB,I,6BCtBO,SAASonB,EAAyBt6B,GAChD,IAAI/R,EACAc,EAASiR,EAAKjR,OAalB,MAXsB,mBAAXA,EACNA,EAAOqjB,WACVnkB,EAASc,EAAOqjB,YAEhBnkB,EAASc,EAAO,cAChBA,EAAOqjB,WAAankB,GAGrBA,EAAS,eAGHA,EAfR,mC,gBCAAilB,EAAOpT,QAAUqC,EAAQ,IAAuBvC,Y,6BCOhD,SAAS26B,EAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAItrC,UAAU,qCAEhH,SAASurC,EAAkBjjC,EAAQ4a,GAAS,IAAK,IAAI5lB,EAAI,EAAGA,EAAI4lB,EAAMzlB,OAAQH,IAAK,CAAE,IAAIkuC,EAAatoB,EAAM5lB,GAAIkuC,EAAW/S,WAAa+S,EAAW/S,aAAc,EAAO+S,EAAWvF,cAAe,EAAU,UAAWuF,IAAYA,EAAWxF,UAAW,GAAM1pC,OAAOoU,eAAepI,EAAQkjC,EAAW9lC,IAAK8lC,IAE7S,SAASC,EAAaH,EAAaI,EAAYC,GAAmJ,OAAhID,GAAYH,EAAkBD,EAAYtuC,UAAW0uC,GAAiBC,GAAaJ,EAAkBD,EAAaK,GAAqBL,EATzMhvC,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQF,gBAAa,EASrB,IAAIm7B,EAAa,WACf,MAAyB,mBAAXhsC,QAGZisC,EAAY,SAAUhrC,GACxB,OAAO+qC,KAAgBt2B,QAAQ1V,OAAOiB,KAGpCirC,EAAY,SAAUjrC,GACxB,OAAOgrC,EAAUhrC,GAAQjB,OAAOiB,GAAQ,KAAOA,GAG7C+qC,MAAiBC,EAAU,gBAC7BjsC,OAAOqjB,WAAarjB,OAAO,eAG7B,IAAImsC,EAAiBD,EAAU,YAC3BE,EAAmBF,EAAU,cAC7BG,EAAgBH,EAAU,WAE9B,SAASI,EAAU7nC,EAAKqB,GACtB,IAAIhH,EAAQ2F,EAAIqB,GAChB,GAAa,MAAThH,EAAJ,CACA,GAAqB,mBAAVA,EAAsB,MAAM,IAAIsB,UAAUtB,EAAQ,sBAC7D,OAAOA,GAGT,SAASytC,EAAW9nC,GAClB,IAAI+nC,EAAO/nC,EAAItH,YAUf,YARa8J,IAATulC,GAGW,QAFbA,EAAOA,EAAKH,MAGVG,OAAOvlC,QAIKA,IAATulC,EAAqBA,EAAO37B,EAGrC,SAAS47B,EAAahpC,GACpB,OAAOA,aAAaoN,EAGtB,SAAS67B,EAAgBzuC,GACnByuC,EAAgBC,IAClBD,EAAgBC,IAAI1uC,GAEpBumB,YAAW,WACT,MAAMvmB,KAKZ,SAAS2uC,EAAQ55B,GACftU,QAAQC,UAAUS,MAAK,WACrB,IACE4T,IACA,MAAO/U,GACPyuC,EAAgBzuC,OAKtB,SAAS4uC,EAAoBhtB,GAC3B,IAAInE,EAAUmE,EAAaitB,SAC3B,QAAgB7lC,IAAZyU,IACJmE,EAAaitB,cAAW7lC,EAEnByU,GAIL,IACE,GAAuB,mBAAZA,EACTA,QACK,CACL,IAAIoF,EAAcwrB,EAAU5wB,EAAS,eAEjCoF,GACFA,EAAYhjB,KAAK4d,IAGrB,MAAOzd,GACPyuC,EAAgBzuC,IAIpB,SAAS8uC,EAAkBltB,GACzBA,EAAaqK,eAAYjjB,EACzB4Y,EAAamtB,YAAS/lC,EACtB4Y,EAAaotB,OAAS,SAmBxB,SAASC,EAAmBrtB,EAAchd,EAAM/D,GAC9C+gB,EAAaotB,OAAS,UACtB,IAAI1lB,EAAW1H,EAAaqK,UAE5B,IACE,IAAIijB,EAAIb,EAAU/kB,EAAU1kB,GAE5B,OAAQA,GACN,IAAK,OACCsqC,GAAGA,EAAErvC,KAAKypB,EAAUzoB,GACxB,MAEF,IAAK,QAEH,GADAiuC,EAAkBltB,IACdstB,EAAgC,MAAMruC,EAAnCquC,EAAErvC,KAAKypB,EAAUzoB,GACxB,MAEF,IAAK,WACHiuC,EAAkBltB,GACdstB,GAAGA,EAAErvC,KAAKypB,IAGlB,MAAOtpB,GACPyuC,EAAgBzuC,GAGU,WAAxB4hB,EAAaotB,OAAqBJ,EAAoBhtB,GAA+C,YAAxBA,EAAaotB,SAAsBptB,EAAaotB,OAAS,SAG5I,SAASG,EAASvtB,EAAchd,EAAM/D,GACpC,GAA4B,WAAxB+gB,EAAaotB,OAAjB,CAEA,GAA4B,cAAxBptB,EAAaotB,OASjB,MAA4B,UAAxBptB,EAAaotB,QACfptB,EAAaotB,OAAS,YACtBptB,EAAamtB,OAAS,CAAC,CACrBnqC,KAAMA,EACN/D,MAAOA,SAET8tC,GAAQ,WACN,OAhEN,SAA2B/sB,GACzB,IAAI8E,EAAQ9E,EAAamtB,OAEzB,GAAKroB,EAAL,CAIA9E,EAAamtB,YAAS/lC,EACtB4Y,EAAaotB,OAAS,QAEtB,IAAK,IAAIvvC,EAAI,EAAGA,EAAIinB,EAAM9mB,SACxBqvC,EAAmBrtB,EAAc8E,EAAMjnB,GAAGmF,KAAM8hB,EAAMjnB,GAAGoB,OAC7B,WAAxB+gB,EAAaotB,UAFiBvvC,KAsDzB2vC,CAAkBxtB,YAK7BqtB,EAAmBrtB,EAAchd,EAAM/D,GApBrC+gB,EAAamtB,OAAO1sC,KAAK,CACvBuC,KAAMA,EACN/D,MAAOA,KAqBb,IAAIkE,EAEJ,WACE,SAASA,EAAaukB,EAAU+lB,GAC9B9B,EAAgBtuC,KAAM8F,GAItB9F,KAAK4vC,cAAW7lC,EAChB/J,KAAKgtB,UAAY3C,EACjBrqB,KAAK8vC,YAAS/lC,EACd/J,KAAK+vC,OAAS,eACd,IAAIM,EAAuB,IAAIC,EAAqBtwC,MAEpD,IACEA,KAAK4vC,SAAWQ,EAAWxvC,UAAKmJ,EAAWsmC,GAC3C,MAAOtvC,GACPsvC,EAAqB7rC,MAAMzD,GAGT,iBAAhBf,KAAK+vC,SAA2B/vC,KAAK+vC,OAAS,SAkBpD,OAfApB,EAAa7oC,EAAc,CAAC,CAC1B8C,IAAK,cACLhH,MAAO,WACe,WAAhB5B,KAAK+vC,SACPF,EAAkB7vC,MAClB2vC,EAAoB3vC,SAGvB,CACD4I,IAAK,SACLzC,IAAK,WACH,MAAuB,WAAhBnG,KAAK+vC,WAITjqC,EApCT,GAuCIwqC,EAEJ,WACE,SAASA,EAAqB3tB,GAC5B2rB,EAAgBtuC,KAAMswC,GAEtBtwC,KAAK+sB,cAAgBpK,EAyBvB,OAtBAgsB,EAAa2B,EAAsB,CAAC,CAClC1nC,IAAK,OACLhH,MAAO,SAAcA,GACnBsuC,EAASlwC,KAAK+sB,cAAe,OAAQnrB,KAEtC,CACDgH,IAAK,QACLhH,MAAO,SAAeA,GACpBsuC,EAASlwC,KAAK+sB,cAAe,QAASnrB,KAEvC,CACDgH,IAAK,WACLhH,MAAO,WACLsuC,EAASlwC,KAAK+sB,cAAe,cAE9B,CACDnkB,IAAK,SACLzC,IAAK,WACH,MAAqC,WAA9BnG,KAAK+sB,cAAcgjB,WAIvBO,EA7BT,GAgCI38B,EAEJ,WACE,SAASA,EAAWy8B,GAGlB,GAFA9B,EAAgBtuC,KAAM2T,KAEhB3T,gBAAgB2T,GAAa,MAAM,IAAIzQ,UAAU,6CACvD,GAA0B,mBAAfktC,EAA2B,MAAM,IAAIltC,UAAU,6CAC1DlD,KAAKuwC,YAAcH,EAmVrB,OAhVAzB,EAAah7B,EAAY,CAAC,CACxB/K,IAAK,YACLhH,MAAO,SAAmByoB,GASxB,MARwB,iBAAbA,GAAsC,OAAbA,IAClCA,EAAW,CACTvoB,KAAMuoB,EACN7lB,MAAO9D,UAAU,GACjBilB,SAAUjlB,UAAU,KAIjB,IAAIoF,EAAaukB,EAAUrqB,KAAKuwC,eAExC,CACD3nC,IAAK,UACLhH,MAAO,SAAiBkU,GACtB,IAAIwtB,EAAQtjC,KAEZ,OAAO,IAAIwB,SAAQ,SAAUC,EAASC,GACpC,GAAkB,mBAAPoU,EAUX,IAAI6M,EAAe2gB,EAAMzgB,UAAU,CACjC/gB,KAAM,SAAUF,GACd,IACEkU,EAAGlU,EAAOK,GACV,MAAOlB,GACPW,EAAOX,GACP4hB,EAAaiB,gBAGjBpf,MAAO9C,EACPikB,SAAUlkB,SAnBVC,EAAO,IAAIwB,UAAU4S,EAAK,uBAI5B,SAAS7T,IACP0gB,EAAaiB,cACbniB,UAiBL,CACDmH,IAAK,MACLhH,MAAO,SAAakU,GAClB,IAAI2tB,EAASzjC,KAEb,GAAkB,mBAAP8V,EAAmB,MAAM,IAAI5S,UAAU4S,EAAK,sBAEvD,OAAO,IADCu5B,EAAWrvC,MACZ,EAAM,SAAUqqB,GACrB,OAAOoZ,EAAO5gB,UAAU,CACtB/gB,KAAM,SAAUF,GACd,IACEA,EAAQkU,EAAGlU,GACX,MAAOb,GACP,OAAOspB,EAAS7lB,MAAMzD,GAGxBspB,EAASvoB,KAAKF,IAEhB4C,MAAO,SAAUzD,GACfspB,EAAS7lB,MAAMzD,IAEjB4kB,SAAU,WACR0E,EAAS1E,mBAKhB,CACD/c,IAAK,SACLhH,MAAO,SAAgBkU,GACrB,IAAI06B,EAASxwC,KAEb,GAAkB,mBAAP8V,EAAmB,MAAM,IAAI5S,UAAU4S,EAAK,sBAEvD,OAAO,IADCu5B,EAAWrvC,MACZ,EAAM,SAAUqqB,GACrB,OAAOmmB,EAAO3tB,UAAU,CACtB/gB,KAAM,SAAUF,GACd,IACE,IAAKkU,EAAGlU,GAAQ,OAChB,MAAOb,GACP,OAAOspB,EAAS7lB,MAAMzD,GAGxBspB,EAASvoB,KAAKF,IAEhB4C,MAAO,SAAUzD,GACfspB,EAAS7lB,MAAMzD,IAEjB4kB,SAAU,WACR0E,EAAS1E,mBAKhB,CACD/c,IAAK,SACLhH,MAAO,SAAgBkU,GACrB,IAAI26B,EAASzwC,KAEb,GAAkB,mBAAP8V,EAAmB,MAAM,IAAI5S,UAAU4S,EAAK,sBACvD,IAAI46B,EAAIrB,EAAWrvC,MACf2wC,EAAUjwC,UAAUC,OAAS,EAC7BiwC,GAAW,EACXC,EAAOnwC,UAAU,GACjBowC,EAAMD,EACV,OAAO,IAAIH,GAAE,SAAUrmB,GACrB,OAAOomB,EAAO5tB,UAAU,CACtB/gB,KAAM,SAAUF,GACd,IAAIsrB,GAAS0jB,EAGb,GAFAA,GAAW,GAEN1jB,GAASyjB,EACZ,IACEG,EAAMh7B,EAAGg7B,EAAKlvC,GACd,MAAOb,GACP,OAAOspB,EAAS7lB,MAAMzD,QAGxB+vC,EAAMlvC,GAGV4C,MAAO,SAAUzD,GACfspB,EAAS7lB,MAAMzD,IAEjB4kB,SAAU,WACR,IAAKirB,IAAaD,EAAS,OAAOtmB,EAAS7lB,MAAM,IAAItB,UAAU,oCAC/DmnB,EAASvoB,KAAKgvC,GACdzmB,EAAS1E,mBAKhB,CACD/c,IAAK,SACLhH,MAAO,WAGL,IAFA,IAAImvC,EAAS/wC,KAEJgxC,EAAOtwC,UAAUC,OAAQ8K,EAAU,IAAI9L,MAAMqxC,GAAO/iC,EAAO,EAAGA,EAAO+iC,EAAM/iC,IAClFxC,EAAQwC,GAAQvN,UAAUuN,GAG5B,IAAIyiC,EAAIrB,EAAWrvC,MACnB,OAAO,IAAI0wC,GAAE,SAAUrmB,GACrB,IAAI1H,EACAtO,EAAQ,EAsBZ,OApBA,SAAS48B,EAAUnvC,GACjB6gB,EAAe7gB,EAAK+gB,UAAU,CAC5B/gB,KAAM,SAAUkB,GACdqnB,EAASvoB,KAAKkB,IAEhBwB,MAAO,SAAUzD,GACfspB,EAAS7lB,MAAMzD,IAEjB4kB,SAAU,WACJtR,IAAU5I,EAAQ9K,QACpBgiB,OAAe5Y,EACfsgB,EAAS1E,YAETsrB,EAAUP,EAAEzU,KAAKxwB,EAAQ4I,UAMjC48B,CAAUF,GACH,WACDpuB,IACFA,EAAaiB,cACbjB,OAAe5Y,SAKtB,CACDnB,IAAK,UACLhH,MAAO,SAAiBkU,GACtB,IAAIo7B,EAASlxC,KAEb,GAAkB,mBAAP8V,EAAmB,MAAM,IAAI5S,UAAU4S,EAAK,sBACvD,IAAI46B,EAAIrB,EAAWrvC,MACnB,OAAO,IAAI0wC,GAAE,SAAUrmB,GACrB,IAAIzjB,EAAgB,GAEhBuqC,EAAQD,EAAOruB,UAAU,CAC3B/gB,KAAM,SAAUF,GACd,GAAIkU,EACF,IACElU,EAAQkU,EAAGlU,GACX,MAAOb,GACP,OAAOspB,EAAS7lB,MAAMzD,GAI1B,IAAIywB,EAAQkf,EAAEzU,KAAKr6B,GAAOihB,UAAU,CAClC/gB,KAAM,SAAUF,GACdyoB,EAASvoB,KAAKF,IAEhB4C,MAAO,SAAUzD,GACfspB,EAAS7lB,MAAMzD,IAEjB4kB,SAAU,WACR,IAAInlB,EAAIoG,EAAc5F,QAAQwwB,GAC1BhxB,GAAK,GAAGoG,EAAcuO,OAAO3U,EAAG,GACpC4wC,OAGJxqC,EAAcxD,KAAKouB,IAErBhtB,MAAO,SAAUzD,GACfspB,EAAS7lB,MAAMzD,IAEjB4kB,SAAU,WACRyrB,OAIJ,SAASA,IACHD,EAAME,QAAmC,IAAzBzqC,EAAcjG,QAAc0pB,EAAS1E,WAG3D,OAAO,WACL/e,EAAcwB,SAAQ,SAAU7H,GAC9B,OAAOA,EAAEqjB,iBAEXutB,EAAMvtB,oBAIX,CACDhb,IAAKsmC,EACLttC,MAAO,WACL,OAAO5B,QAEP,CAAC,CACH4I,IAAK,OACLhH,MAAO,SAAc2E,GACnB,IAAImqC,EAAoB,mBAAT1wC,KAAsBA,KAAO2T,EAC5C,GAAS,MAALpN,EAAW,MAAM,IAAIrD,UAAUqD,EAAI,qBACvC,IAAIlC,EAAS+qC,EAAU7oC,EAAG2oC,GAE1B,GAAI7qC,EAAQ,CACV,IAAI8hB,EAAa9hB,EAAOzD,KAAK2F,GAC7B,GAAI/G,OAAO2mB,KAAgBA,EAAY,MAAM,IAAIjjB,UAAUijB,EAAa,qBACxE,OAAIopB,EAAappB,IAAeA,EAAWlmB,cAAgBywC,EAAUvqB,EAC9D,IAAIuqB,GAAE,SAAUrmB,GACrB,OAAOlE,EAAWtD,UAAUwH,MAIhC,GAAI0kB,EAAU,cACZ1qC,EAAS+qC,EAAU7oC,EAAG0oC,IAGpB,OAAO,IAAIyB,GAAE,SAAUrmB,GACrBqlB,GAAQ,WACN,IAAIrlB,EAASgnB,OAAb,CACA,IAAIC,GAA4B,EAC5BC,GAAoB,EACpBC,OAAiBznC,EAErB,IACE,IAAK,IAAmD0nC,EAA/CC,EAAYrtC,EAAOzD,KAAK2F,GAAGzD,OAAOC,cAAsBuuC,GAA6BG,EAAQC,EAAU5vC,QAAQG,MAAOqvC,GAA4B,EAAM,CAC/J,IAAIK,EAAQF,EAAM7vC,MAElB,GADAyoB,EAASvoB,KAAK6vC,GACVtnB,EAASgnB,OAAQ,QAEvB,MAAOxnB,GACP0nB,GAAoB,EACpBC,EAAiB3nB,EARnB,QAUE,IACOynB,GAAiD,MAApBI,EAAUE,QAC1CF,EAAUE,SAFd,QAKE,GAAIL,EACF,MAAMC,GAKZnnB,EAAS1E,kBAMjB,GAAIhmB,MAAM2S,QAAQ/L,GAChB,OAAO,IAAImqC,GAAE,SAAUrmB,GACrBqlB,GAAQ,WACN,IAAIrlB,EAASgnB,OAAb,CAEA,IAAK,IAAI7wC,EAAI,EAAGA,EAAI+F,EAAE5F,SAAUH,EAE9B,GADA6pB,EAASvoB,KAAKyE,EAAE/F,IACZ6pB,EAASgnB,OAAQ,OAGvBhnB,EAAS1E,kBAKf,MAAM,IAAIziB,UAAUqD,EAAI,wBAEzB,CACDqC,IAAK,KACLhH,MAAO,WACL,IAAK,IAAIiwC,EAAQnxC,UAAUC,OAAQkZ,EAAQ,IAAIla,MAAMkyC,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACrFj4B,EAAMi4B,GAASpxC,UAAUoxC,GAG3B,IAAIpB,EAAoB,mBAAT1wC,KAAsBA,KAAO2T,EAC5C,OAAO,IAAI+8B,GAAE,SAAUrmB,GACrBqlB,GAAQ,WACN,IAAIrlB,EAASgnB,OAAb,CAEA,IAAK,IAAI7wC,EAAI,EAAGA,EAAIqZ,EAAMlZ,SAAUH,EAElC,GADA6pB,EAASvoB,KAAK+X,EAAMrZ,IAChB6pB,EAASgnB,OAAQ,OAGvBhnB,EAAS1E,oBAId,CACD/c,IAAKumC,EACLhpC,IAAK,WACH,OAAOnG,SAIJ2T,EAzVT,GA4VAE,EAAQF,WAAaA,EAEjBm7B,KACFtvC,OAAOoU,eAAeD,EAAY7Q,OAAO,cAAe,CACtDlB,MAAO,CACLmwC,OAAQ7C,EACRM,gBAAiBA,GAEnBrG,cAAc,K,6BCpmBlBliB,EAAOpT,QAAU,SAAUgN,EAAMqL,GACxBA,IAAMA,EAAO,IACE,mBAATA,IAAqBA,EAAO,CAAE8lB,IAAK9lB,IAC9C,IAEiC7pB,EAF7B4vC,EAAiC,kBAAhB/lB,EAAK+lB,QAAwB/lB,EAAK+lB,OAEnDD,EAAM9lB,EAAK8lB,MAAkB3vC,EAQ9B6pB,EAAK8lB,IAPG,SAAUlnC,GACb,OAAO,SAAUrH,EAAGlE,GAChB,IAAI2yC,EAAO,CAAEtpC,IAAKnF,EAAG7B,MAAOkJ,EAAKrH,IAC7B0uC,EAAO,CAAEvpC,IAAKrJ,EAAGqC,MAAOkJ,EAAKvL,IACjC,OAAO8C,EAAE6vC,EAAMC,MAKvB3hC,EAAO,GACX,OAAQ,SAAS1H,EAAWgC,GAKxB,GAJIA,GAAQA,EAAK0P,QAAiC,mBAAhB1P,EAAK0P,SACnC1P,EAAOA,EAAK0P,eAGHzQ,IAATe,EAAJ,CACA,GAAmB,iBAARA,EAAkB,OAAOsnC,SAAStnC,GAAQ,GAAKA,EAAO,OACjE,GAAoB,iBAATA,EAAmB,OAAOjC,KAAKC,UAAUgC,GAEpD,IAAItK,EAAG6xC,EACP,GAAI1yC,MAAM2S,QAAQxH,GAAO,CAErB,IADAunC,EAAM,IACD7xC,EAAI,EAAGA,EAAIsK,EAAKnK,OAAQH,IACrBA,IAAG6xC,GAAO,KACdA,GAAOvpC,EAAUgC,EAAKtK,KAAO,OAEjC,OAAO6xC,EAAM,IAGjB,GAAa,OAATvnC,EAAe,MAAO,OAE1B,IAA4B,IAAxB0F,EAAKxP,QAAQ8J,GAAc,CAC3B,GAAImnC,EAAQ,OAAOppC,KAAKC,UAAU,aAClC,MAAM,IAAI5F,UAAU,yCAGxB,IAAIovC,EAAY9hC,EAAKpN,KAAK0H,GAAQ,EAC9B7B,EAAOzJ,OAAOyJ,KAAK6B,GAAMnC,KAAKqpC,GAAOA,EAAIlnC,IAE7C,IADAunC,EAAM,GACD7xC,EAAI,EAAGA,EAAIyI,EAAKtI,OAAQH,IAAK,CAC9B,IAAIoI,EAAMK,EAAKzI,GACXoB,EAAQkH,EAAUgC,EAAKlC,IAEtBhH,IACDywC,IAAKA,GAAO,KAChBA,GAAOxpC,KAAKC,UAAUF,GAAO,IAAMhH,GAGvC,OADA4O,EAAK2E,OAAOm9B,EAAW,GAChB,IAAMD,EAAM,KAtCf,CAuCLxxB,K,6BCvDPrhB,OAAOoU,eAAeC,EAAS,aAAc,CAC3CjS,OAAO,IAETiS,EAAQ0+B,MAUR,SAAerU,GACb,OAAO,EAAIsU,EAAS1+B,OAAOoqB,EAAK,CAC9BnoB,MAAO08B,KAVX,IAAID,EAAWt8B,EAAQ,IAEnBy1B,EAAez1B,EAAQ,IAa3B,IAAIu8B,EAAqB,CACvBr8B,KAAM,SAActL,GAClB,OAAOA,EAAKlJ,OAEdmM,SAAU,SAAkBjD,GAC1B,MAAO,IAAMA,EAAK/G,MAGpBsS,SAAU,SAAkBvL,GAC1B,OAAOgP,EAAKhP,EAAKzE,YAAa,QAAU,MAE1C0I,oBAAqB,SAA6BjE,GAChD,IAAI7H,EAAK6H,EAAKpE,UACV3C,EAAO+G,EAAK/G,KACZ2uC,EAAUC,EAAK,IAAK74B,EAAKhP,EAAK2B,oBAAqB,MAAO,KAC1DtE,EAAa2R,EAAKhP,EAAK3C,WAAY,KACnCmD,EAAeR,EAAKQ,aAGxB,OAAQvH,GAASoE,GAAeuqC,GAAkB,UAAPzvC,EAAgC6W,EAAK,CAAC7W,EAAI6W,EAAK,CAAC/V,EAAM2uC,IAAWvqC,EAAYmD,GAAe,KAA3EA,GAE9DgL,mBAAoB,SAA4Bw0B,GAC9C,IAAIl+B,EAAWk+B,EAAKl+B,SAChBjH,EAAOmlC,EAAKnlC,KACZgH,EAAem+B,EAAKn+B,aACpBxE,EAAa2iC,EAAK3iC,WACtB,OAAOyE,EAAW,KAAOjH,EAAOgtC,EAAK,MAAOhmC,GAAgBgmC,EAAK,IAAK74B,EAAK3R,EAAY,OAEzFsH,aAAc,SAAsBw7B,GAElC,OAAO5H,EADU4H,EAAM1/B,aAGzB4C,MAAO,SAAe+8B,GACpB,IAAI9hC,EAAQ8hC,EAAM9hC,MACdrF,EAAOmnC,EAAMnnC,KACb0E,EAAOyiC,EAAMxqC,UACbyH,EAAa+iC,EAAM/iC,WACnBmD,EAAe4/B,EAAM5/B,aACzB,OAAOwO,EAAK,CAAC64B,EAAK,GAAIvpC,EAAO,MAAQrF,EAAO4uC,EAAK,IAAK74B,EAAKrR,EAAM,MAAO,KAAMqR,EAAK3R,EAAY,KAAMmD,GAAe,MAEtH4D,SAAU,SAAkB0jC,GAG1B,OAFWA,EAAM7uC,KAEH,KADF6uC,EAAMhxC,OAIpB6M,eAAgB,SAAwBokC,GAGtC,MAAO,MAFIA,EAAM9uC,KAEK4uC,EAAK,IAAK74B,EADf+4B,EAAM1qC,WAC0B,OAEnDoO,eAAgB,SAAwBu8B,GACtC,IAAIliB,EAAgBkiB,EAAMliB,cACtBzoB,EAAa2qC,EAAM3qC,WACnBmD,EAAewnC,EAAMxnC,aACzB,OAAOwO,EAAK,CAAC,MAAO64B,EAAK,MAAO/hB,GAAgB9W,EAAK3R,EAAY,KAAMmD,GAAe,MAExFgE,mBAAoB,SAA4ByjC,GAC9C,IAAIhvC,EAAOgvC,EAAMhvC,KACb6sB,EAAgBmiB,EAAMniB,cACtBnkB,EAAsBsmC,EAAMtmC,oBAC5BtE,EAAa4qC,EAAM5qC,WACnBmD,EAAeynC,EAAMznC,aACzB,MAEE,YAAY2N,OAAOlV,GAAMkV,OAAO05B,EAAK,IAAK74B,EAAKrN,EAAqB,MAAO,KAAM,KAAO,MAAMwM,OAAO2X,EAAe,KAAK3X,OAAO05B,EAAK,GAAI74B,EAAK3R,EAAY,KAAM,MAAQmD,GAI5KkL,SAAU,SAAkBw8B,GAE1B,OADYA,EAAMpxC,OAGpB6U,WAAY,SAAoBw8B,GAE9B,OADYA,EAAMrxC,OAGpB8U,YAAa,SAAqBw8B,EAAQtqC,GACxC,IAAIhH,EAAQsxC,EAAOtxC,MAEnB,OADoBsxC,EAAO7P,OACJ,EAAIsI,EAAa5vB,kBAAkBna,EAAe,gBAARgH,EAAwB,GAAK,MAAQC,KAAKC,UAAUlH,IAEvH+U,aAAc,SAAsBw8B,GAElC,OADYA,EAAOvxC,MACJ,OAAS,SAE1BgV,UAAW,WACT,MAAO,QAETC,UAAW,SAAmBu8B,GAE5B,OADYA,EAAOxxC,OAGrBkV,UAAW,SAAmBu8B,GAE5B,MAAO,IAAMv5B,EADAu5B,EAAO1rC,OACM,MAAQ,KAEpCoP,YAAa,SAAqBu8B,GAEhC,MAAO,IAAMx5B,EADAw5B,EAAOjsC,OACM,MAAQ,KAEpC2P,YAAa,SAAqBu8B,GAGhC,OAFWA,EAAOxvC,KAEJ,KADFwvC,EAAO3xC,OAIrBiJ,UAAW,SAAmB2oC,GAG5B,MAAO,IAFIA,EAAOzvC,KAEE4uC,EAAK,IAAK74B,EADnB05B,EAAO9yC,UACuB,MAAO,MAGlDuW,UAAW,SAAmBw8B,GAE5B,OADWA,EAAO1vC,MAGpBmT,SAAU,SAAkBw8B,GAE1B,MAAO,IADIA,EAAO/tC,KACE,KAEtBwR,YAAa,SAAqBw8B,GAEhC,OADWA,EAAOhuC,KACJ,KAGhByR,iBAAkB,SAA0Bw8B,GAC1C,IAAIzrC,EAAayrC,EAAOzrC,WACpB08B,EAAiB+O,EAAO/O,eAC5B,OAAO/qB,EAAK,CAAC,SAAUA,EAAK3R,EAAY,KAAMk7B,EAAMwB,IAAkB,MAExExtB,wBAAyB,SAAiCw8B,GAGxD,OAFgBA,EAAOntC,UAEJ,KADRmtC,EAAOluC,MAGpB2R,qBAAsBw8B,GAAe,SAAUC,GAG7C,OAAOj6B,EAAK,CAAC,SAFFi6B,EAAOhwC,KAEW+V,EADZi6B,EAAO5rC,WACsB,MAAO,QAEvDoP,qBAAsBu8B,GAAe,SAAUE,GAC7C,IAAIjwC,EAAOiwC,EAAOjwC,KACdmhC,EAAa8O,EAAO9O,WACpB/8B,EAAa6rC,EAAO7rC,WACpBd,EAAS2sC,EAAO3sC,OACpB,OAAOyS,EAAK,CAAC,OAAQ/V,EAAM4uC,EAAK,cAAe74B,EAAKorB,EAAY,QAASprB,EAAK3R,EAAY,KAAMk7B,EAAMh8B,IAAU,QAElHmQ,gBAAiBs8B,GAAe,SAAUG,GACxC,IAAIlwC,EAAOkwC,EAAOlwC,KACd0E,EAAOwrC,EAAOvzC,UACdiF,EAAOsuC,EAAOtuC,KACdwC,EAAa8rC,EAAO9rC,WACxB,OAAOpE,GAAQmwC,EAAkBzrC,GAAQkqC,EAAK,MAAOp3B,EAAOzB,EAAKrR,EAAM,OAAQ,OAASkqC,EAAK,IAAK74B,EAAKrR,EAAM,MAAO,MAAQ,KAAO9C,EAAOgtC,EAAK,IAAK74B,EAAK3R,EAAY,SAEvKsP,qBAAsBq8B,GAAe,SAAUK,GAC7C,IAAIpwC,EAAOowC,EAAOpwC,KACd4B,EAAOwuC,EAAOxuC,KACdgH,EAAewnC,EAAOxnC,aACtBxE,EAAagsC,EAAOhsC,WACxB,OAAO2R,EAAK,CAAC/V,EAAO,KAAO4B,EAAMgtC,EAAK,KAAMhmC,GAAemN,EAAK3R,EAAY,MAAO,QAErFuP,wBAAyBo8B,GAAe,SAAUM,GAChD,IAAIrwC,EAAOqwC,EAAOrwC,KACdoE,EAAaisC,EAAOjsC,WACpBd,EAAS+sC,EAAO/sC,OACpB,OAAOyS,EAAK,CAAC,YAAa/V,EAAM+V,EAAK3R,EAAY,KAAMk7B,EAAMh8B,IAAU,QAEzEsQ,oBAAqBm8B,GAAe,SAAUO,GAC5C,IAAItwC,EAAOswC,EAAOtwC,KACdoE,EAAaksC,EAAOlsC,WACpBm9B,EAAQ+O,EAAO/O,MACnB,OAAOxrB,EAAK,CAAC,QAAS/V,EAAM+V,EAAK3R,EAAY,KAAMm9B,GAA0B,IAAjBA,EAAM3kC,OAAe,KAAOmZ,EAAKwrB,EAAO,OAAS,IAAK,QAEpH1tB,mBAAoBk8B,GAAe,SAAUQ,GAC3C,IAAIvwC,EAAOuwC,EAAOvwC,KACdoE,EAAamsC,EAAOnsC,WACpBR,EAAS2sC,EAAO3sC,OACpB,OAAOmS,EAAK,CAAC,OAAQ/V,EAAM+V,EAAK3R,EAAY,KAAMk7B,EAAM17B,IAAU,QAEpEkQ,oBAAqBi8B,GAAe,SAAUS,GAG5C,OAAOz6B,EAAK,CAFDy6B,EAAOxwC,KAEC+V,EADFy6B,EAAOpsC,WACY,MAAO,QAE7C2P,0BAA2Bg8B,GAAe,SAAUU,GAClD,IAAIzwC,EAAOywC,EAAOzwC,KACdoE,EAAaqsC,EAAOrsC,WACpBd,EAASmtC,EAAOntC,OACpB,OAAOyS,EAAK,CAAC,QAAS/V,EAAM+V,EAAK3R,EAAY,KAAMk7B,EAAMh8B,IAAU,QAErE0Q,oBAAqB+7B,GAAe,SAAUW,GAC5C,IAAI1wC,EAAO0wC,EAAO1wC,KACd0E,EAAOgsC,EAAO/zC,UACd2mC,EAAaoN,EAAOpN,WACpBC,EAAYmN,EAAOnN,UACvB,MAAO,cAAgBvjC,GAAQmwC,EAAkBzrC,GAAQkqC,EAAK,MAAOp3B,EAAOzB,EAAKrR,EAAM,OAAQ,OAASkqC,EAAK,IAAK74B,EAAKrR,EAAM,MAAO,OAAS4+B,EAAa,cAAgB,IAAM,OAASvtB,EAAKwtB,EAAW,UAE3MtvB,gBAAiB,SAAyB08B,GACxC,IAAIvsC,EAAausC,EAAOvsC,WACpB08B,EAAiB6P,EAAO7P,eAC5B,OAAO/qB,EAAK,CAAC,gBAAiBA,EAAK3R,EAAY,KAAMk7B,EAAMwB,IAAkB,MAE/E5sB,oBAAqB,SAA6B08B,GAGhD,OAAO76B,EAAK,CAAC,gBAFF66B,EAAO5wC,KAEkB+V,EADnB66B,EAAOxsC,WAC6B,MAAO,MAE9D+P,oBAAqB,SAA6B08B,GAChD,IAAI7wC,EAAO6wC,EAAO7wC,KACdmhC,EAAa0P,EAAO1P,WACpB/8B,EAAaysC,EAAOzsC,WACpBd,EAASutC,EAAOvtC,OACpB,OAAOyS,EAAK,CAAC,cAAe/V,EAAM4uC,EAAK,cAAe74B,EAAKorB,EAAY,QAASprB,EAAK3R,EAAY,KAAMk7B,EAAMh8B,IAAU,MAEzH8Q,uBAAwB,SAAgC08B,GACtD,IAAI9wC,EAAO8wC,EAAO9wC,KACdoE,EAAa0sC,EAAO1sC,WACpBd,EAASwtC,EAAOxtC,OACpB,OAAOyS,EAAK,CAAC,mBAAoB/V,EAAM+V,EAAK3R,EAAY,KAAMk7B,EAAMh8B,IAAU,MAEhF+Q,mBAAoB,SAA4B08B,GAC9C,IAAI/wC,EAAO+wC,EAAO/wC,KACdoE,EAAa2sC,EAAO3sC,WACpBm9B,EAAQwP,EAAOxP,MACnB,OAAOxrB,EAAK,CAAC,eAAgB/V,EAAM+V,EAAK3R,EAAY,KAAMm9B,GAA0B,IAAjBA,EAAM3kC,OAAe,KAAOmZ,EAAKwrB,EAAO,OAAS,IAAK,MAE3HjtB,kBAAmB,SAA2B08B,GAC5C,IAAIhxC,EAAOgxC,EAAOhxC,KACdoE,EAAa4sC,EAAO5sC,WACpBR,EAASotC,EAAOptC,OACpB,OAAOmS,EAAK,CAAC,cAAe/V,EAAM+V,EAAK3R,EAAY,KAAMk7B,EAAM17B,IAAU,MAE3E2Q,yBAA0B,SAAkC08B,GAC1D,IAAIjxC,EAAOixC,EAAOjxC,KACdoE,EAAa6sC,EAAO7sC,WACpBd,EAAS2tC,EAAO3tC,OACpB,OAAOyS,EAAK,CAAC,eAAgB/V,EAAM+V,EAAK3R,EAAY,KAAMk7B,EAAMh8B,IAAU,OAI9E,SAASysC,EAAelZ,GACtB,OAAO,SAAU9vB,GACf,OAAOgP,EAAK,CAAChP,EAAK6P,YAAaigB,EAAG9vB,IAAQ,OAS9C,SAASgP,EAAKm7B,EAAYC,GACxB,OAAOD,EAAaA,EAAW3uC,QAAO,SAAUC,GAC9C,OAAOA,KACNuT,KAAKo7B,GAAa,IAAM,GAQ7B,SAAS7R,EAAMt2B,GACb,OAAOA,GAA0B,IAAjBA,EAAMpM,OAAe,MAAQ4a,EAAOzB,EAAK/M,EAAO,OAAS,MAAQ,GAQnF,SAAS4lC,EAAKtU,EAAO8W,EAAa7W,GAChC,OAAO6W,EAAc9W,EAAQ8W,GAAe7W,GAAO,IAAM,GAG3D,SAAS/iB,EAAO45B,GACd,OAAOA,GAAe,KAAOA,EAAYl7B,QAAQ,MAAO,QAG1D,SAASm7B,EAAYlY,GACnB,OAAiC,IAA1BA,EAAOl8B,QAAQ,MAGxB,SAASkzC,EAAkBe,GACzB,OAAOA,GAAcA,EAAWjqC,KAAKoqC,K,4FC3SvBC,EAAc9tC,GAgB5B,MAL0B,CACxBf,KAAM,WACNH,YAAa,CAZqB,CAClCG,KAAM,sBACNE,UAAW,QACX3C,KAAM,CACJyC,KAAM,OACN5E,MAAO,wBAET0J,aAAcgqC,EAAoB/tC,MAoCtC,SAAS+tC,EAAoB/tC,GAC3B,GACiB,iBAARA,GACQ,kBAARA,GACQ,iBAARA,GAFP,MAGOA,EAIP,OAAO,KAGT,GAAI5H,MAAM2S,QAAQ/K,GAEhB,OAAO+tC,EAAoB/tC,EAAI,IAIjC,IAAMgE,EAA0B,GAsBhC,OApBA/L,OAAOyJ,KAAK1B,GAAKa,SAAQ,SAAAQ,GACvB,IAEMX,EAAmB,CACvBzB,KAAM,QACNzC,KAAM,CACJyC,KAAM,OACN5E,MAAOgH,GAET0C,aARqCgqC,EAAoB/tC,EAAIqB,UAQ/BmB,GAGhCwB,EAAWnI,KAAK6E,MAGqB,CACrCzB,KAAM,eACN+E,WAAU,GAMP,IC7FUgqC,ED6FJC,EAAkC,CAC7ChvC,KAAM,WACNH,YAAa,CACX,CACEG,KAAM,sBACNE,UAAW,QACX3C,KAAM,KACN0I,oBAAqB,KACrBtE,WAAY,GACZmD,aAAc,CACZ9E,KAAM,eACN+E,WAAY,CACV,CACE/E,KAAM,QACN4C,MAAO,KACPrF,KAAM,CACJyC,KAAM,OACN5E,MAAO,cAETlB,UAAW,GACXyH,WAAY,GACZmD,aAAc,W,aE5G1B,cA6IA,OA/FS,8BAAP,SAAyB,GACvB,OAAO,GAGF,6BAAP,SAAwB,GACtB,OAAO,GASF,sBAAP,SACE,EACA,GAEA,YAFA,cAEO,KAAK,KAAK,CACf,MAAO,EAAQ,MACf,UAAW,EAAQ,UACnB,WAAU,KAIP,yBAAP,SACE,EACA,GAEA,YAFA,cAEO,KAAK,KAAK,CACf,MAAO,YAAyB,EAAQ,SAAU,EAAQ,cAC1D,UAAW,EAAQ,UACnB,OAAQ,EAAQ,GAChB,WAAU,KAIP,uBAAP,SACE,GAEA,KAAK,MAAM,CACT,OAAQ,aACR,OAAQ,EAAQ,KAChB,MAAO,EAAQ,MACf,UAAW,EAAQ,aAIhB,0BAAP,SACE,GAEA,KAAK,MAAM,CACT,OAAQ,EAAQ,GAChB,OAAQ,EAAQ,KAChB,UAAW,EAAQ,UACnB,MAAO,YAAyB,EAAQ,SAAU,EAAQ,iBAIvD,sBAAP,SAA8B,G,IFtFC/D,EAAUuC,EEuFvC,OACA,SAEA,QAAkB,IAAP,EAAoB,CAC7B,IAAI,EAAiB,KAKrB,IACE,EAAiB,KAAK,KAAU,CAC9B,OAAQ,EACR,YAAY,EACZ,MAAO,IAET,MAAO,IAKT,IAAM,EACH,GAAkB,EAAe,YAAe,eAG7C,EAAc,OAAO,OAAO,CAAE,WAAU,GAAI,GAElD,KAAK,cAAc,CACjB,GAAE,EACF,UFnHyBvC,EEmHE,EFnHQuC,EEmHK,EFlGpB,CACxBtD,KAAM,WACNH,YAAa,CAlBsB,CACnCG,KAAM,qBACNoqB,cAAe,CACbpqB,KAAM,YACNzC,KAAM,CACJyC,KAAM,OACN5E,MAAOkI,GAAY,eAGvB/F,KAAM,CACJyC,KAAM,OACN5E,MAAO,wBAET0J,aAAcgqC,EAAoB/tC,OEsG9B,KAAM,SAGR,KAAK,WAAW,CAAE,MAAO,EAAc,GAAO,KAAI,KAGxD,E,GDnJiBguC,MAAK,I,YEMlBE,EAAiC,KAI/BC,EAAqB,GAEvBxjB,EAAY,EAwHVyjB,EAAOh2C,MAEAi2C,EAAyCD,EAHpC,sBAGuD,WACvE,IAAMC,EAtHoB,wBAIV,KAAA/rC,GAAK,CACnB,OACAqoB,IACA2jB,KAAKC,MACLp8B,KAAKq8B,SAAS3lC,SAAS,IAAIM,MAAM,IACjCoJ,KAAK,KA+FT,OA7FS,YAAA82B,SAAP,WACE,IAAK,IAAI,EAAU6E,EAAgB,EAAS,EAAU,EAAQvnC,OAG5D,GAAIlO,KAAK6J,MAAM,EAAQmsC,MAAO,CAC5B,IAAMp0C,EAAQ,EAAQo0C,MAAMh2C,KAAK6J,IACjC,GAAIjI,IAAU8zC,EAAe,MAO7B,OANI,IAAYD,IAIdA,EAAgBO,MAAMh2C,KAAK6J,IAAMjI,IAE5B,EASX,OANI6zC,IAIFA,EAAeO,MAAMh2C,KAAK6J,IAAM6rC,IAE3B,GAGF,YAAAO,SAAP,WACE,GAAIj2C,KAAK4wC,WACP,OAAO6E,EAAgBO,MAAMh2C,KAAK6J,KAI/B,YAAAqsC,UAAP,SACEt0C,EACA+0B,EAGAluB,EACArH,G,MAEM40C,IAAK,GACTt2C,UAAW,OACVM,KAAK6J,IAAKjI,EACZ,GACKsM,EAASunC,EACfA,EAAiB,CAAEvnC,OAAM,EAAE8nC,MAAK,GAChC,IAGE,OAAOrf,EAAS91B,MAAMO,EAAUqH,GAHlC,QAKEgtC,EAAiBvnC,IAMd,EAAAmT,KAAP,SACEsV,GAEA,IAAMrxB,EAAUmwC,EAChB,OAAO,WACL,IAAMU,EAAQV,EACd,IAEE,OADAA,EAAiBnwC,EACVqxB,EAAS91B,MAAMb,KAAMU,WAF9B,QAIE+0C,EAAiBU,KAMhB,EAAAC,UAAP,SACEzf,EAGAluB,EACArH,GAEA,IAAIq0C,EAWF,OAAO9e,EAAS91B,MAAMO,EAAUqH,GAVhC,IAAM0tC,EAAQV,EACd,IAIE,OAHAA,EAAiB,KAGV9e,EAAS91B,MAAMO,EAAUqH,GAJlC,QAMEgtC,EAAiBU,IAMzB,EAxG4B,GAuH1B,IACE32C,OAAOoU,eAAe+hC,EANR,oBAMyB,CACrC/zC,MAAO+zC,EAPK,qBAOaC,EACzBja,YAAY,EACZuN,UAAU,EACVC,cAAc,IALlB,QAQE,OAAOyM,GAV8D,GCtI1D,OAAM,YFKrB,SAASS,KAET,iBAKE,WACUrL,EACDsL,QADC,IAAAtL,MAAA,UACD,IAAAsL,MAAA,GADC,KAAAtL,MACD,KAAAsL,UAND,KAAAhvC,IAAM,IAAI7B,IACV,KAAA8wC,OAA4B,KAC5B,KAAAC,OAA4B,KAsGtC,OA/FS,YAAA/lC,IAAP,SAAW7H,GACT,OAAO5I,KAAKsH,IAAImJ,IAAI7H,IAGf,YAAAzC,IAAP,SAAWyC,GACT,IAAM6tC,EAAQz2C,KAAK02C,SAAS9tC,GAC5B,OAAO6tC,GAASA,EAAM70C,OAGhB,YAAA80C,SAAR,SAAiB9tC,GACf,IAAM6tC,EAAQz2C,KAAKsH,IAAInB,IAAIyC,GAE3B,GAAI6tC,GAASA,IAAUz2C,KAAKu2C,OAAQ,CAC1B,IAAAI,EAAA,EAAAA,MAAOC,EAAA,EAAAA,MAEXA,IACFA,EAAMD,MAAQA,GAGZA,IACFA,EAAMC,MAAQA,GAGhBH,EAAME,MAAQ32C,KAAKu2C,OACnBE,EAAME,MAAOC,MAAQH,EAErBA,EAAMG,MAAQ,KACd52C,KAAKu2C,OAASE,EAEVA,IAAUz2C,KAAKw2C,SACjBx2C,KAAKw2C,OAASI,GAIlB,OAAOH,GAGF,YAAA9lC,IAAP,SAAW/H,EAAQhH,GACjB,IAAI60C,EAAQz2C,KAAK02C,SAAS9tC,GAC1B,OAAI6tC,EACKA,EAAM70C,MAAQA,GAGvB60C,EAAQ,CACN7tC,IAAKA,EACLhH,MAAOA,EACPg1C,MAAO,KACPD,MAAO32C,KAAKu2C,QAGVv2C,KAAKu2C,SACPv2C,KAAKu2C,OAAOK,MAAQH,GAGtBz2C,KAAKu2C,OAASE,EACdz2C,KAAKw2C,OAASx2C,KAAKw2C,QAAUC,EAE7Bz2C,KAAKsH,IAAIqJ,IAAI/H,EAAK6tC,GAEXA,EAAM70C,QAGR,YAAAi1C,MAAP,WACE,KAAO72C,KAAKw2C,QAAUx2C,KAAKsH,IAAI0L,KAAOhT,KAAKgrC,KACzChrC,KAAK6qB,OAAO7qB,KAAKw2C,OAAO5tC,MAIrB,YAAAiiB,OAAP,SAAcjiB,GACZ,IAAM6tC,EAAQz2C,KAAKsH,IAAInB,IAAIyC,GAC3B,QAAI6tC,IACEA,IAAUz2C,KAAKu2C,SACjBv2C,KAAKu2C,OAASE,EAAME,OAGlBF,IAAUz2C,KAAKw2C,SACjBx2C,KAAKw2C,OAASC,EAAMG,OAGlBH,EAAMG,QACRH,EAAMG,MAAMD,MAAQF,EAAME,OAGxBF,EAAME,QACRF,EAAME,MAAMC,MAAQH,EAAMG,OAG5B52C,KAAKsH,IAAIujB,OAAOjiB,GAChB5I,KAAKs2C,QAAQG,EAAM70C,MAAOgH,IAEnB,IAKb,EAzGA,GENakuC,EAAkB,IAAIlB,ECA7BmB,EAAiC,GACjCC,EAAgC,GAKtC,SAASC,EAAO9yC,EAAgB+yC,GAC9B,IAAM/yC,EACJ,MAAM,IAAIF,MAAMizC,GAAmB,qBAuBvC,SAASC,EAAYv1C,GACnB,OAAQA,EAAMjB,QACZ,KAAK,EAAG,MAAM,IAAIsD,MAAM,iBACxB,KAAK,EAAG,OAAOrC,EAAM,GACrB,KAAK,EAAG,MAAMA,EAAM,IAUxB,iBAmBE,WACkBkU,EACTrN,GADS,KAAAqN,KACT,KAAArN,OAdO,KAAA2uC,QAAU,IAAI3jC,IACd,KAAA4jC,YAAc,IAAI5xC,IAK3B,KAAA6xC,cAAsC,KAEtC,KAAAC,OAAQ,EACR,KAAAC,aAAc,EACL,KAAA51C,MAAuB,KAMnC61C,EAAM5lC,MAuDZ,OA9CS,YAAA6lC,UAAP,WAGE,GAFAT,GAASj3C,KAAKw3C,YAAa,uBA+C/B,SAAwB5mC,GACtB,IAAM1C,EAAS4oC,EAAgBb,WAC/B,GAAI/nC,EAaF,OAZA0C,EAAMwmC,QAAQ1jC,IAAIxF,GAEZA,EAAOmpC,YAAY5mC,IAAIG,IAC3B1C,EAAOmpC,YAAY1mC,IAAIC,EAAO,IAG5B+mC,EAAa/mC,GACfgnC,EAAiB1pC,EAAQ0C,GAEzBinC,EAAiB3pC,EAAQ0C,GAGpB1C,EA5DD4pC,CAAe93C,QAAS+3C,EAAkB/3C,MAOhD,OAAO23C,EAAa33C,MAyDxB,SAAyBy2C,GAIvB,IAAMuB,EAAmBC,EAAexB,GAGxCK,EAAgBZ,UAAUO,EAAOyB,EAAmB,CAACzB,IAqJvD,SAAwBA,GACtB,GAA+B,mBAApBA,EAAM5zB,UACf,IACEs1B,EAAiB1B,GACjBA,EAAM7yB,YAAc6yB,EAAM5zB,UAAUhiB,MAAM,KAAM41C,EAAMhuC,MACtD,MAAO1H,GAMP,OADA01C,EAAM2B,YACC,EAMX,OAAO,EApKHC,CAAe5B,IAiCrB,SAAkBA,GAGhB,GAFAA,EAAMc,OAAQ,EAEVI,EAAalB,GAGf,OAGF6B,EAAY7B,GAvCV8B,CAAS9B,GAQX,OAFAuB,EAAiB5vC,QAAQ2vC,GAElBZ,EAASV,EAAM70C,OA5EhB42C,CAAgBx4C,MAChBm3C,EAASn3C,KAAK4B,QAGb,YAAAw2C,SAAP,WACMp4C,KAAKu3C,QACTv3C,KAAKu3C,OAAQ,EACbv3C,KAAK4B,MAAMjB,OAAS,EACpB83C,EAAYz4C,MAIZm4C,EAAiBn4C,QAGZ,YAAAs2C,QAAP,sBACE2B,EAAej4C,MAAMoI,QAAQ2vC,GAC7BI,EAAiBn4C,MAajBA,KAAKo3C,QAAQhvC,SAAQ,SAAA8F,GACnBA,EAAOkqC,WACPM,EAAYxqC,EAAQ,OA1EV,EAAA2D,MAAQ,EA6ExB,EA9EA,GA0HA,SAASqmC,EAAkBzB,GACzBA,EAAMe,aAAc,EAEpBf,EAAM70C,MAAMjB,OAAS,EACrB,IAEE81C,EAAM70C,MAAM,GAAK60C,EAAM3gC,GAAGjV,MAAM,KAAM41C,EAAMhuC,MAC5C,MAAO1H,GAEP01C,EAAM70C,MAAM,GAAKb,EAGnB01C,EAAMe,aAAc,EAGtB,SAASG,EAAalB,GACpB,OAAOA,EAAMc,UAAYd,EAAMa,gBAAiBb,EAAMa,cAActkC,MAetE,SAASylC,EAAY7nC,GACnBA,EAAMwmC,QAAQhvC,SAAQ,SAAA8F,GAAU,OAAA0pC,EAAiB1pC,EAAQ0C,MAG3D,SAAS0nC,EAAY1nC,GACnBA,EAAMwmC,QAAQhvC,SAAQ,SAAA8F,GAAU,OAAA2pC,EAAiB3pC,EAAQ0C,MAI3D,SAASgnC,EAAiB1pC,EAAkB0C,GAM1C,GAHAqmC,EAAO/oC,EAAOmpC,YAAY5mC,IAAIG,IAC9BqmC,EAAOU,EAAa/mC,IAEd1C,EAAOopC,eAGN,GAAIppC,EAAOopC,cAAc7mC,IAAIG,GAIlC,YANA1C,EAAOopC,cAAgBN,EAAa7zC,OAAS,IAAIsQ,IASnDvF,EAAOopC,cAAc5jC,IAAI9C,GACzB6nC,EAAYvqC,GAId,SAAS2pC,EAAiB3pC,EAAkB0C,GAG1CqmC,EAAO/oC,EAAOmpC,YAAY5mC,IAAIG,IAC9BqmC,GAASU,EAAa/mC,IAEtB,IAvNenN,EAAelE,EACxBka,EAsNAk/B,EAAazqC,EAAOmpC,YAAYlxC,IAAIyK,GAChB,IAAtB+nC,EAAWh4C,OACbuN,EAAOmpC,YAAY1mC,IAAIC,EAAiBA,EAAMhP,MApMnC8O,MAAM,KArBJjN,EA0NMk1C,EA1NSp5C,EA0NGqR,EAAMhP,OAzNjC6X,EAAMhW,EAAE9C,QAGN,GAEN8Y,IAAQla,EAAEoB,QAEV8C,EAAEgW,EAAM,KAAOla,EAAEka,EAAM,IAmNvBvL,EAAOkqC,YAGTQ,EAAiB1qC,EAAQ0C,GAErB+mC,EAAazpC,IAIjBoqC,EAAYpqC,GAGd,SAAS0qC,EAAiB1qC,EAAkB0C,GAC1C,IAAMioC,EAAK3qC,EAAOopC,cACduB,IACFA,EAAGhuB,OAAOja,GACM,IAAZioC,EAAG7lC,OACDgkC,EAAar2C,OA7PE,KA8PjBq2C,EAAa5zC,KAAKy1C,GAEpB3qC,EAAOopC,cAAgB,OAU7B,SAASS,EAAkBtB,GACzB,OAA8B,IAAvBA,EAAMW,QAAQpkC,MACW,mBAAvByjC,EAAMqC,eACY,IAAzBrC,EAAMqC,eAKV,SAASb,EAAe/pC,GACtB,IAAI9I,EAAW2xC,EAcf,OAZI7oC,EAAOmpC,YAAYrkC,KAAO,IAC5B5N,EAAW,GACX8I,EAAOmpC,YAAYjvC,SAAQ,SAAC2wC,EAAQnoC,GAClC8nC,EAAYxqC,EAAQ0C,GACpBxL,EAAShC,KAAKwN,OAMlBqmC,EAAgC,OAAzB/oC,EAAOopC,eAEPlyC,EAGT,SAASszC,EAAYxqC,EAAkB0C,GACrCA,EAAMwmC,QAAQvsB,OAAO3c,GACrBA,EAAOmpC,YAAYxsB,OAAOja,GAC1BgoC,EAAiB1qC,EAAQ0C,GAuB3B,SAASunC,EAAiB1B,GAChB,IAAA7yB,EAAA,EAAAA,YACmB,mBAAhBA,IACT6yB,EAAM7yB,iBAAc,EACpBA,KCrUJ,iBAQE,WAA6Bo1B,GAAA,KAAAA,WAoB/B,OAlBS,YAAAC,OAAP,W,IAA+B,sDAC7B,OAAOj5C,KAAKk5C,YAAYnsC,IAGnB,YAAAmsC,YAAP,SAAoCnsC,GAClC,IAAIjC,EAAmB9K,KAEvB,OADA+M,EAAM3E,SAAQ,SAAAQ,GAAO,OAAAkC,EAAOA,EAAKquC,aAAavwC,MACvCkC,EAAK+V,OAAS/V,EAAK+V,KAAOrhB,OAAOW,OAAO,QAGzC,YAAAg5C,aAAR,SAAqBvwC,GACnB,IAAMtB,EAAMtH,KAAKg5C,UASrB,SAAkBp3C,GAChB,cAAeA,GACf,IAAK,SACH,GAAc,OAAVA,EAAgB,MAEtB,IAAK,WACH,OAAO,EAET,OAAO,EAjBwBw3C,CAASxwC,GAClC5I,KAAKq5C,OAASr5C,KAAKq5C,KAAO,IAAIppC,SAC9BjQ,KAAKs5C,SAAWt5C,KAAKs5C,OAAS,IAAI7zC,KAClCmL,EAAQtJ,EAAInB,IAAIyC,GAEpB,OADKgI,GAAOtJ,EAAIqJ,IAAI/H,EAAKgI,EAAQ,IAAI2oC,EAAWv5C,KAAKg5C,WAC9CpoC,GAEX,EA5BA,GC2BA,IAAM,EAAU,IAAI,EAAsC,mBAAZ,SAC9C,SAAgB,I,IAAoB,sDAClC,OAAO,EAAQ,YAAY,GAkC7B,IAAM,EAAS,IAAI,IAEnB,SAAgB,EAId,EACA,kBAAwC,OAAO,OAAO,OAEtD,IAAM,EAAQ,IAAI,EAChB,EAAQ,KAAO,KAAK,IAAI,EAAG,KAC3B,YAAS,SAAM,aAGX,IAAgB,EAAQ,WACxB,EAAe,EAAQ,cAAgB,EAE7C,SAAS,IACP,IAAI,GAAgB,EAAgB,WAApC,CASA,IAAM,EAAM,EAAa,MAAM,KAAM,WACrC,QAAY,IAAR,EACF,OAAO,EAAiB,MAAM,KAAM,WAGtC,IAAM,EAAO,MAAM,UAAU,MAAM,KAAK,WAEpC,EAAQ,EAAM,IAAI,GAClB,EACF,EAAM,KAAO,GAEb,EAAQ,IAAI,EAAsB,EAAkB,GACpD,EAAM,IAAI,EAAK,GACf,EAAM,UAAY,EAAQ,UACtB,IACF,EAAM,aAAe,WAAM,SAAM,OAAO,MAI5C,IAAM,EAAQ,EAAM,YAmBhB,OAfJ,EAAM,IAAI,EAAK,GAEf,EAAO,IAAI,GAKL,EAAgB,aACpB,EAAO,SAAQ,YAAS,SAAM,WAC9B,EAAO,SAMF,OAAa,EAAgB,GAWpC,OARA,EAAS,MAAQ,WACb,IAAE,EAAM,EAAa,MAAM,KAAM,WAC/B,OAAgB,IAAR,GAAkB,EAAM,IAAI,GACtC,GACF,EAAM,YAIH,E,WCnIL4oC,GAAa,EAEjB,SAASC,IACP,IAAMC,GAAUF,EAKhB,OAHK,gBACHA,GAAa,GAERE,EAMT,iBACE,cA6EF,OAzES,YAAAC,YAAP,WACE,OAAOn4C,QAAQC,WAGV,YAAAm4C,cAAP,WACE,OAAO,GAGF,YAAA7+B,MAAP,SACE8+B,EACAjpB,EACAtrB,GAEA,IAAMiC,EAAMjC,EAAQ0oB,MAAM7nB,IAAI0zC,EAAQhwC,IAChCiwC,EAA6B,eAAfD,EAAQhwC,GAE5B,IAAKtC,EAEH,OAAOuyC,EAGD,QAAA3oB,kBAAA,mBAER,OAAKA,GAoBDA,IAAeP,IAnBb6oB,IAgBG,cAiCb,EA9EA,GCrBMM,G,WDyGJ,WAAYl8B,GAGNA,GAAWA,EAAQm8B,8BACrBh6C,KAAKi6C,iBAAmBj6C,KAAKk6C,yBAC3Br8B,EAAQm8B,8BAEVh6C,KAAKm6C,SAAU,GAEfn6C,KAAKm6C,SAAU,EAGjBn6C,KAAK+a,MAAQ/a,KAAK+a,MAAMsG,KAAKrhB,MAGxB,YAAA+a,MAAP,SACE8+B,EACAjpB,EACAtrB,GAEA,4BAKA,IAAMiC,EAAMjC,EAAQ0oB,MAAM7nB,IAAI0zC,EAAQhwC,IAChCiwC,EAA6B,eAAfD,EAAQhwC,GAE5B,IAAKtC,EAEH,OAAOuyC,EAGD,QAAA3oB,kBAAA,mBASR,GANY,iBAMRA,IAAeP,EACjB,OAAO,EAGT,IAAMwpB,EAAoBp6C,KAAKi6C,iBAAiBrpB,GAChD,SACEO,GACAipB,GACAA,EAAkBp5C,QAAQmwB,IAAe,IAQrC,YAAA+oB,yBAAR,SACEG,GAEA,IAAMC,EAA4B,GAQlC,OAPAD,EAAwBE,SAASjV,MAAMl9B,SAAQ,SAAAzC,GAC3B,UAAdA,EAAKa,MAAkC,cAAdb,EAAKa,OAChC8zC,EAAQ30C,EAAK5B,MAAQ4B,EAAK60C,cAAclzC,KACtC,SAAAmzC,GAAoB,OAAAA,EAAiB12C,YAIpCu2C,G,GC9KI96C,OAAOU,UAAUL,gBAEhC,aAKE,WAAoBghB,GAApB,gBAAoB,IAAAA,MAA8BrhB,OAAOW,OAAO,OAA5C,KAAA0gB,OAClB7gB,KAAK06C,OAAS/H,GAAK,SAACja,GAAmB,SAAK7X,KAAK6X,KAAS,CACxDiiB,YAAY,EACZC,aAAA,SAAaliB,GACX,OAAOA,KAiDf,OA5CS,YAAAmiB,SAAP,WACE,OAAO76C,KAAK6gB,MAGP,YAAA1a,IAAP,SAAWuyB,GAET,OADA14B,KAAK06C,OAAOhiB,GACL14B,KAAK6gB,KAAK6X,IAGZ,YAAA/nB,IAAP,SAAW+nB,EAAgB92B,GAErBA,IADa5B,KAAK6gB,KAAK6X,KAEzB14B,KAAK6gB,KAAK6X,GAAU92B,EACpB5B,KAAK06C,OAAOnD,MAAM7e,KAIf,YAAA7N,OAAP,SAAc6N,GACRqhB,EAAOn5C,KAAKZ,KAAK6gB,KAAM6X,YAClB14B,KAAK6gB,KAAK6X,GACjB14B,KAAK06C,OAAOnD,MAAM7e,KAIf,YAAAnlB,MAAP,WACEvT,KAAKia,QAAQ,OAGR,YAAAA,QAAP,SAAekb,GAAf,WACMA,GACF31B,OAAOyJ,KAAKksB,GAAS/sB,SAAQ,SAAAswB,GAC3B,EAAK/nB,IAAI+nB,EAAQvD,EAAQuD,OAE3Bl5B,OAAOyJ,KAAKjJ,KAAK6gB,MAAMzY,SAAQ,SAAAswB,GACxBqhB,EAAOn5C,KAAKu0B,EAASuD,IACxB,EAAK7N,OAAO6N,OAIhBl5B,OAAOyJ,KAAKjJ,KAAK6gB,MAAMzY,SAAQ,SAAAswB,GAC7B,EAAK7N,OAAO6N,OAIpB,EA1DA,G,SA4DgBoiB,EACdjK,GAEA,OAAO,IAAI,EAAiBA,G,iBC0C5B,WAAY,GAAZ,WAAY,kBACV,IAAAkK,oBAAA,IAAe,EAAf,aACA,IAAAC,qBAAA,IAAgB,GAAhB,EAGEC,EADI,KACJA,kBACAC,EAFI,KAEJA,oBACAC,EAHI,KAGJA,wBAGFn7C,KAAKg7C,cAAgBA,EAErBh7C,KAAKi7C,kBAAoBtI,GAAK,SAAC90B,GAC7B,OAAOo9B,EAAkBr6C,KAAK,EAAMid,KACnC,CACD+8B,aAAA,SAAa,G,IACXx7B,EAAA,EAAAA,MACA4Q,EAAA,EAAAA,UACAorB,EAAA,EAAAA,aACAC,EAAA,EAAAA,eACA5sB,EAAA,EAAAA,gBAKA,GAAI2sB,EAAaptB,iBAAiB,EAChC,OAAO+sB,EAAa9B,OAClBmC,EAAaptB,MACb5O,EACAqP,EACA5lB,KAAKC,UAAUuyC,GACfrrB,EAAUnmB,OAMlB7J,KAAKk7C,oBAAsBvI,GAAK,SAAC90B,GAC/B,OAAOq9B,EAAoBt6C,KAAK,EAAMid,KACrC,CACD+8B,aAAA,SAAa,G,IACXtvC,EAAA,EAAAA,aACA0kB,EAAA,EAAAA,UACAO,EAAA,EAAAA,YAEA,GAAIA,EAAY6qB,aAAaptB,iBAAiB,EAC5C,OAAO+sB,EAAa9B,OAClB1oB,EAAY6qB,aAAaptB,MACzB1iB,EACAilB,EAAY9B,gBACZ5lB,KAAKC,UAAUynB,EAAY8qB,gBAC3BrrB,EAAUnmB,OAMlB7J,KAAKm7C,wBAA0BxI,GAAK,SAAC90B,GACnC,OAAOs9B,EAAwBv6C,KAAK,EAAMid,KACzC,CACD+8B,aAAY,SAAC,G,IAAE3yC,EAAA,EAAAA,MAAO8E,EAAA,EAAAA,MAAOwjB,EAAA,EAAAA,YAC3B,GAAIA,EAAY6qB,aAAaptB,iBAAiB,EAC5C,OAAO+sB,EAAa9B,OAClB1oB,EAAY6qB,aAAaptB,MACzB/lB,EACA8E,EACAlE,KAAKC,UAAUynB,EAAY8qB,oBAkXvC,OA5VS,YAAAC,mBAAP,SACEz9B,GAEA,OAAO7d,KAAKu7C,sBAAqB,2BAC5B19B,GAAO,CACViS,mBAAmB,KAClB9tB,QAWE,YAAAu5C,sBAAP,SAAgC,G,IAC9BvtB,EAAA,EAAAA,MACA5O,EAAA,EAAAA,MACAnZ,EAAA,EAAAA,UACA6c,EAAA,EAAAA,eACA,IAAAgN,yBAAA,IAAoB,GAApB,EACA,IAAA0rB,cAAA,IAAS,EAAT,eACAC,EAAA,EAAAA,wBACA/sC,EAAA,EAAAA,OAGMgtC,EAAkB,YAAmBt8B,GAE3CnZ,EAAY,YAAO,GAAI,YAAiBy1C,GAAkBz1C,GAE1D,IAAMX,EAA4B,CAEhC0oB,MAAK,EACLwB,iBAAkB9gB,GAAUA,EAAO8gB,iBACnCmsB,eAAiBjtC,GAAUA,EAAOitC,gBAAmB,IAGjDC,EAAa57C,KAAKi7C,kBAAkB,CACxC77B,MAAK,EACL4Q,UAAW,CACTrqB,KAAM,KACNkE,GAAI2xC,EACJ9xC,WAAW,EACXI,SAAU,SAEZsxC,aAAc91C,EACd+1C,eAAgBp1C,EAChBwoB,gBAAiBgtB,IAGbI,EACJD,EAAWE,SAAWF,EAAWE,QAAQn7C,OAAS,EAqBpD,OAnBIk7C,IAAsB/rB,GACxB8rB,EAAWE,QAAS1zC,SAAQ,SAAAgL,GAC1B,IAAIA,EAAK2oC,UACT,MAAM,cAUNj5B,GACE,YAAQA,EAAgB84B,EAAW55C,UACrC45C,EAAW55C,OAAS8gB,GAIjB,CACL9gB,OAAQ45C,EAAW55C,OACnB2jB,UAAWk2B,IAsBP,YAAAZ,kBAAR,SAA0B,G,IACxB77B,EAAA,EAAAA,MACA4Q,EAAA,EAAAA,UACAorB,EAAA,EAAAA,aACAC,EAAA,EAAAA,eAEA,IAAA5sB,uBAAA,IAAkB,EAAlB,IAEMwB,EAAiB,YAAkB7Q,GACnChZ,EAAY,YAAuBgZ,GAEnCmR,EAA2B,CAC/BnR,MAAK,EACL8Q,YAHkB,YAAkB9pB,GAIpCg1C,aAAY,EACZC,eAAc,EACd5sB,gBAAe,GAGjB,OAAOzuB,KAAKk7C,oBAAoB,CAC9B5vC,aAAc2kB,EAAe3kB,aAC7B0kB,UAAS,EACTO,YAAW,KAIP,YAAA2qB,oBAAR,SAA4B,GAA5B,WACE5vC,EAAA,EAAAA,aACA0kB,EAAA,EAAAA,UACAO,EAAA,EAAAA,YAEQL,EAAA,EAAAA,YAAakrB,EAAA,EAAAA,aAAc,IAAAC,eAC7BW,EAA0B,CAAEh6C,OAAQ,MAEpCi6C,EAA2C,GAE3C7iC,EAAsBgiC,EAAaptB,MAAM7nB,IAAI6pB,EAAUnmB,IAEvDC,EACHsP,GAAUA,EAAO+X,YACA,eAAjBnB,EAAUnmB,IAAuB,cAClC,EAEF,SAASqyC,EAAiBl6C,G,MAKxB,OAJIA,EAAO85C,UACTE,EAAYF,QAAUE,EAAYF,SAAW,IAC7C,EAAAE,EAAYF,SAAQ14C,KAAI,QAAIpB,EAAO85C,UAE9B95C,EAAOA,OAsEhB,OAnEAsJ,EAAaC,WAAWnD,SAAQ,SAAAkB,G,MAC9B,GAAK,YAAcA,EAAWrD,GAK9B,GAAI,YAAQqD,GAAY,CACtB,IAAMqnB,EAAcurB,EAClB,EAAKC,aAAa/iC,EAAQtP,EAAUR,EAAWinB,SAGtB,IAAhBI,GACTsrB,EAAe74C,OAAI,MAChB,YAAuBkG,IAAaqnB,EACrC,QAGC,CACL,IAAIpkB,OAAQ,EAEZ,GAAI,YAAiBjD,GACnBiD,EAAWjD,OAKX,KAFAiD,EAAW2jB,EAAY5mB,EAAUvF,KAAKnC,QAGpC,MAAM,WAIV,IAAMgvB,EACJrkB,EAASqkB,eAAiBrkB,EAASqkB,cAAc7sB,KAAKnC,MAElDmZ,GACH6V,GACDL,EAAY9B,gBAAgBuB,EAAWY,EAAewqB,GAExD,GAAIrgC,EAAO,CACT,IAAIqhC,EAAqB,EAAKlB,oBAAoB,CAChD5vC,aAAciB,EAASjB,aACvB0kB,UAAS,EACTO,YAAW,IAGC,cAAVxV,GAAyBqhC,EAAmBN,UAC9CM,EAAqB,OAAH,IAAG,CAAH,eACbA,GAAkB,CACrBN,QAASM,EAAmBN,QAAQx0C,KAAI,SAAA8L,GACtC,kCAAYA,GAAI,CAAE2oC,WAAW,UAKnCE,EAAe74C,KAAK84C,EAAcE,SAOxCJ,EAAYh6C,OAAS,YAAei6C,GAEhCj8C,KAAKg7C,cAIFgB,GAGD,YAAAG,aAAR,SACE/iC,EACAtP,EACA7B,EACAsoB,GAEQ,QAAA8qB,eAA2BD,EAAA,EAAAA,aAS7BiB,EA4IV,SACEjjC,EACAtP,EACAtB,EACAC,EACAnD,EACA,GAAE,EAAAg3C,U,IAAWn0C,EAAA,EAAAA,WAETo0C,EAAe/zC,GACfC,GAAQN,KAKVo0C,EAAe,YAAgBA,EAAc9zC,EAAMN,IAGrD,IAAIq0C,OAAgC,EAEpC,GAAIpjC,QAIsB,KAHxBojC,EAAapjC,EAAOmjC,KAIlBj3C,EAAQq2C,gBACY,iBAAb7xC,EACP,CAEA,IAAMnE,EAAOL,EAAQq2C,eAAe7xC,GACpC,GAAInE,EAAM,CAER,IAAM82C,EAAW92C,EAAK6C,GAClBi0C,IACFD,EAAaC,EAASrjC,EAAQ3Q,EAAM,CAClC8mB,YAAA,SAAYmtB,GACV,IAAM7yC,EAAKvE,EAAQkqB,iBAAkBktB,GACrC,OAAO7yC,GAAM,YAAU,CACrBA,GAAE,EACFC,SAAU4yC,EAASvrB,kBASjC,QAA0B,IAAfqrB,EACT,MAAO,CACLx6C,OAAQw6C,EACRV,QAAS,CAAC,CACR1iC,OAAM,EACN5Q,UAAW+zC,EACXR,WAAW,KAKb,YAAYS,KACdA,EAAaA,EAAWG,MAG1B,MAAO,CACL36C,OAAQw6C,GA3MgBI,CACtBxjC,EACAtP,EAVgB7B,EAAMlE,KAAKnC,MAChB,YAAyBqG,EAAOhC,GAY3Cm1C,EAVqB,CACrBkB,UAAW,YAAuBr0C,GAClCE,WAAY,YAA0BF,EAAOhC,KAY/C,OAAItG,MAAM2S,QAAQ+pC,EAAgBr6C,QACzBhC,KAAK68C,mBACVR,EACAr8C,KAAKm7C,wBAAwB,CAC3BlzC,MAAK,EACL8E,MAAOsvC,EAAgBr6C,OACvBuuB,YAAW,KAMZtoB,EAAMqD,aAUmB,MAA1B+wC,EAAgBr6C,OAEXq6C,EAIFr8C,KAAK68C,mBACVR,EACAr8C,KAAKk7C,oBAAoB,CACvB5vC,aAAcrD,EAAMqD,aACpB0kB,UAAWqsB,EAAgBr6C,OAC3BuuB,YAAW,MApBbusB,EAA6B70C,EAAOo0C,EAAgBr6C,QAChDhC,KAAKg7C,cAGFqB,IAqBH,YAAAQ,mBAAR,W,IACE,IAEIf,EAFJ,kDASA,OANAiB,EAAY30C,SAAQ,SAAAwzC,GACdA,EAAWE,UACbA,EAAUA,GAAW,IACb14C,KAAI,MAAZ04C,EAAgBF,EAAWE,YAGxB,CACL95C,OAAQ+6C,EAAY55C,MAAOnB,OAC3B85C,QAAO,IAIH,YAAAX,wBAAR,SAAgC,GAAhC,IAKMW,EALN,OACE7zC,EAAA,EAAAA,MACA8E,EAAA,EAAAA,MACAwjB,EAAA,EAAAA,YAIA,SAAS2rB,EAAiBc,GAMxB,OALIA,EAAYlB,UACdA,EAAUA,GAAW,IACb14C,KAAI,MAAZ04C,EAAgBkB,EAAYlB,SAGvBkB,EAAYh7C,OAoCrB,OAjCA+K,EAAQA,EAAMzF,KAAI,SAAAgqB,GAEhB,OAAa,OAATA,EACK,KAIL3xB,MAAM2S,QAAQgf,GACT4qB,EAAc,EAAKf,wBAAwB,CAChDlzC,MAAK,EACL8E,MAAOukB,EACPf,YAAW,KAKXtoB,EAAMqD,aACD4wC,EAAc,EAAKhB,oBAAoB,CAC5C5vC,aAAcrD,EAAMqD,aACpB0kB,UAAWsB,EACXf,YAAW,MAIfusB,EAA6B70C,EAAOqpB,GAE7BA,MAGLtxB,KAAKg7C,cAIF,CAAEh5C,OAAQ+K,EAAO+uC,QAAO,IAEnC,E,GAEA,SAASgB,EACP70C,EACArG,GAEA,IAAKqG,EAAMqD,cAAgB,YAAU1J,GACnC,MAAM,YAQV,SAASq7C,IACP,OAAO,E,iBC/iBP,WAAsBp8B,QAAA,IAAAA,MAA8BrhB,OAAOW,OAAO,OAA5C,KAAA0gB,OAyBxB,OAvBS,YAAAg6B,SAAP,WACE,OAAO76C,KAAK6gB,MAGP,YAAA1a,IAAP,SAAWuyB,GACT,OAAO14B,KAAK6gB,KAAK6X,IAGZ,YAAA/nB,IAAP,SAAW+nB,EAAgB92B,GACzB5B,KAAK6gB,KAAK6X,GAAU92B,GAGf,YAAAipB,OAAP,SAAc6N,GACZ14B,KAAK6gB,KAAK6X,QAAU,GAGf,YAAAnlB,MAAP,WACEvT,KAAK6gB,KAAOrhB,OAAOW,OAAO,OAGrB,YAAA8Z,QAAP,SAAekb,GACbn1B,KAAK6gB,KAAOsU,GAAW31B,OAAOW,OAAO,OAEzC,E,qBCaA,2D,OACS,EAAAwF,KAAO,a,EAChB,OAFgC,iBAEhC,E,CAFgC1B,OAuBhC,+BAoYA,OAlXS,YAAAi5C,kBAAP,SAAyB,G,IACvB99B,EAAA,EAAAA,MACApd,EAAA,EAAAA,OACA,IAAAgsB,aAAA,IAAQ,EAAR,MACA/nB,EAAA,EAAAA,UACAupB,EAAA,EAAAA,iBACAisB,EAAA,EAAAA,wBASA,OAAOz7C,KAAKm9C,mBAAmB,CAC7BzkB,OAAQ,aACR12B,OAAM,EACNgE,SAAUoZ,EACV4O,MAAK,EACL/nB,UAAS,EACTupB,iBAAgB,EAChBisB,wBAAuB,KAIpB,YAAA0B,mBAAP,SAA0B,G,IACxBzkB,EAAA,EAAAA,OACA12B,EAAA,EAAAA,OACAgE,EAAA,EAAAA,SACA,IAAAgoB,aAAA,IAAQ,EAAR,MACA/nB,EAAA,EAAAA,UACAupB,EAAA,EAAAA,iBACAisB,EAAA,EAAAA,wBAWM2B,EAAsB,YAAuBp3C,GAEnD,IACE,OAAOhG,KAAKq9C,yBAAyB,CACnCr7C,OAAM,EACN02B,OAAM,EACNptB,aAAc8xC,EAAoB9xC,aAClChG,QAAS,CACP0oB,MAAK,EACLsvB,cAAe,GACfr3C,UAAW,YACT,GACA,YAAiBm3C,GACjBn3C,GAEFupB,iBAAgB,EAChBU,YAAa,YAAkB,YAAuBlqB,IACtDy1C,wBAAuB,KAG3B,MAAO16C,GACP,M,SAtGmCyD,EAAcwB,GAErD,IAAMu3C,EAAgB,IAAI,EACxB,8CAA8C10C,KAAKC,UAAU9C,IAI/D,OAFAu3C,EAAc35C,SAAW,KAAOY,EAAMZ,QACtC25C,EAAcppC,MAAQ3P,EAAM2P,MACrBopC,EA+FGC,CAAyBz8C,EAAGiF,KAI/B,YAAAq3C,yBAAP,SAAgC,GAAhC,WACEr7C,EAAA,EAAAA,OACA02B,EAAA,EAAAA,OACAptB,EAAA,EAAAA,aACAhG,EAAA,EAAAA,QAOQW,EAAA,EAAAA,UAAW+nB,EAAA,EAAAA,MAAOkC,EAAA,EAAAA,YAoG1B,OAlGA5kB,EAAaC,WAAWnD,SAAQ,SAAAkB,G,MAC9B,GAAK,YAAcA,EAAWrD,GAI9B,GAAI,YAAQqD,GAAY,CACtB,IAAMm0C,EAAyB,YAAuBn0C,GAChD1H,EAAaI,EAAOy7C,GAE1B,QAAqB,IAAV77C,EACT,EAAK87C,kBAAkB,CACrBhlB,OAAM,EACN92B,MAAK,EACLqG,MAAOqB,EACPhE,QAAO,QAEJ,CACL,IAAIq4C,GAAY,EACZC,GAAW,EACXt0C,EAAUnB,YAAcmB,EAAUnB,WAAWxH,SAE/Cg9C,EAAYr0C,EAAUnB,WAAW6C,MAC/B,SAAA3C,GAAa,OAAAA,EAAUtE,MAAiC,UAAzBsE,EAAUtE,KAAKnC,SAWhDg8C,EAAWt0C,EAAUnB,WAAW6C,MAC9B,SAAA3C,GAAa,OAAAA,EAAUtE,MAAiC,WAAzBsE,EAAUtE,KAAKnC,WAI7C+7C,IAAcC,GAAYt4C,EAAQm2C,6BAapC,CAEL,IAAIlvC,OAAQ,EAER,YAAiBjD,GACnBiD,EAAWjD,GAGXiD,GAAY2jB,GAAe,IAAI5mB,EAAUvF,KAAKnC,OAC1B,cAAoC,IAG1D,IAAIi8C,GAAU,EACd,GAAIv4C,EAAQm2C,yBAA2BlvC,EAASqkB,cAAe,CAI7D,IAAM/mB,EAAK6uB,GAAU,OACfmhB,EAAU,YAAU,CAAEhwC,GAAE,EAAEC,cAAUC,IACpC+zC,EAAgC,CAGpC9vB,MAAO,IAAI+vB,GAAW,KAAG,EAACl0C,GAAK7H,EAAM,IACrC25C,eAAgB,IAEZ5gC,EAAQzV,EAAQm2C,wBACpB5B,EACAttC,EAASqkB,cAAc7sB,KAAKnC,MAC5Bk8C,GAEG,cAGLD,IAAY9iC,EAGV8iC,GACF,EAAKR,yBAAyB,CAC5Br7C,OAAM,EACNsJ,aAAciB,EAASjB,aACvBotB,OAAM,EACNpzB,QAAO,QAMR0oB,GAGD,YAAA0vB,kBAAR,SAA0B,G,MAapB3yB,EACAizB,EAbJ/1C,EAAA,EAAAA,MACArG,EAAA,EAAAA,MACA82B,EAAA,EAAAA,OACApzB,EAAA,EAAAA,QAOQW,EAAA,EAAAA,UAAWupB,EAAA,EAAAA,iBAAkBxB,EAAA,EAAAA,MAK/BiwB,EAAyB,YAAsBh2C,EAAOhC,GAG5D,GAAKgC,EAAMqD,cAA0B,OAAV1J,EAQpB,GAAIjC,MAAM2S,QAAQ1Q,GAAQ,CAC/B,IAAMs8C,EAAiBxlB,EAAM,IAAIulB,EAEjClzB,EAAa/qB,KAAKm+C,kBAChBv8C,EACAs8C,EACAj2C,EAAMqD,aACNhG,OAEG,CAEL,IAAI84C,EAAiB1lB,EAAM,IAAIulB,EAC3Bv0C,GAAY,EAQhB,GAJK20C,EAAcD,KACjBA,EAAc,IAAMA,GAGlB5uB,EAAkB,CACpB,IAAM8uB,EAAa9uB,EAAiB5tB,GAOJ,aAAW,aAKzC08C,GACuB,iBAAfA,GAA0C,IAAfA,KAEnCF,EAAcE,EACd50C,GAAY,GAIX60C,GAAgBH,EAAan2C,EAAO3C,EAAQg4C,gBAC/Ct9C,KAAKq9C,yBAAyB,CAC5B3kB,OAAQ0lB,EACRp8C,OAAQJ,EACR0J,aAAcrD,EAAMqD,aACpBhG,QAAO,IAMX,IAAMwE,EAAWlI,EAAMuvB,WACvBpG,EAAa,YAAU,CAAElhB,GAAIu0C,EAAat0C,SAAQ,GAAIJ,GAMtD,IAAM80C,GADNR,EAAchwB,EAAM7nB,IAAIuyB,KAENslB,EAAYC,GAC9B,GAAIO,IAAczzB,GAAc,YAAUyzB,GAAY,CACpD,IAAMC,OAAqC10C,IAAvBy0C,EAAU10C,SACxB40C,OAA2B30C,IAAbD,EACd60C,EACJF,GAAeC,GAAeF,EAAU10C,WAAaA,EAQ3C,gBACV,kBAS2B,qBAQzB00C,EAAU90C,YAGRi1C,EAIGj1C,GACHskB,EAAMnD,OAAO2zB,EAAU30C,IAqErC,SAAS+0C,EACPC,EACAC,EACAt5C,GAEA,GAAIq5C,IAAiBC,EACnB,OAAO,EAGT,IAAMp1C,EAAYlE,EAAMW,IAAI04C,GACtBE,EAAOv5C,EAAMW,IAAI24C,GACnBE,GAAc,EAElBx/C,OAAOyJ,KAAKS,GAAWtB,SAAQ,SAAAQ,GAC7B,IAAMhH,EAAQ8H,EAAUd,GAClBq2C,EAAYF,EAAKn2C,GAGrB,YAAUhH,IACVy8C,EAAcz8C,EAAMiI,KACpB,YAAUo1C,KACT,YAAQr9C,EAAOq9C,IAChBL,EAAmBh9C,EAAMiI,GAAIo1C,EAAUp1C,GAAIrE,KAE3Cw5C,GAAc,MAIlBx5C,EAAMqlB,OAAOg0B,GACb,IAAMK,EAAe,OAAH,IAAG,CAAH,eAAQx1C,GAAcq1C,GAExC,GAAI,YAAQG,EAAcH,GACxB,OAAOC,EAIT,OADAx5C,EAAMmL,IAAImuC,EAASI,IACZ,EAtGGN,CAAmBJ,EAAU30C,GAAKkhB,EAAuBlhB,GAAImkB,UA7GnEjD,EACW,MAATnpB,GAAkC,iBAAVA,EAGpB,CAAE+D,KAAM,OAAQg3C,KAAM/6C,GAEtBA,GA6GRo8C,EAAchwB,EAAM7nB,IAAIuyB,KACH,YAAQ3N,EAAYizB,EAAYC,KACnDjwB,EAAMrd,IAAI+nB,EAAM,2BACXslB,KAAW,MACbC,GAAiBlzB,EAAU,MAK1B,YAAAozB,kBAAR,SACEv8C,EACAs8C,EACA5yC,EACAhG,GAJF,WAME,OAAO1D,EAAM0F,KAAI,SAACgqB,EAAWjd,GAC3B,GAAa,OAATid,EACF,OAAO,KAGT,IAAI6tB,EAAgBjB,EAAW,IAAI7pC,EAEnC,GAAI1U,MAAM2S,QAAQgf,GAChB,OAAO,EAAK6sB,kBAAkB7sB,EAAM6tB,EAAY7zC,EAAchG,GAGhE,IAAIoE,GAAY,EAEhB,GAAIpE,EAAQkqB,iBAAkB,CAC5B,IAAM8uB,EAAah5C,EAAQkqB,iBAAiB8B,GAExCgtB,IACFa,EAAab,EACb50C,GAAY,GAahB,OATK60C,GAAgBY,EAAY7zC,EAAchG,EAAQg4C,gBACrD,EAAKD,yBAAyB,CAC5B3kB,OAAQymB,EACRn9C,OAAQsvB,EACRhmB,aAAY,EACZhG,QAAO,IAIJ,YACL,CAAEuE,GAAIs1C,EAAYr1C,SAAUwnB,EAAKH,YACjCznB,OAIR,EApYA,GAwYA,SAAS20C,EAAcx0C,GACrB,MAAiB,MAAVA,EAAG,GA0CZ,SAAS00C,GACP7lB,EACAzwB,EACAq1C,GAEA,IAAKA,EACH,OAAO,EAGT,GAAIA,EAAc5kB,GAAS,CACzB,GAAI4kB,EAAc5kB,GAAQ13B,QAAQiH,IAAU,EAC1C,OAAO,EAEPq1C,EAAc5kB,GAAQt1B,KAAK6E,QAG7Bq1C,EAAc5kB,GAAU,CAACzwB,GAG3B,OAAO,ECveT,IAAMm3C,GAAqC,CACzC3wB,gBAAiB,IAAI4wB,EACrB7vB,iBAMF,SAAwCxtB,GACtC,GAAIA,EAAOmvB,WAAY,CACrB,QAAkBpnB,IAAd/H,EAAO6H,GACT,OAAU7H,EAAOmvB,WAAU,IAAInvB,EAAO6H,GAExC,QAAmBE,IAAf/H,EAAOs9C,IACT,OAAUt9C,EAAOmvB,WAAU,IAAInvB,EAAOs9C,IAG1C,OAAO,MAdPC,aAAa,EACbC,eAAe,EACfxE,eAAe,GAejB,IAAMjB,GAASv6C,OAAOU,UAAUL,eAEhC,eACE,WACkB4/C,EAGAvxC,EACAwxC,GALlB,MAOE,YAAMlgD,OAAOW,OAAO,QAAM,K,OANV,EAAAs/C,eAGA,EAAAvxC,SACA,EAAAwxC,c,EAoBpB,OA1B0ClgD,OAAA,IAAAA,CAAA,KAWjC,YAAAq7C,SAAP,WACE,kCACK76C,KAAKkO,OAAO2sC,YACZ76C,KAAK6gB,OAOL,YAAA1a,IAAP,SAAWuyB,GACT,OAAOqhB,GAAOn5C,KAAKZ,KAAK6gB,KAAM6X,GAC1B14B,KAAK6gB,KAAK6X,GACV14B,KAAKkO,OAAO/H,IAAIuyB,IAExB,EA1BA,CAA0CqlB,G,eA4CxC,WAAYrvC,QAAA,IAAAA,MAAA,IAAZ,MACE,cAAO,KAZD,EAAAixC,QAAU,IAAIlsC,IAEd,EAAAmsC,sBAAwB,IAAIn6C,IAG5B,EAAAs1C,aAAe,IAAIxB,EAAgB,KAInC,EAAAsG,kBAA4B,EAIlC,EAAKnxC,OAAM,2BAAQ0wC,IAAkB1wC,GAGhC,EAAKA,OAAeoxC,kBAIvB,EAAKpxC,OAAOitC,eAAkB,EAAKjtC,OAAeoxC,iBAG/C,EAAKpxC,OAAeqxC,iBAIvB,EAAKrxC,OAAOitC,eAAkB,EAAKjtC,OAAeqxC,gBAGpD,EAAKR,cAAgB,EAAK7wC,OAAO6wC,YAKjC,EAAK1+B,KAAO,EAAKnS,OAAO8wC,cACpB,IAAI,EACJ,IAAIzB,EAOR,EAAKiC,eAAiB,EAAKn/B,KAE3B,EAAKo/B,YAAc,IAAI,EACvB,EAAKC,YAAc,IAAI,EAAY,CACjCnF,aAAc,EAAKA,aACnBC,cAAetsC,EAAOssC,gBAGxB,IAAMx1C,EAAQ,EACN26C,EAAA,EAAAA,oB,OACR,EAAKA,oBAAsBxN,GAAK,SAAC/Z,GAC/B,OAAOunB,EAAoBv/C,KAAK,EAAMg4B,KACrC,CACDgiB,aAAA,SAAahiB,GACX,IAAIA,EAAE7I,aAMF6I,EAAE9V,eAQN,OAAItd,EAAMqb,gBAAgB,EAGjBrb,EAAMu1C,aAAa9B,OACxBrgB,EAAExZ,MACFvW,KAAKC,UAAU8vB,EAAE3yB,iBALrB,K,EAoMR,OAjRmC,iBAyF1B,YAAAi1B,QAAP,SAAera,GAEb,OADIA,GAAM7gB,KAAK6gB,KAAK5G,QAAQ4G,GACrB7gB,MAGF,YAAAq6B,QAAP,SAAetK,GACb,YADa,IAAAA,OAAA,IACLA,EAAa/vB,KAAKggD,eAAiBhgD,KAAK6gB,MAAMg6B,YAGjD,YAAAuF,KAAP,SAAeviC,GACb,GAA8B,iBAAnBA,EAAQ29B,aAC0B,IAAlCx7C,KAAK6gB,KAAK1a,IAAI0X,EAAQ29B,QAC/B,OAAO,KAGD,IAAA/sB,EAAA,YAAAA,gBACFgtB,EAA0BhtB,GAAmBA,EAAgB1T,MAEnE,OAAO/a,KAAKkgD,YAAY5E,mBAAmB,CACzCttB,MAAOnQ,EAAQkS,WAAa/vB,KAAKggD,eAAiBhgD,KAAK6gB,KACvDzB,MAAOpf,KAAK+1B,kBAAkBlY,EAAQuB,OACtCnZ,UAAW4X,EAAQ5X,UACnBu1C,OAAQ39B,EAAQ29B,OAChBC,wBAAuB,EACvB34B,eAAgBjF,EAAQiF,eACxBpU,OAAQ1O,KAAK0O,UACT,MAGD,YAAA+pB,MAAP,SAAaA,GACH,IAAAhK,EAAA,YAAAA,gBACFgtB,EAA0BhtB,GAAmBA,EAAgB1T,MAEnE/a,KAAKigD,YAAY9C,mBAAmB,CAClCzkB,OAAQD,EAAMC,OACd12B,OAAQy2B,EAAMz2B,OACdiE,UAAWwyB,EAAMxyB,UACjBD,SAAUhG,KAAK+1B,kBAAkB0C,EAAMrZ,OACvC4O,MAAOhuB,KAAK6gB,KACZ2O,iBAAkBxvB,KAAK0O,OAAO8gB,iBAC9BisB,wBAAuB,IAGzBz7C,KAAKqgD,oBAGA,YAAAxwB,KAAP,SAAezQ,GACL,IAAAqP,EAAA,YAAAA,gBACFgtB,EAA0BhtB,GAAmBA,EAAgB1T,MAEnE,OAAO/a,KAAKkgD,YAAY3E,sBAAsB,CAC5CvtB,MAAO5O,EAAM2Q,WAAa/vB,KAAKggD,eAAiBhgD,KAAK6gB,KACrDzB,MAAOpf,KAAK+1B,kBAAkB3W,EAAMA,OACpCnZ,UAAWmZ,EAAMnZ,UACjB6pB,kBAAmB1Q,EAAM0Q,kBACzBhN,eAAgB1D,EAAM0D,eACtB24B,wBAAuB,EACvB/sC,OAAQ1O,KAAK0O,UAIV,YAAAgoB,MAAP,SAAaA,GAAb,WAGE,OAFA12B,KAAK2/C,QAAQjsC,IAAIgjB,GAEV,WACL,EAAKipB,QAAQ90B,OAAO6L,KAIjB,YAAA4pB,MAAP,SAAalhC,GACX,MAAM,YAGD,YAAAiP,MAAP,WAIE,OAHAruB,KAAK6gB,KAAKtN,QACVvT,KAAKqgD,mBAEE7+C,QAAQC,WAGV,YAAA03B,iBAAP,SAAwBonB,GAKtB,IAJA,IAAMC,EAAoC,GACtCC,EAAe,EACfC,EAAQ1gD,KAAKggD,eAEVU,aAAiB,IAClBA,EAAMjB,eAAiBc,IACvBE,EAEFD,EAAUp9C,KAAKs9C,GAEjBA,EAAQA,EAAMxyC,OAGhB,GAAIuyC,EAAe,EAAG,CAMpB,IAHAzgD,KAAKggD,eAAiBU,EAGfF,EAAU7/C,OAAS,GAAG,CAC3B,IAAM,EAAQ6/C,EAAUr9C,MACxBnD,KAAKk5B,mBAAmB,EAAMwmB,YAAa,EAAMD,cAGnDz/C,KAAKqgD,qBAIF,YAAAnnB,mBAAP,SACEwmB,EAIAD,GAEM,IAAE5+B,EAAF,KAAEA,KAAMg/B,EAAR,KAAQA,iBACd7/C,KAAK6/C,kBAAmB,EAEI,iBAAjBJ,IAGTz/C,KAAK6gB,KAAO7gB,KAAKggD,eAAiB,IAAI,GAIpCP,EACAz/C,KAAKggD,eACLN,IAIJ,IACEA,EAAY1/C,MADd,QAGEA,KAAK6/C,iBAAmBA,EACxB7/C,KAAK6gB,KAAOA,EAId7gB,KAAKqgD,oBAGA,YAAA1nB,4BAAP,SACE+mB,EACA71C,GAEA,OAAO7J,KAAKk5B,mBAAmBwmB,EAAa71C,IAGvC,YAAAksB,kBAAP,SAAyB/vB,GACvB,GAAIhG,KAAKu/C,YAAa,CACpB,IAAIv9C,EAAShC,KAAK4/C,sBAAsBz5C,IAAIH,GAS5C,OARKhE,IACHA,EAAS,YAAsBgE,GAC/BhG,KAAK4/C,sBAAsBjvC,IAAI3K,EAAUhE,GAIzChC,KAAK4/C,sBAAsBjvC,IAAI3O,EAAQA,IAElCA,EAET,OAAOgE,GAGC,YAAAq6C,iBAAV,sBACOrgD,KAAK6/C,kBACR7/C,KAAK2/C,QAAQv3C,SAAQ,SAAAwwB,GAAK,SAAKunB,oBAAoBvnB,OAM/C,YAAAunB,oBAAR,SAA4BvnB,GAC1BA,EAAEjC,SACA32B,KAAK6vB,KAAK,CACRzQ,MAAOwZ,EAAExZ,MACTnZ,UAAW2yB,EAAE3yB,UACb6c,eAAgB8V,EAAE9V,gBAAkB8V,EAAE9V,iBACtCiN,WAAY6I,EAAE7I,eAItB,E,CAjRmC,I,yGNyBtB4wB,EAAqB,CAChCC,KAhB2C,CAC3CC,cAAc,EACdC,mBAAmB,GAenBC,QAZqB,CAErBC,OAAQ,MACR,eAAgB,oBAUhBnjC,QAPqB,CACrBxZ,OAAQ,SASG48C,EAAmB,SAAC58B,EAAUriB,EAAQ4B,GACjD,IAAMY,EAAQ,IAAIP,MAAML,GAOxB,MALAY,EAAMT,KAAO,cACbS,EAAM6f,SAAWA,EACjB7f,EAAM08C,WAAa78B,EAAS88B,OAC5B38C,EAAMxC,OAASA,EAETwC,GA8HK48C,EAA0B,SAACxhD,EAAG6C,GACzC,IAAI4+C,EACJ,IACEA,EAAax4C,KAAKC,UAAUlJ,GAC5B,MAAOmB,GACP,IAAMugD,EAAa,WAInB,MADAA,EAAWA,WAAavgD,EAClBugD,EAER,OAAOD,GO/NIE,EAAiB,SAACC,QAAA,IAAAA,MAAA,IAE3B,QAAAC,WAAA,mBAEA,IAAAC,MACAZ,EAAA,EAAAA,kBACAa,EAAA,EAAAA,iBACA,yEPoIwB,SAACC,GAC3B,IAAKA,GAA4B,oBAAVF,MAAuB,CAG5C,KADsB,oBAAX9nB,QAAkC,aACvC,YOpIRioB,CAAaD,GAKRA,IACHA,EAAUF,OAGZ,IAAMI,EAAa,CACjBlB,KAAM,CAAEE,kBAAiB,GACzBjjC,QAASkkC,EAAeC,aACxBC,YAAaF,EAAeE,YAC5BlB,QAASgB,EAAehB,SAG1B,OAAO,IAAI,KAAW,SAAAr6C,GACpB,IAAIw7C,EPuMiB,SACvBx7C,EACAy7C,GAEA,IACMC,EADU17C,EAAU27C,aACCZ,IAE3B,OAAIW,IAE8B,mBAAhBD,EACTA,EAAYz7C,GAEXy7C,GAA0B,YOnNlBG,CAAU57C,EAAW+6C,GAE/Bn8C,EAAUoB,EAAU27C,aAQpBE,EAAyB,GAC/B,GAAIj9C,EAAQusB,gBAAiB,CACrB,wBAAE,IAAA9tB,KAAMykB,EAAA,EAAAA,QACV,IACF+5B,EAAuB,6BAA+B,GAEpD/5B,IACF+5B,EAAuB,gCAAkC/5B,GAI7D,IAiBIg6B,EAjBEC,EAAiB,OAAH,IAAG,CAAH,GAAQF,EAA2Bj9C,EAAQy7C,SAEzD2B,EAAgB,CACpB9B,KAAMt7C,EAAQs7C,KACd/iC,QAASvY,EAAQ08C,aACjBC,YAAa38C,EAAQ28C,YACrBlB,QAAS0B,GAIL,EPyG8B,SACtC/7C,EACAi8C,G,IACA,wDAEA,IAAI9kC,EAAO,eACN8kC,EAAe9kC,QAAO,CACzBkjC,QAAS4B,EAAe5B,QACxBkB,YAAaU,EAAeV,cAE1BrB,EAAyB+B,EAAe/B,KAM5CgC,EAAQx6C,SAAQ,SAAAsG,GACdmP,EAAU,OAAH,IAAG,CAAH,GACFA,EACAnP,EAAOmP,QAAO,CACjBkjC,QAAS,OAAF,IAAE,CAAF,GACFljC,EAAQkjC,QACRryC,EAAOqyC,WAGVryC,EAAOuzC,cAAapkC,EAAQokC,YAAcvzC,EAAOuzC,aAErDrB,EAAO,OAAH,IAAG,CAAH,GACCA,EACAlyC,EAAOkyC,SAKN,IAAAl7C,EAAAgB,EAAAhB,cAAek3B,EAAA,EAAAA,WAAY32B,EAAA,EAAAA,UAAWmZ,EAAA,EAAAA,MACxChd,EAAa,CAAEsD,cAAa,EAAEO,UAAS,GAO7C,OALI26C,EAAKE,oBAAoB1+C,EAAaw6B,WAAaA,GAGnDgkB,EAAKC,eAAez+C,EAAagd,MAAQ,gBAAMA,IAE5C,CACLvB,QAAO,EACPzb,KAAI,GOrJE,UAAEyb,EAAA,EAAAA,QAASzb,EAAA,EAAAA,KAQjB,IAAMyb,EAAgBglC,OAAQ,CACtB,MPuF2B,WACrC,GAA+B,oBAApBC,gBACT,MAAO,CAAEN,YAAY,EAAOK,QAAQ,GAEtC,IAAML,EAAa,IAAIM,gBAEvB,MAAO,CAAEN,WAAU,EAAEK,OADNL,EAAWK,QO5FhB,GAAE,IAAAL,WAAyBK,EAAA,EAAAA,QACjCL,EAAaO,KACIllC,EAAgBglC,OAASA,GAc5C,GANElB,IACCj7C,EAAU0Y,MAAM/Y,YAAY2E,MALF,SAAC1L,GAC5B,MAAkB,wBAAXA,EAAEkH,MAAkD,aAAhBlH,EAAEoH,eAM7CmX,EAAQxZ,OAAS,OAGI,QAAnBwZ,EAAQxZ,OAAkB,CACtB,MA8EZ,SAA0B69C,EAAmB9/C,GAG3C,IAAM4gD,EAAc,GACdC,EAAgB,SAACr6C,EAAahH,GAClCohD,EAAY5/C,KAAQwF,EAAG,IAAIs6C,mBAAmBthD,KAG5C,UAAWQ,GACb6gD,EAAc,QAAS7gD,EAAKgd,OAE1Bhd,EAAKsD,eACPu9C,EAAc,gBAAiB7gD,EAAKsD,eAEtC,GAAItD,EAAK6D,UAAW,CAClB,IAAIk9C,OAAmB,EACvB,IACEA,EAAsB/B,EACpBh/C,EAAK6D,WAGP,MAAOq7C,GACP,MAAO,CAAEA,WAAU,GAErB2B,EAAc,YAAaE,GAE7B,GAAI/gD,EAAKw6B,WAAY,CACnB,IAAIwmB,OAAoB,EACxB,IACEA,EAAuBhC,EACrBh/C,EAAKw6B,YAGP,MAAO0kB,GACP,MAAO,CAAEA,WAAU,GAErB2B,EAAc,aAAcG,GAS9B,IAAI72C,EAAW,GACb82C,EAAcnB,EACVoB,EAAgBpB,EAAUlhD,QAAQ,MACjB,IAAnBsiD,IACF/2C,EAAW21C,EAAUqB,OAAOD,GAC5BD,EAAcnB,EAAUqB,OAAO,EAAGD,IAEpC,IAAME,GAAkD,IAA9BH,EAAYriD,QAAQ,KAAc,IAAM,IAGlE,MAAO,CAAEyiD,OADPJ,EAAcG,EAAoBR,EAAYlpC,KAAK,KAAOvN,GApIlD,MAAEk3C,EAAA,EAAAA,OAAQnC,EAAA,EAAAA,WAChB,GAAIA,EACF,OAAO,YAAUA,GAEnBY,EAAYuB,OAEZ,IACG5lC,EAAgBzb,KAAOg/C,EAAwBh/C,GAChD,MAAOk/C,GACP,OAAO,YAAUA,GAIrB,OAAO,IAAI,KAAW,SAAAj3B,GPRe,IAAAze,EO8DnC,OArDAg2C,EAAQM,EAAWrkC,GAChB3b,MAAK,SAAAmiB,GAEJ,OADA3d,EAAUg9C,WAAW,CAAEr/B,SAAQ,IACxBA,KAERniB,MPdgC0J,EOcDlF,EPde,SAAC2d,GACtD,OACEA,EACGs/B,OACAzhD,MAAK,SAAA0hD,GACJ,IACE,OAAO/6C,KAAKm0B,MAAM4mB,GAClB,MAAO/5B,GACP,IAAMy3B,EAAaz3B,EAKnB,OAJAy3B,EAAWv9C,KAAO,mBAClBu9C,EAAWj9B,SAAWA,EACtBi9B,EAAWJ,WAAa78B,EAAS88B,OACjCG,EAAWsC,SAAWA,EACfpiD,QAAQE,OAAO4/C,OAIzBp/C,MAAK,SAACF,GA2BL,OA1BIqiB,EAAS88B,QAAU,KAErBF,EACE58B,EACAriB,EACA,iDAAiDqiB,EAAS88B,QAM3DxhD,MAAM2S,QAAQtQ,IACdA,EAAOnC,eAAe,SACtBmC,EAAOnC,eAAe,WAGvBohD,EACE58B,EACAriB,EACA,2CACErC,MAAM2S,QAAQ1G,GACVA,EAAWtE,KAAI,SAAArE,GAAM,OAAAA,EAAGyC,iBACxBkG,EAAWlG,eAAa,MAI3B1D,QO7BNE,MAAK,SAAAF,GAIJ,OAFAqoB,EAASvoB,KAAKE,GACdqoB,EAAS1E,WACF3jB,KAER0gB,OAAM,SAAAmH,GAEY,eAAbA,EAAI9lB,OAOJ8lB,EAAI7nB,QAAU6nB,EAAI7nB,OAAOmP,QAAU0Y,EAAI7nB,OAAO6e,MA2BhDwJ,EAASvoB,KAAK+nB,EAAI7nB,QAEpBqoB,EAAS7lB,MAAMqlB,OAGZ,WAGD24B,GAAYA,EAAWqB,gB,kBAoEjC,WAAY33B,G,OACV,YAAMq1B,EAAer1B,GAAMoP,UAAQ,KAEvC,OAL8B,iBAK9B,E,CAL8B","file":"vendors~app.bundle.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(condition: any, message?: string | number) {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nfunction wrapConsoleMethod(method: \"warn\" | \"error\") {\n  return function () {\n    return console[method].apply(console, arguments as any);\n  } as (...args: any[]) => void;\n}\n\nexport namespace invariant {\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\n// Code that uses ts-invariant with rollup-plugin-invariant may want to\n// import this process stub to avoid errors evaluating process.env.NODE_ENV.\n// However, because most ESM-to-CJS compilers will rewrite the process import\n// as tsInvariant.process, which prevents proper replacement by minifiers, we\n// also attempt to define the stub globally when it is not already defined.\nlet processStub: NodeJS.Process = { env: {} } as any;\nexport { processStub as process };\nif (typeof process === \"object\") {\n  processStub = process;\n} else try {\n  // Using Function to evaluate this assignment in global scope also escapes\n  // the strict mode of the current module, thereby allowing the assignment.\n  // Inspired by https://github.com/facebook/regenerator/pull/369.\n  Function(\"stub\", \"process = stub\")(processStub);\n} catch (atLeastWeTried) {\n  // The assignment can fail if a Content Security Policy heavy-handedly\n  // forbids Function usage. In those environments, developers should take\n  // extra care to replace process.env.NODE_ENV in their production builds,\n  // or define an appropriate global.process polyfill.\n}\n\nexport default invariant;\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: Record<any, any>;\n}\n\nlet apolloContext: React.Context<ApolloContextValue>;\n\nexport function getApolloContext() {\n  if (!apolloContext) {\n    apolloContext = React.createContext<ApolloContextValue>({});\n  }\n  return apolloContext;\n}\n\nexport function resetApolloContext() {\n  apolloContext = React.createContext<ApolloContextValue>({});\n}\n","import {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\nimport { invariant } from 'ts-invariant';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to saftey check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\nimport { invariant } from 'ts-invariant';\n\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children\n}) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context = {}) => {\n        if (client && context.client !== client) {\n          context = Object.assign({}, context, { client });\n        }\n\n        invariant(\n          context.client,\n          'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.'\n        );\n\n        return (\n          <ApolloContext.Provider value={context}>\n            {children}\n          </ApolloContext.Provider>\n        );\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject &&\n    (idObject as IdValue | JsonValue).type === 'id' &&\n    typeof (idObject as IdValue).generated === 'boolean';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new InvariantError(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  FieldNode,\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n} from 'graphql';\n\nimport { visit } from 'graphql/language/visitor';\n\nimport { invariant } from 'ts-invariant';\n\nimport { argumentsObjectFromField } from './storeUtils';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function getDirectiveInfoFromField(\n  field: FieldNode,\n  variables: Object,\n): DirectiveInfo {\n  if (field.directives && field.directives.length) {\n    const directiveObj: DirectiveInfo = {};\n    field.directives.forEach((directive: DirectiveNode) => {\n      directiveObj[directive.name.value] = argumentsObjectFromField(\n        directive,\n        variables,\n      );\n    });\n    return directiveObj;\n  }\n  return null;\n}\n\nexport function shouldInclude(\n  selection: SelectionNode,\n  variables: { [name: string]: any } = {},\n): boolean {\n  return getInclusionDirectives(\n    selection.directives,\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(doc: DocumentNode) {\n  const names: string[] = [];\n\n  visit(doc, {\n    Directive(node) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], doc: DocumentNode) {\n  return getDirectiveNames(doc).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return (\n    document &&\n    hasDirectives(['client'], document) &&\n    hasDirectives(['export'], document)\n  );\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  return directives ? directives.filter(isInclusionDirective).map(directive => {\n    const directiveArguments = directive.arguments;\n    const directiveName = directive.name.value;\n\n    invariant(\n      directiveArguments && directiveArguments.length === 1,\n      `Incorrect number of arguments for the @${directiveName} directive.`,\n    );\n\n    const ifArgument = directiveArguments[0];\n    invariant(\n      ifArgument.name && ifArgument.name.value === 'if',\n      `Invalid argument for the @${directiveName} directive.`,\n    );\n\n    const ifValue: ValueNode = ifArgument.value;\n\n    // means it has to be a variable value if this is a valid @skip or @include directive\n    invariant(\n      ifValue &&\n        (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n      `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n    );\n\n    return { directive, ifArgument };\n  }) : [];\n}\n\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: [\n            {\n              kind: 'FragmentSpread',\n              name: {\n                kind: 'Name',\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n","/**\n * Adds the properties of one or more source objects to a target object. Works exactly like\n * `Object.assign`, but as a utility to maintain support for IE 11.\n *\n * @see https://github.com/apollostack/apollo-client/pull/1009\n */\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n): A & B & C & D & E;\nexport function assign(target: any, ...sources: Array<any>): any;\nexport function assign(\n  target: { [key: string]: any },\n  ...sources: Array<{ [key: string]: any }>\n): { [key: string]: any } {\n  sources.forEach(source => {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n    Object.keys(source).forEach(key => {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  invariant(mutationDef, 'Must contain a mutation definition.');\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  invariant(def, `GraphQL document is missing an operation`);\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from 'graphql';\nimport { visit } from 'graphql/language/visitor';\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\nimport { invariant } from 'ts-invariant';\nimport { isField, isInlineFragment } from './storeUtils';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll fist check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // docuemnt.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  return (\n    selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  checkDocument(doc);\n\n  let parentPath: string;\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      SelectionSet: {\n        enter(node, _key, _parent, path) {\n          const currentPath = path.join('-');\n\n          if (\n            !parentPath ||\n            currentPath === parentPath ||\n            !currentPath.startsWith(parentPath)\n          ) {\n            if (node.selections) {\n              const selectionsWithDirectives = node.selections.filter(\n                selection => hasDirectivesInSelection(directives, selection),\n              );\n\n              if (hasDirectivesInSelectionSet(directives, node, false)) {\n                parentPath = currentPath;\n              }\n\n              return {\n                ...node,\n                selections: selectionsWithDirectives,\n              };\n            } else {\n              return null;\n            }\n          }\n        },\n      },\n    }),\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ),\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            node.arguments.forEach(arg => {\n              if (argMatcher(arg)) {\n                argMatchCount += 1;\n              }\n            });\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n","export const canUseWeakMap = typeof WeakMap === 'function' && !(\n  typeof navigator === 'object' &&\n  navigator.product === 'ReactNative'\n);\n","const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper<T>(val: T, seen: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","import { isDevelopment, isTest } from './environment';\n\n// Taken (mostly) from https://github.com/substack/deep-freeze to avoid\n// import hassles with rollup.\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\nexport function maybeDeepFreeze(obj: any) {\n  if (isDevelopment() || isTest()) {\n    // Polyfilled Symbols potentially cause infinite / very deep recursion while deep freezing\n    // which is known to crash IE11 (https://github.com/apollographql/apollo-client/issues/3043).\n    const symbolIsPolyfilled =\n      typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n  return obj;\n}\n","const { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A :\n  T extends [infer A, infer B] ? A & B :\n  T extends [infer A, infer B, infer C] ? A & B & C :\n  T extends [infer A, infer B, infer C, infer D] ? A & B & C & D :\n  T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E :\n  T extends (infer U)[] ? U : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || {} as T;\n  const count = sources.length;\n  if (count > 1) {\n    const pastCopies: any[] = [];\n    target = shallowCopyForMerge(target, pastCopies);\n    for (let i = 1; i < count; ++i) {\n      target = mergeHelper(target, sources[i], pastCopies);\n    }\n  }\n  return target;\n}\n\nfunction isObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction mergeHelper(\n  target: any,\n  source: any,\n  pastCopies: any[],\n) {\n  if (isObject(source) && isObject(target)) {\n    // In case the target has been frozen, make an extensible copy so that\n    // we can merge properties into the copy.\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = shallowCopyForMerge(target, pastCopies);\n    }\n\n    Object.keys(source).forEach(sourceKey => {\n      const sourceValue = source[sourceKey];\n      if (hasOwnProperty.call(target, sourceKey)) {\n        const targetValue = target[sourceKey];\n        if (sourceValue !== targetValue) {\n          // When there is a key collision, we need to make a shallow copy of\n          // target[sourceKey] so the merge does not modify any source objects.\n          // To avoid making unnecessary copies, we use a simple array to track\n          // past copies, since it's safe to modify copies created earlier in\n          // the merge. We use an array for pastCopies instead of a Map or Set,\n          // since the number of copies should be relatively small, and some\n          // Map/Set polyfills modify their keys.\n          target[sourceKey] = mergeHelper(\n            shallowCopyForMerge(targetValue, pastCopies),\n            sourceValue,\n            pastCopies,\n          );\n        }\n      } else {\n        // If there is no collision, the target can safely share memory with\n        // the source, and the recursion can terminate here.\n        target[sourceKey] = sourceValue;\n      }\n    });\n\n    return target;\n  }\n\n  // If source (or target) is not an object, let source replace target.\n  return source;\n}\n\nfunction shallowCopyForMerge<T>(value: T, pastCopies: any[]): T {\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    pastCopies.indexOf(value) < 0\n  ) {\n    if (Array.isArray(value)) {\n      value = (value as any).slice(0);\n    } else {\n      value = {\n        __proto__: Object.getPrototypeOf(value),\n        ...value,\n      };\n    }\n    pastCopies.push(value);\n  }\n  return value;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (!isProduction() && !haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n}\n","const { toString, hasOwnProperty } = Object.prototype;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = Object.keys(a);\n      const bKeys = Object.keys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n","/* tslint:disable */\n\nimport zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.getVisitFn = getVisitFn;\nexports.BREAK = exports.QueryDocumentKeys = void 0;\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexports.QueryDocumentKeys = QueryDocumentKeys;\nvar BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexports.BREAK = BREAK;\n\nfunction visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + (0, _inspect.default)(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\n\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inspect;\n\nvar _nodejsCustomInspectSymbol = _interopRequireDefault(require(\"./nodejsCustomInspectSymbol\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(_nodejsCustomInspectSymbol.default)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\nvar _default = nodejsCustomInspectSymbol;\nexports.default = _default;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = devAssert;\n\nfunction devAssert(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = defineToJSON;\n\nvar _nodejsCustomInspectSymbol = _interopRequireDefault(require(\"./nodejsCustomInspectSymbol\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * The `defineToJSON()` function defines toJSON() and inspect() prototype\n * methods, if no function provided they become aliases for toString().\n */\nfunction defineToJSON(classObject) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (_nodejsCustomInspectSymbol.default) {\n    classObject.prototype[_nodejsCustomInspectSymbol.default] = fn;\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.syntaxError = syntaxError;\n\nvar _GraphQLError = require(\"./GraphQLError\");\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\nfunction syntaxError(source, position, description) {\n  return new _GraphQLError.GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLocation = getLocation;\n\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dedentBlockStringValue = dedentBlockStringValue;\nexports.getBlockStringIndentation = getBlockStringIndentation;\nexports.printBlockString = printBlockString;\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenKind = void 0;\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n\nexports.TokenKind = TokenKind;\n","import { ApolloClient } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport {\n  ApolloContextValue,\n  parser,\n  DocumentType,\n  operationName\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { CommonOptions } from '../types';\n\nexport abstract class OperationData<TOptions = any> {\n  public isMounted: boolean = false;\n  public previousOptions: CommonOptions<TOptions> = {} as CommonOptions<\n    TOptions\n  >;\n  public context: ApolloContextValue = {};\n  public client: ApolloClient<object> | undefined;\n\n  private options: CommonOptions<TOptions> = {} as CommonOptions<TOptions>;\n\n  constructor(options?: CommonOptions<TOptions>, context?: ApolloContextValue) {\n    this.options = options || ({} as CommonOptions<TOptions>);\n    this.context = context || {};\n  }\n\n  public getOptions(): CommonOptions<TOptions> {\n    return this.options;\n  }\n\n  public setOptions(\n    newOptions: CommonOptions<TOptions>,\n    storePrevious: boolean = false\n  ) {\n    if (storePrevious && !isEqual(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n    this.options = newOptions;\n  }\n\n  public abstract execute(...args: any): any;\n  public abstract afterExecute(...args: any): void | (() => void);\n  public abstract cleanup(): void;\n\n  protected unmount() {\n    this.isMounted = false;\n  }\n\n  protected refreshClient() {\n    const client =\n      (this.options && this.options.client) ||\n      (this.context && this.context.client);\n\n    invariant(\n      !!client,\n      'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ' +\n        'ApolloClient instance in via options.'\n    );\n\n    let isNew = false;\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n    return {\n      client: this.client as ApolloClient<object>,\n      isNew\n    };\n  }\n\n  protected verifyDocumentType(document: DocumentNode, type: DocumentType) {\n    const operation = parser(document);\n    const requiredOperationName = operationName(type);\n    const usedOperationName = operationName(operation.type);\n    invariant(\n      operation.type === type,\n      `Running a ${requiredOperationName} requires a graphql ` +\n        `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n    );\n  }\n}\n","import {\n  ApolloQueryResult,\n  ApolloError,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  UpdateQueryOptions,\n  SubscribeToMoreOptions,\n} from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  QueryResult,\n  ObservableQueryFields,\n} from '@apollo/react-common';\n\nimport {\n  QueryPreviousData,\n  QueryOptions,\n  QueryCurrentObservable,\n  QueryTuple,\n  QueryLazyOptions,\n} from '../types';\nimport { OperationData } from './OperationData';\n\nexport class QueryData<TData, TVariables> extends OperationData {\n  public onNewData: () => void;\n\n  private previousData: QueryPreviousData<TData, TVariables> = {};\n  private currentObservable: QueryCurrentObservable<TData, TVariables> = {};\n  private runLazy: boolean = false;\n  private lazyOptions?: QueryLazyOptions<TVariables>;\n\n  constructor({\n    options,\n    context,\n    onNewData,\n  }: {\n    options: QueryOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    onNewData: () => void;\n  }) {\n    super(options, context);\n    this.onNewData = onNewData;\n  }\n\n  public execute(): QueryResult<TData, TVariables> {\n    this.refreshClient();\n\n    const { skip, query } = this.getOptions();\n    if (skip || query !== this.previousData.query) {\n      this.removeQuerySubscription();\n      this.previousData.query = query;\n    }\n\n    this.updateObservableQuery();\n\n    if (this.isMounted) this.startQuerySubscription();\n\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  }\n\n  public executeLazy(): QueryTuple<TData, TVariables> {\n    return !this.runLazy\n      ? [\n          this.runLazyQuery,\n          {\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            called: false,\n            data: undefined,\n          } as QueryResult<TData, TVariables>,\n        ]\n      : [this.runLazyQuery, this.execute()];\n  }\n\n  // For server-side rendering\n  public fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    const options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n\n    // currentObservable.query is already assigned the registered SSR observable in initializeObservableQuery.\n    const obs = this.currentObservable.query!;\n    const currentResult = obs.getCurrentResult();\n    return currentResult.loading ? obs.result() : false;\n  }\n\n  public afterExecute({ lazy = false }: { lazy?: boolean } = {}) {\n    this.isMounted = true;\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n    }\n\n    this.previousOptions = this.getOptions();\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    this.removeQuerySubscription();\n    delete this.currentObservable.query;\n    delete this.previousData.result;\n  }\n\n  public getOptions() {\n    const options = super.getOptions();\n\n    if (this.lazyOptions) {\n      options.variables = {\n        ...options.variables,\n        ...this.lazyOptions.variables,\n      };\n      options.context = {\n        ...options.context,\n        ...this.lazyOptions.context,\n      };\n    }\n\n    // skip is not supported when using lazy query execution.\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  }\n\n  public ssrInitiated() {\n    return this.context && this.context.renderPromises;\n  }\n\n  private runLazyQuery = (options?: QueryLazyOptions<TVariables>) => {\n    this.cleanup();\n    this.runLazy = true;\n    this.lazyOptions = options;\n    this.onNewData();\n  };\n\n  private getExecuteResult = (): QueryResult<TData, TVariables> => {\n    const result = this.getQueryResult();\n    this.startQuerySubscription();\n    return result;\n  };\n\n  private getExecuteSsrResult() {\n    const ssrDisabled = this.getOptions().ssr === false;\n    const fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    const ssrLoading = {\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined,\n      stale: false,\n      client: this.client,\n      ...this.observableQueryFields(),\n    } as QueryResult<TData, TVariables>;\n\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    if (ssrDisabled && (this.ssrInitiated() || fetchDisabled)) {\n      this.previousData.result = ssrLoading;\n      return ssrLoading;\n    }\n\n    let result;\n    if (this.ssrInitiated()) {\n      result =\n        this.context.renderPromises!.addQueryPromise(\n          this,\n          this.getExecuteResult\n        ) || ssrLoading;\n    }\n\n    return result;\n  }\n\n  private prepareObservableQueryOptions() {\n    const options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    const displayName = options.displayName || 'Query';\n\n    // Set the fetchPolicy to cache-first for network-only and cache-and-network\n    // fetches for server side renders.\n    if (\n      this.ssrInitiated() &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return {\n      ...options,\n      displayName,\n      context: options.context,\n      metadata: { reactComponent: { displayName } },\n    };\n  }\n\n  private initializeObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    if (this.ssrInitiated()) {\n      this.currentObservable.query = this.context!.renderPromises!.getSSRObservable(\n        this.getOptions()\n      );\n    }\n\n    if (!this.currentObservable.query) {\n      const observableQueryOptions = this.prepareObservableQueryOptions();\n\n      this.previousData.observableQueryOptions = {\n        ...observableQueryOptions,\n        children: null,\n      };\n      this.currentObservable.query = this.refreshClient().client.watchQuery({\n        ...observableQueryOptions,\n      });\n\n      if (this.ssrInitiated()) {\n        this.context?.renderPromises?.registerSSRObservable(\n          this.currentObservable.query,\n          observableQueryOptions\n        );\n      }\n    }\n  }\n\n  private updateObservableQuery() {\n    // If we skipped initially, we may not have yet created the observable\n    if (!this.currentObservable.query) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    const newObservableQueryOptions = {\n      ...this.prepareObservableQueryOptions(),\n      children: null,\n    };\n\n    if (\n      !isEqual(\n        newObservableQueryOptions,\n        this.previousData.observableQueryOptions\n      )\n    ) {\n      this.previousData.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable\n        .query!.setOptions(newObservableQueryOptions)\n        // The error will be passed to the child container, so we don't\n        // need to log it here. We could conceivably log something if\n        // an option was set. OTOH we don't log errors w/ the original\n        // query. See https://github.com/apollostack/react-apollo/issues/404\n        .catch(() => {});\n    }\n  }\n\n  private startQuerySubscription() {\n    if (this.currentObservable.subscription || this.getOptions().skip) return;\n\n    const obsQuery = this.currentObservable.query!;\n    this.currentObservable.subscription = obsQuery.subscribe({\n      next: ({ loading, networkStatus, data }) => {\n        const previousResult = this.previousData.result;\n\n        // Make sure we're not attempting to re-render similar results\n        if (\n          previousResult &&\n          previousResult.loading === loading &&\n          previousResult.networkStatus === networkStatus &&\n          isEqual(previousResult.data, data)\n        ) {\n          return;\n        }\n\n        this.onNewData();\n      },\n      error: (error) => {\n        this.resubscribeToQuery();\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n        const previousResult = this.previousData.result;\n        if (\n          (previousResult && previousResult.loading) ||\n          !isEqual(error, this.previousData.error)\n        ) {\n          this.previousData.error = error;\n          this.onNewData();\n        }\n      },\n    });\n  }\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `observableQuery` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.currentObservable.query!.getLastError();\n    const lastResult = this.currentObservable.query!.getLastResult();\n    this.currentObservable.query!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.currentObservable.query!, {\n      lastError,\n      lastResult,\n    });\n  }\n\n  private getQueryResult(): QueryResult<TData, TVariables> {\n    let result: any = this.observableQueryFields();\n    const options = this.getOptions();\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (options.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n        called: true,\n      };\n    } else {\n      // Fetch the current result (if any) from the store.\n      const currentResult = this.currentObservable.query!.getCurrentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error, data } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      result = {\n        ...result,\n        loading,\n        networkStatus,\n        error,\n        called: true,\n      };\n\n      if (loading) {\n        const previousData =\n          this.previousData.result && this.previousData.result.data;\n        result.data =\n          previousData && data\n            ? {\n                ...previousData,\n                ...data,\n              }\n            : previousData || data;\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.query!.getLastResult() || ({} as any))\n            .data,\n        });\n      } else {\n        const { fetchPolicy } = this.currentObservable.query!.options;\n        const { partialRefetch } = options;\n        if (\n          partialRefetch &&\n          !data &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as `undefined` since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading,\n          });\n          result.refetch();\n          return result;\n        }\n\n        result.data = data;\n      }\n    }\n\n    result.client = this.client;\n    this.previousData.loading =\n      (this.previousData.result && this.previousData.result.loading) || false;\n    this.previousData.result = result;\n\n    // Any query errors that exist are now available in `result`, so we'll\n    // remove the original errors from the `ObservableQuery` query store to\n    // make sure they aren't re-displayed on subsequent (potentially error\n    // free) requests/responses.\n    this.currentObservable.query &&\n      this.currentObservable.query.resetQueryStoreErrors();\n\n    return result;\n  }\n\n  private handleErrorOrCompleted() {\n    const obsQuery = this.currentObservable.query;\n    if (!obsQuery || !this.previousData.result) return;\n\n    const { data, loading, error } = this.previousData.result;\n\n    if (!loading) {\n      const { query, variables, onCompleted, onError } = this.getOptions();\n\n      // No changes, so we won't call onError/onCompleted.\n      if (\n        this.previousOptions &&\n        !this.previousData.loading &&\n        isEqual(this.previousOptions.query, query) &&\n        isEqual(this.previousOptions.variables, variables)\n      ) {\n        return;\n      }\n\n      if (onCompleted && !error) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  }\n\n  private removeQuerySubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n\n  private obsRefetch = (variables?: TVariables) =>\n    this.currentObservable.query!.refetch(variables);\n\n  private obsFetchMore = <K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>\n  ) => this.currentObservable.query!.fetchMore(fetchMoreOptions);\n\n  private obsUpdateQuery = <TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>\n    ) => TData\n  ) => this.currentObservable.query!.updateQuery(mapFn);\n\n  private obsStartPolling = (pollInterval: number) => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.startPolling(pollInterval);\n  };\n\n  private obsStopPolling = () => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.stopPolling();\n  };\n\n  private obsSubscribeToMore = <\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) => this.currentObservable.query!.subscribeToMore(options);\n\n  private observableQueryFields() {\n    const observable = this.currentObservable.query!;\n    return {\n      variables: observable.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore,\n    } as ObservableQueryFields<TData, TVariables>;\n  }\n}\n","import { ApolloError } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  OperationVariables,\n  ExecutionResult,\n  MutationFunctionOptions,\n  MutationResult\n} from '@apollo/react-common';\n\nimport { MutationOptions, MutationTuple } from '../types';\nimport { OperationData } from './OperationData';\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables\n> extends OperationData {\n  private mostRecentMutationId: number;\n  private result: MutationResult<TData>;\n  private previousResult?: MutationResult<TData>;\n  private setResult: (result: MutationResult<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    result: MutationResult<TData>;\n    setResult: (result: MutationResult<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResult<TData>) {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    result.client = this.refreshClient().client;\n    return [this.runMutation, result] as MutationTuple<TData, TVariables>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables\n    > = {} as MutationFunctionOptions<TData, TVariables>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        this.onMutationError(error, mutationId);\n        if (!this.getOptions().onError) throw error;\n      });\n  };\n\n  private mutate(\n    mutationFunctionOptions: MutationFunctionOptions<TData, TVariables>\n  ) {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context: mutationContext = {},\n      awaitRefetchQueries = false,\n      fetchPolicy\n    } = this.getOptions();\n    const mutateOptions = { ...mutationFunctionOptions };\n\n    const mutateVariables = Object.assign(\n      {},\n      variables,\n      mutateOptions.variables\n    );\n    delete mutateOptions.variables;\n\n    return this.refreshClient().client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries:\n        mutateOptions.refetchQueries || this.getOptions().refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context: mutationContext,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions\n    });\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: ExecutionResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    const { onError } = this.getOptions();\n\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResult<TData>) {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !isEqual(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n    }\n  }\n}\n","import { equal as isEqual } from '@wry/equality';\nimport { ApolloContextValue, SubscriptionResult } from '@apollo/react-common';\n\nimport { OperationData } from './OperationData';\nimport { SubscriptionCurrentObservable, SubscriptionOptions } from '../types';\n\nexport class SubscriptionData<\n  TData = any,\n  TVariables = any\n> extends OperationData<SubscriptionOptions<TData, TVariables>> {\n  private setResult: any;\n  private currentObservable: SubscriptionCurrentObservable = {};\n\n  constructor({\n    options,\n    context,\n    setResult\n  }: {\n    options: SubscriptionOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    setResult: any;\n  }) {\n    super(options, context);\n    this.setResult = setResult;\n    this.initialize(options);\n  }\n\n  public execute(result: SubscriptionResult<TData>) {\n    if (this.getOptions().skip === true) {\n      this.cleanup();\n      return {\n        loading: false,\n        error: undefined,\n        data: undefined,\n        variables: this.getOptions().variables\n      };\n    }\n\n    let currentResult = result;\n    if (this.refreshClient().isNew) {\n      currentResult = this.getLoadingResult();\n    }\n\n    let { shouldResubscribe } = this.getOptions();\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.getOptions());\n    }\n\n    if (\n      shouldResubscribe !== false &&\n      this.previousOptions &&\n      Object.keys(this.previousOptions).length > 0 &&\n      (this.previousOptions.subscription !== this.getOptions().subscription ||\n        !isEqual(this.previousOptions.variables, this.getOptions().variables) ||\n        this.previousOptions.skip !== this.getOptions().skip)\n    ) {\n      this.cleanup();\n      currentResult = this.getLoadingResult();\n    }\n\n    this.initialize(this.getOptions());\n    this.startSubscription();\n\n    this.previousOptions = this.getOptions();\n    return { ...currentResult, variables: this.getOptions().variables };\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n  }\n\n  public cleanup() {\n    this.endSubscription();\n    delete this.currentObservable.query;\n  }\n\n  private initialize(options: SubscriptionOptions<TData, TVariables>) {\n    if (this.currentObservable.query || this.getOptions().skip === true) return;\n    this.currentObservable.query = this.refreshClient().client.subscribe({\n      query: options.subscription,\n      variables: options.variables,\n      fetchPolicy: options.fetchPolicy\n    });\n  }\n\n  private startSubscription() {\n    if (this.currentObservable.subscription) return;\n    this.currentObservable.subscription = this.currentObservable.query!.subscribe(\n      {\n        next: this.updateCurrentData.bind(this),\n        error: this.updateError.bind(this),\n        complete: this.completeSubscription.bind(this)\n      }\n    );\n  }\n\n  private getLoadingResult() {\n    return {\n      loading: true,\n      error: undefined,\n      data: undefined\n    };\n  }\n\n  private updateResult(result: SubscriptionResult) {\n    if (this.isMounted) {\n      this.setResult(result);\n    }\n  }\n\n  private updateCurrentData(result: SubscriptionResult<TData>) {\n    const { onSubscriptionData } = this.getOptions();\n\n    this.updateResult({\n      data: result.data,\n      loading: false,\n      error: undefined\n    });\n\n    if (onSubscriptionData) {\n      onSubscriptionData({\n        client: this.refreshClient().client,\n        subscriptionData: result\n      });\n    }\n  }\n\n  private updateError(error: any) {\n    this.updateResult({\n      error,\n      loading: false\n    });\n  }\n\n  private completeSubscription() {\n    const { onSubscriptionComplete } = this.getOptions();\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  }\n\n  private endSubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n}\n","import React from 'react';\nimport { invariant } from 'ts-invariant';\nimport { getApolloContext } from '@apollo/react-common';\nimport ApolloClient from 'apollo-client';\n\nexport function useApolloClient(): ApolloClient<object> {\n  const { client } = React.useContext(getApolloContext());\n  invariant(\n    client,\n    'No Apollo Client instance can be found. Please ensure that you ' +\n      'have called `ApolloProvider` higher up in your tree.'\n  );\n  return client!;\n}\n","import { ObservableQuery } from 'apollo-client';\nimport { QueryOptions } from '../types';\nimport { DocumentNode } from 'graphql';\nimport { QueryData } from '../data/QueryData';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n};\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<QueryOptions<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    observable: ObservableQuery<any, TVariables>,\n    props: QueryOptions<TData, TVariables>\n  ) {\n    this.lookupQueryInfo(props).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ) {\n    return this.lookupQueryInfo(props).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: QueryData<TData, TVariables>,\n    finish: () => React.ReactNode\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance.getOptions());\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance.getOptions(),\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        })\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","import {\n  ExecutionResult,\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: ExecutionResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<ExecutionResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: ExecutionResult) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result as FetchResult<T>;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult as ExecutionResult);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: ExecutionResult) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n","export const version = \"2.6.8\"","import Observable from 'zen-observable-ts';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nimport { getOperationName } from 'apollo-utilities';\nimport { invariant, InvariantError } from 'ts-invariant';\nexport { getOperationName };\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new InvariantError(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX We're assuming here that query and variables will be serialized in\n  // the same order, which might not always be true.\n  const { query, variables, operationName } = operation;\n  return JSON.stringify([operationName, query, variables]);\n}\n","import Observable from 'zen-observable-ts';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nexport function empty(): ApolloLink {\n  return new ApolloLink(() => Observable.of());\n}\n\nexport function from(links: ApolloLink[]): ApolloLink {\n  if (links.length === 0) return empty();\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n}\n\nexport function split(\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right?: ApolloLink | RequestHandler,\n): ApolloLink {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right || new ApolloLink(passthrough));\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n}\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    invariant.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new InvariantError('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\n\nvar _inspect = _interopRequireDefault(require(\"../jsutils/inspect\"));\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _defineToJSON = _interopRequireDefault(require(\"../jsutils/defineToJSON\"));\n\nvar _syntaxError = require(\"../error/syntaxError\");\n\nvar _kinds = require(\"./kinds\");\n\nvar _source = require(\"./source\");\n\nvar _lexer = require(\"./lexer\");\n\nvar _directiveLocation = require(\"./directiveLocation\");\n\nvar _tokenKind = require(\"./tokenKind\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\n\nfunction parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\n\nfunction parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return type;\n}\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n    sourceObj instanceof _source.Source || (0, _devAssert.default)(0, \"Must provide Source. Received: \".concat((0, _inspect.default)(sourceObj)));\n    this._lexer = (0, _lexer.createLexer)(sourceObj);\n    this._options = options || {};\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(_tokenKind.TokenKind.NAME);\n    return {\n      kind: _kinds.Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return {\n        kind: _kinds.Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.DOLLAR);\n    return {\n      kind: _kinds.Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: _kinds.Kind.SELECTION_SET,\n      selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: _kinds.Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return {\n      kind: _kinds.Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: _kinds.Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {\n      return {\n        kind: _kinds.Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: _kinds.Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.experimentalFragmentVariables) {\n      return {\n        kind: _kinds.Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case _tokenKind.TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case _tokenKind.TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case _tokenKind.TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: _kinds.Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case _tokenKind.TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: _kinds.Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case _tokenKind.TokenKind.STRING:\n      case _tokenKind.TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case _tokenKind.TokenKind.NAME:\n        if (token.value === 'true' || token.value === 'false') {\n          this._lexer.advance();\n\n          return {\n            kind: _kinds.Kind.BOOLEAN,\n            value: token.value === 'true',\n            loc: this.loc(token)\n          };\n        } else if (token.value === 'null') {\n          this._lexer.advance();\n\n          return {\n            kind: _kinds.Kind.NULL,\n            loc: this.loc(token)\n          };\n        }\n\n        this._lexer.advance();\n\n        return {\n          kind: _kinds.Kind.ENUM,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case _tokenKind.TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: _kinds.Kind.STRING,\n      value: token.value,\n      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: _kinds.Kind.LIST,\n      values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: _kinds.Kind.OBJECT,\n      fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return {\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(_tokenKind.TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.AT);\n    return {\n      kind: _kinds.Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(_tokenKind.TokenKind.BRACKET_R);\n      type = {\n        kind: _kinds.Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {\n      return {\n        kind: _kinds.Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: _kinds.Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);\n    return {\n      kind: _kinds.Kind.SCHEMA_DEFINITION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(_tokenKind.TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || // Legacy support for the SDL?\n      this._options.allowLegacySDLImplementsInterfaces && this.peek(_tokenKind.TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    // Legacy support for the SDL?\n    if (this._options.allowLegacySDLEmptyFields && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: _kinds.Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(_tokenKind.TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *   - extend interface Name Directives[Const]? FieldsDefinition\n   *   - extend interface Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(_tokenKind.TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(_tokenKind.TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(_tokenKind.TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (_directiveLocation.DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    if (!this._options.noLocation) {\n      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat(getTokenDesc(token)));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token)));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken || this._lexer.token;\n    return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token)));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\n(0, _defineToJSON.default)(Loc, function () {\n  return {\n    start: this.start,\n    end: this.end\n  };\n});\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, \" \\\"\").concat(value, \"\\\"\") : token.kind;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLError = GraphQLError;\nexports.printError = printError;\n\nvar _isObjectLike = _interopRequireDefault(require(\"../jsutils/isObjectLike\"));\n\nvar _location = require(\"../language/location\");\n\nvar _printLocation = require(\"../language/printLocation\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return (0, _location.getLocation)(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push((0, _location.getLocation)(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (_extensions == null && originalError != null) {\n    var originalExtensions = originalError.extensions;\n\n    if ((0, _isObjectLike.default)(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return printError(this);\n    }\n  }\n});\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nfunction printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + (0, _printLocation.printLocation)(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + (0, _printLocation.printSourceLocation)(error.source, location);\n    }\n  }\n\n  return output;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isObjectLike;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nfunction isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printLocation = printLocation;\nexports.printSourceLocation = printSourceLocation;\n\nvar _location = require(\"../language/location\");\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nfunction printLocation(location) {\n  return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\n\nfunction printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return ['', subline];\n    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Kind = void 0;\n\n/**\n * The set of allowed kind values for AST nodes.\n */\nvar Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n\nexports.Kind = Kind;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Source = void 0;\n\nvar _devAssert = _interopRequireDefault(require(\"../jsutils/devAssert\"));\n\nvar _defineToStringTag = _interopRequireDefault(require(\"../jsutils/defineToStringTag\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nvar Source = function Source(body, name, locationOffset) {\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  this.locationOffset.line > 0 || (0, _devAssert.default)(0, 'line in locationOffset is 1-indexed and must be positive');\n  this.locationOffset.column > 0 || (0, _devAssert.default)(0, 'column in locationOffset is 1-indexed and must be positive');\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.Source = Source;\n(0, _defineToStringTag.default)(Source);\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = defineToStringTag;\n\n/**\n * The `defineToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method defineToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nfunction defineToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLexer = createLexer;\nexports.isPunctuatorToken = isPunctuatorToken;\n\nvar _defineToJSON = _interopRequireDefault(require(\"../jsutils/defineToJSON\"));\n\nvar _syntaxError = require(\"../error/syntaxError\");\n\nvar _blockString = require(\"./blockString\");\n\nvar _tokenKind = require(\"./tokenKind\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== _tokenKind.TokenKind.EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === _tokenKind.TokenKind.COMMENT);\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n\n\n// @internal\nfunction isPunctuatorToken(token) {\n  var kind = token.kind;\n  return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;\n}\n/**\n * Helper function for constructing the Token object.\n */\n\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\n(0, _defineToJSON.default)(Tok, function () {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n});\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? _tokenKind.TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(_tokenKind.TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Tok(_tokenKind.TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Tok(_tokenKind.TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(_tokenKind.TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(_tokenKind.TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(_tokenKind.TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(_tokenKind.TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(_tokenKind.TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw (0, _syntaxError.syntaxError)(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or e\n\n\n  if (code === 46 || code === 69 || code === 101) {\n    throw (0, _syntaxError.syntaxError)(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Tok(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw (0, _syntaxError.syntaxError)(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Tok(_tokenKind.TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _syntaxError.syntaxError)(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw (0, _syntaxError.syntaxError)(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw (0, _syntaxError.syntaxError)(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Tok(_tokenKind.TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw (0, _syntaxError.syntaxError)(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw (0, _syntaxError.syntaxError)(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Tok(_tokenKind.TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectiveLocation = void 0;\n\n/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n\nexports.DirectiveLocation = DirectiveLocation;\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","module.exports = require('./lib/Observable.js').Observable;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Observable = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// === Symbol Support ===\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\n\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\n\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type: type,\n      value: value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type: type,\n      value: value\n    }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription =\n/*#__PURE__*/\nfunction () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: \"closed\",\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver =\n/*#__PURE__*/\nfunction () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: \"next\",\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: \"error\",\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: \"closed\",\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable =\n/*#__PURE__*/\nfunction () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: \"subscribe\",\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscription;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n      var C = getSpecies(this);\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: SymbolObservable,\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n      if (x == null) throw new TypeError(x + ' is not an object');\n      var method = getMethod(x, SymbolObservable);\n\n      if (method) {\n        var observable = method.call(x);\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n        if (isObservable(observable) && observable.constructor === C) return observable;\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, SymbolIterator);\n\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var _item = _step.value;\n                  observer.next(_item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: \"of\",\n    value: function of() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nexports.Observable = Observable;\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.print = print;\n\nvar _visitor = require(\"./visitor\");\n\nvar _blockString = require(\"./blockString\");\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, {\n    leave: printDocASTReducer\n  });\n} // TODO: provide better type coverage in future\n\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? (0, _blockString.printBlockString)(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction isMultiline(string) {\n  return string.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray && maybeArray.some(isMultiline);\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n      selectionSet: nestedSelSet || undefined,\n    };\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DataProxy } from './DataProxy';\n\nexport namespace Cache {\n  export type WatchCallback = (newData: any) => void;\n  export interface EvictionResult {\n    success: Boolean;\n  }\n\n  export interface ReadOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    dataId: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions extends ReadOptions {\n    returnPartialData?: boolean;\n  }\n\n  export interface WatchOptions extends ReadOptions {\n    callback: WatchCallback;\n  }\n\n  export interface EvictOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import WriteDataOptions = DataProxy.WriteDataOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n","interface Node<K, V> {\n  key: K;\n  value: V;\n  newer: Node<K, V> | null;\n  older: Node<K, V> | null;\n}\n\nfunction defaultDispose() {}\n\nexport class Cache<K = any, V = any> {\n  private map = new Map<K, Node<K, V>>();\n  private newest: Node<K, V> | null = null;\n  private oldest: Node<K, V> | null = null;\n\n  constructor(\n    private max = Infinity,\n    public dispose: (value: V, key: K) => void = defaultDispose,\n  ) {}\n\n  public has(key: K) {\n    return this.map.has(key);\n  }\n\n  public get(key: K) {\n    const entry = this.getEntry(key);\n    return entry && entry.value;\n  }\n\n  private getEntry(key: K): Node<K, V> | void {\n    const entry = this.map.get(key);\n\n    if (entry && entry !== this.newest) {\n      const { older, newer } = entry;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      entry.older = this.newest;\n      entry.older!.newer = entry;\n\n      entry.newer = null;\n      this.newest = entry;\n\n      if (entry === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return entry;\n  }\n\n  public set(key: K, value: V) {\n    let entry = this.getEntry(key);\n    if (entry) {\n      return entry.value = value;\n    }\n\n    entry = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = entry;\n    }\n\n    this.newest = entry;\n    this.oldest = this.oldest || entry;\n\n    this.map.set(key, entry);\n\n    return entry.value;\n  }\n\n  public clean() {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n\n  public delete(key: K) {\n    const entry = this.map.get(key);\n    if (entry) {\n      if (entry === this.newest) {\n        this.newest = entry.older;\n      }\n\n      if (entry === this.oldest) {\n        this.oldest = entry.newer;\n      }\n\n      if (entry.newer) {\n        entry.newer.older = entry.older;\n      }\n\n      if (entry.older) {\n        entry.older.newer = entry.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(entry.value, key);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n","type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult>(\n    callback: (...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: any) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = Array as any;\n\nexport const Slot: ReturnType<typeof makeSlotClass> = host[globalKey] || function () {\n  const Slot = makeSlotClass();\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n  } finally {\n    return Slot;\n  }\n}();\n","import { AnyEntry } from \"./entry\";\nimport { Slot } from \"@wry/context\";\n\nexport const parentEntrySlot = new Slot<AnyEntry>();\n\nexport {\n  bind as bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"@wry/context\";\n","import { parentEntrySlot } from \"./context\";\nimport { OptimisticWrapOptions } from \"./index\";\n\nconst reusableEmptyArray: AnyEntry[] = [];\nconst emptySetPool: Set<AnyEntry>[] = [];\nconst POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition: any, optionalMessage?: string) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\n// Since exceptions are cached just like normal values, we need an efficient\n// way of representing unknown, ordinary, and exceptional values.\ntype Value<T> =\n  | []           // unknown\n  | [T]          // known value\n  | [void, any]; // known exception\n\nfunction valueIs(a: Value<any>, b: Value<any>) {\n  const len = a.length;\n  return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n    // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length &&\n    // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet<T>(value: Value<T>): T {\n  switch (value.length) {\n    case 0: throw new Error(\"unknown value\");\n    case 1: return value[0];\n    case 2: throw value[1];\n  }\n}\n\nfunction valueCopy<T>(value: Value<T>): Value<T> {\n  return value.slice(0) as Value<T>;\n}\n\nexport type AnyEntry = Entry<any, any>;\n\nexport class Entry<TArgs extends any[], TValue> {\n  public static count = 0;\n\n  public subscribe: OptimisticWrapOptions<TArgs>[\"subscribe\"];\n  public unsubscribe?: () => any;\n  public reportOrphan?: (this: Entry<TArgs, TValue>) => any;\n\n  public readonly parents = new Set<AnyEntry>();\n  public readonly childValues = new Map<AnyEntry, Value<any>>();\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  public dirtyChildren: Set<AnyEntry> | null = null;\n\n  public dirty = true;\n  public recomputing = false;\n  public readonly value: Value<TValue> = [];\n\n  constructor(\n    public readonly fn: (...args: TArgs) => TValue,\n    public args: TArgs,\n  ) {\n    ++Entry.count;\n  }\n\n  // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n  public recompute(): TValue {\n    assert(! this.recomputing, \"already recomputing\");\n\n    if (! rememberParent(this) && maybeReportOrphan(this)) {\n      // The recipient of the entry.reportOrphan callback decided to dispose\n      // of this orphan entry by calling entry.dispose(), so we don't need to\n      // (and should not) proceed with the recomputation.\n      return void 0 as any;\n    }\n\n    return mightBeDirty(this)\n      ? reallyRecompute(this)\n      : valueGet(this.value);\n  }\n\n  public setDirty() {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this);\n    // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n    maybeUnsubscribe(this);\n  }\n\n  public dispose() {\n    forgetChildren(this).forEach(maybeReportOrphan);\n    maybeUnsubscribe(this);\n\n    // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n    this.parents.forEach(parent => {\n      parent.setDirty();\n      forgetChild(parent, this);\n    });\n  }\n}\n\nfunction rememberParent(child: AnyEntry) {\n  const parent = parentEntrySlot.getValue();\n  if (parent) {\n    child.parents.add(parent);\n\n    if (! parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry: AnyEntry) {\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  const originalChildren = forgetChildren(entry);\n\n  // Set entry as the parent entry while calling recomputeNewValue(entry).\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\n\n  if (maybeSubscribe(entry)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry: AnyEntry) {\n  entry.recomputing = true;\n  // Set entry.value as unknown.\n  entry.value.length = 0;\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, entry.args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  }\n  // Either way, this line is always reached.\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry: AnyEntry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry: AnyEntry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child: AnyEntry) {\n  child.parents.forEach(parent => reportDirtyChild(parent, child));\n}\n\nfunction reportClean(child: AnyEntry) {\n  child.parents.forEach(parent => reportCleanChild(parent, child));\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n  reportDirty(parent);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(! mightBeDirty(child));\n\n  const childValue = parent.childValues.get(child)!;\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (! valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  const dc = parent.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      parent.dirtyChildren = null;\n    }\n  }\n}\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry: AnyEntry) {\n  return entry.parents.size === 0 &&\n    typeof entry.reportOrphan === \"function\" &&\n    entry.reportOrphan() === true;\n}\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent: AnyEntry) {\n  let children = reusableEmptyArray;\n\n  if (parent.childValues.size > 0) {\n    children = [];\n    parent.childValues.forEach((_value, child) => {\n      forgetChild(parent, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n  assert(parent.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(parent: AnyEntry, child: AnyEntry) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry: AnyEntry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction maybeUnsubscribe(entry: AnyEntry) {\n  const { unsubscribe } = entry;\n  if (typeof unsubscribe === \"function\") {\n    entry.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n","// A trie data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nexport class KeyTrie<K> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, KeyTrie<K>>;\n  private strong?: Map<any, KeyTrie<K>>;\n  private data?: K;\n\n  constructor(private readonly weakness: boolean) {}\n\n  public lookup<T extends any[]>(...array: T): K {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends any[]>(array: T): K {\n    let node: KeyTrie<K> = this;\n    array.forEach(key => node = node.getChildTrie(key));\n    return node.data || (node.data = Object.create(null));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, KeyTrie<K>>())\n      : this.strong || (this.strong = new Map<any, KeyTrie<K>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new KeyTrie<K>(this.weakness));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\nimport { InvariantError } from 'ts-invariant';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: WindowOrWorkerGlobalScope['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.name = 'ServerError';\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.name = 'ServerParseError';\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: WindowOrWorkerGlobalScope['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new InvariantError(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new InvariantError(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it cant pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n","/* tslint:disable */\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch if nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders['apollographql-client-name'] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders['apollographql-client-version'] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so it's already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we don't call next, the UI can only show networkError because AC didn't\n            // get any graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n"],"sourceRoot":""}